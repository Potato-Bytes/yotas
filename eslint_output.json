[{"filePath":"/Users/saaya.aizawa/yotas/yotas/.eslintrc.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/App.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":14,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":14,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[352,380],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * yotas - Location-based Review App\n * @format\n */\n\nimport React from 'react';\nimport { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport AppNavigator from './src/navigation/AppNavigator';\n\nconst queryClient = new QueryClient();\n\nfunction App() {\n  console.log('App: レンダリング中');\n  const isDarkMode = useColorScheme() === 'dark';\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <View style={styles.container}>\n        <StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} />\n        <AppNavigator />\n      </View>\n    </QueryClientProvider>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n\nexport default App;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/__tests__/App.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/babel.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/jest.setup.js","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":78,"column":19,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":78,"endColumn":35},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":79,"column":22,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":79,"endColumn":45}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// React Native Testing Library setup\n// Note: extend-expect is included by default in newer versions\n\n// Firebase mocksを追加\njest.mock('@react-native-firebase/app', () => ({\n  utils: () => ({\n    FilePath: {\n      PICTURES_DIRECTORY: '/tmp/pictures',\n    },\n  }),\n}));\n\njest.mock('@react-native-firebase/firestore', () => ({\n  __esModule: true,\n  default: jest.fn(() => ({\n    collection: jest.fn(() => ({\n      doc: jest.fn(() => ({\n        set: jest.fn(() => Promise.resolve()),\n        get: jest.fn(() => Promise.resolve({ exists: false })),\n        update: jest.fn(() => Promise.resolve()),\n        delete: jest.fn(() => Promise.resolve()),\n      })),\n      add: jest.fn(() => Promise.resolve({ id: 'mock-id' })),\n      where: jest.fn(() => ({\n        get: jest.fn(() => Promise.resolve({ empty: true, docs: [] })),\n        orderBy: jest.fn(() => ({\n          limit: jest.fn(() => ({\n            get: jest.fn(() => Promise.resolve({ empty: true, docs: [] })),\n          })),\n        })),\n      })),\n    })),\n  })),\n}));\n\njest.mock('@react-native-firebase/auth', () => ({\n  __esModule: true,\n  default: jest.fn(() => ({\n    currentUser: null,\n    signInWithEmailAndPassword: jest.fn(() => Promise.resolve()),\n    createUserWithEmailAndPassword: jest.fn(() => Promise.resolve()),\n    signOut: jest.fn(() => Promise.resolve()),\n  })),\n}));\n\njest.mock('@react-native-firebase/storage', () => ({\n  __esModule: true,\n  default: jest.fn(() => ({\n    ref: jest.fn(() => ({\n      putFile: jest.fn(() => Promise.resolve()),\n      getDownloadURL: jest.fn(() => Promise.resolve('https://example.com/image.jpg')),\n    })),\n  })),\n}));\n\n// React Navigation mocks\njest.mock('@react-navigation/native', () => ({\n  useNavigation: () => ({\n    navigate: jest.fn(),\n    goBack: jest.fn(),\n    reset: jest.fn(),\n  }),\n  useRoute: () => ({\n    params: {},\n  }),\n  NavigationContainer: ({ children }) => children,\n}));\n\n// SafeAreaProvider mock\njest.mock('react-native-safe-area-context', () => ({\n  SafeAreaProvider: ({ children }) => children,\n  useSafeAreaInsets: () => ({ top: 0, bottom: 0, left: 0, right: 0 }),\n}));\n\n// React Native Vector Icons mock\njest.mock('react-native-vector-icons/Ionicons', () => {\n  const Icon = ({ name, ...props }) => {\n    const React = require('react');\n    const { Text } = require('react-native');\n    return React.createElement(Text, { ...props }, `Icon-${name}`);\n  };\n  return Icon;\n});\n\n// React Native Async Storage mock\njest.mock('@react-native-async-storage/async-storage', () => ({\n  setItem: jest.fn(() => Promise.resolve()),\n  getItem: jest.fn(() => Promise.resolve(null)),\n  removeItem: jest.fn(() => Promise.resolve()),\n  clear: jest.fn(() => Promise.resolve()),\n}));\n\n// Alert mock - use a more targeted approach\njest.mock('react-native/Libraries/Alert/Alert', () => ({\n  alert: jest.fn(),\n  prompt: jest.fn(),\n}));\n\n// Modal mock - React Native Modal doesn't render children in tests by default\njest.mock('react-native/Libraries/Modal/Modal', () => {\n  const mockModal = ({ children, visible }) => {\n    if (visible) {\n      return children;\n    }\n    return null;\n  };\n  return mockModal;\n});\n\n// Console warning suppression for tests\nglobal.console = {\n  ...console,\n  warn: jest.fn(),\n  error: jest.fn(),\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/metro.config.js","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":1,"column":43,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":1,"endColumn":80}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');\n\n/**\n * Metro configuration\n * https://reactnative.dev/docs/metro\n *\n * @type {import('@react-native/metro-config').MetroConfig}\n */\nconst config = {};\n\nmodule.exports = mergeConfig(getDefaultConfig(__dirname), config);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/__tests__/integration/report-flow.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[858,861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[858,861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1052,1055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1052,1055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1462,1465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1462,1465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":338,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10189,10192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10189,10192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Alert } from 'react-native';\nimport { render, fireEvent, waitFor, mockUser, mockToilet } from '../../test-utils';\n\n// Mock Alert\njest.mock('react-native/Libraries/Alert/Alert', () => ({\n  alert: jest.fn(),\n  prompt: jest.fn(),\n}));\nimport ReportModal from '../../components/report/ReportModal';\nimport ReportHistoryScreen from '../../screens/report/ReportHistoryScreen';\nimport { ReportTargetType, ReportReason } from '../../types/post';\n\n// Mock functions defined first\nconst mockSubmitReport = jest.fn();\nconst mockGetUserReports = jest.fn();\nconst mockGetUserRestrictions = jest.fn();\nconst mockGetUserViolationPoints = jest.fn();\n\n// Mock dependencies\njest.mock('../../stores/authStore', () => ({\n  useAuth: () => ({ user: mockUser }),\n}));\n\n// Create a mock hook that can be updated per test\nconst mockUseReportHook: any = {\n  submitReport: mockSubmitReport,\n  reports: [],\n  userRestrictions: [],\n  violationPoints: 0,\n  isLoading: false,\n  isSubmitting: false,\n  error: null,\n  getReasonDisplayName: (reason: any) => {\n    const names: Record<string, string> = {\n      inappropriate_content: '不適切なコンテンツ',\n      spam: 'スパム',\n      harassment: '嫌がらせ',\n      fake_information: '虚偽情報',\n      copyright_violation: '著作権侵害',\n      privacy_violation: 'プライバシー侵害',\n      commercial_spam: '商業的スパム',\n      hate_speech: 'ヘイトスピーチ',\n      other: 'その他',\n    };\n    return names[reason] || reason;\n  },\n  getStatusDisplayName: (status: any) => {\n    const names: Record<string, string> = {\n      pending: '審査待ち',\n      under_review: '審査中',\n      resolved: '解決済み',\n      dismissed: '却下',\n      auto_resolved: '自動解決',\n    };\n    return names[status] || status;\n  },\n  getStatusColor: () => '#FF9800',\n  hasActiveRestrictions: () => false,\n  getActiveRestrictionTypes: () => [],\n  isNearViolationLimit: () => false,\n  refresh: jest.fn(),\n  reportCount: 0,\n  activeRestrictionCount: 0,\n  isHighRiskUser: false,\n};\n\njest.mock('../../hooks/useReport', () => ({\n  useReport: () => mockUseReportHook,\n}));\n\njest.mock('../../services/reportService', () => ({\n  reportService: {\n    submitReport: mockSubmitReport,\n    getUserReports: mockGetUserReports,\n    getUserRestrictions: mockGetUserRestrictions,\n    getUserViolationPoints: mockGetUserViolationPoints,\n    isUserRestricted: jest.fn().mockResolvedValue({ restricted: false }),\n  },\n}));\n\ndescribe('Report Flow Integration', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockSubmitReport.mockResolvedValue(undefined);\n    mockGetUserReports.mockResolvedValue([]);\n    mockGetUserRestrictions.mockResolvedValue([]);\n    mockGetUserViolationPoints.mockResolvedValue(0);\n\n    // Reset mock hook data\n    mockUseReportHook.reports = [];\n    mockUseReportHook.userRestrictions = [];\n    mockUseReportHook.violationPoints = 0;\n    mockUseReportHook.isLoading = false;\n    mockUseReportHook.isSubmitting = false;\n    mockUseReportHook.error = null;\n    mockUseReportHook.hasActiveRestrictions = () => false;\n    mockUseReportHook.isNearViolationLimit = () => false;\n  });\n\n  describe('Report Submission Flow', () => {\n    it('should complete full report submission flow', async () => {\n      const onClose = jest.fn();\n\n      const { getByText, getByPlaceholderText } = render(\n        <ReportModal\n          visible={true}\n          onClose={onClose}\n          targetType={ReportTargetType.TOILET}\n          targetId={mockToilet.id}\n          targetTitle={mockToilet.title}\n        />,\n      );\n\n      // Step 1: Select report reason\n      const spamOption = getByText('スパム');\n      fireEvent.press(spamOption);\n\n      // Should navigate to details step\n      await waitFor(() => {\n        expect(getByText('詳細情報（任意）')).toBeTruthy();\n      });\n\n      // Step 2: Add description\n      const descriptionInput = getByPlaceholderText('問題の詳細を入力してください（任意）');\n      fireEvent.changeText(descriptionInput, 'This is spam content');\n\n      // Press next\n      const nextButton = getByText('次へ');\n      fireEvent.press(nextButton);\n\n      // Step 3: Confirmation\n      await waitFor(() => {\n        expect(getByText('通報内容の確認')).toBeTruthy();\n      });\n\n      // Verify report details are shown\n      expect(getByText('理由:')).toBeTruthy();\n      expect(getByText('スパム')).toBeTruthy();\n      expect(getByText('詳細:')).toBeTruthy();\n      expect(getByText('This is spam content')).toBeTruthy();\n\n      // Submit report\n      const submitButton = getByText('通報を送信');\n      fireEvent.press(submitButton);\n\n      await waitFor(() => {\n        expect(mockSubmitReport).toHaveBeenCalledWith(\n          mockUser.uid,\n          ReportTargetType.TOILET,\n          mockToilet.id,\n          ReportReason.SPAM,\n          'This is spam content',\n          undefined,\n        );\n      });\n\n      // Verify success alert\n      expect(Alert.alert).toHaveBeenCalledWith(\n        '通報完了',\n        '通報を受け付けました。確認後、適切な対応を行います。',\n        [{ text: 'OK' }],\n      );\n\n      // Modal should close\n      expect(onClose).toHaveBeenCalled();\n    });\n\n    it('should handle report submission without description', async () => {\n      const onClose = jest.fn();\n\n      const { getByText } = render(\n        <ReportModal\n          visible={true}\n          onClose={onClose}\n          targetType={ReportTargetType.TOILET}\n          targetId={mockToilet.id}\n          targetTitle={mockToilet.title}\n        />,\n      );\n\n      // Select reason\n      const harassmentOption = getByText('嫌がらせ');\n      fireEvent.press(harassmentOption);\n\n      // Skip description and go to next\n      await waitFor(() => {\n        const nextButton = getByText('次へ');\n        fireEvent.press(nextButton);\n      });\n\n      // Submit without description\n      await waitFor(() => {\n        const submitButton = getByText('通報を送信');\n        fireEvent.press(submitButton);\n      });\n\n      await waitFor(() => {\n        expect(mockSubmitReport).toHaveBeenCalledWith(\n          mockUser.uid,\n          ReportTargetType.TOILET,\n          mockToilet.id,\n          ReportReason.HARASSMENT,\n          undefined,\n          undefined,\n        );\n      });\n    });\n\n    it('should handle report submission error', async () => {\n      mockSubmitReport.mockRejectedValueOnce(new Error('Network error'));\n      const onClose = jest.fn();\n\n      const { getByText } = render(\n        <ReportModal\n          visible={true}\n          onClose={onClose}\n          targetType={ReportTargetType.TOILET}\n          targetId={mockToilet.id}\n        />,\n      );\n\n      // Quick submission\n      fireEvent.press(getByText('その他'));\n      await waitFor(() => fireEvent.press(getByText('次へ')));\n      await waitFor(() => fireEvent.press(getByText('通報を送信')));\n\n      await waitFor(() => {\n        expect(Alert.alert).toHaveBeenCalledWith('エラー', '通報の送信に失敗しました');\n      });\n\n      // Modal should not close on error\n      expect(onClose).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Report History Display', () => {\n    it('should display user reports in history', async () => {\n      const mockReports = [\n        {\n          id: 'report-1',\n          reporterId: mockUser.uid,\n          targetType: ReportTargetType.TOILET,\n          targetId: 'toilet-1',\n          reason: ReportReason.SPAM,\n          description: 'Spam content',\n          status: 'pending' as const,\n          createdAt: new Date('2024-01-01'),\n        },\n        {\n          id: 'report-2',\n          reporterId: mockUser.uid,\n          targetType: ReportTargetType.USER,\n          targetId: 'user-456',\n          reason: ReportReason.HARASSMENT,\n          status: 'resolved' as const,\n          createdAt: new Date('2024-01-02'),\n          resolution: 'Action taken against user',\n        },\n      ];\n\n      // Update mock hook with test data\n      mockUseReportHook.reports = mockReports;\n\n      const { getByText } = render(<ReportHistoryScreen />);\n\n      await waitFor(() => {\n        expect(getByText('通報統計')).toBeTruthy();\n        expect(getByText('2')).toBeTruthy(); // Total reports\n        expect(getByText('総通報数')).toBeTruthy();\n      });\n\n      // Check report items\n      expect(getByText('理由: スパム')).toBeTruthy();\n      expect(getByText('理由: 嫌がらせ')).toBeTruthy();\n      expect(getByText('審査待ち')).toBeTruthy();\n      expect(getByText('解決済み')).toBeTruthy();\n    });\n\n    it('should display user restrictions', async () => {\n      const mockRestrictions = [\n        {\n          id: 'restriction-1',\n          userId: mockUser.uid,\n          type: 'post_restriction' as const,\n          reason: '複数の違反により投稿が制限されています',\n          startDate: new Date(),\n          endDate: new Date(Date.now() + 86400000), // 1 day later\n          isActive: true,\n          createdBy: 'system' as const,\n        },\n      ];\n\n      // Update mock hook with test data\n      mockUseReportHook.userRestrictions = mockRestrictions;\n      mockUseReportHook.violationPoints = 15;\n      mockUseReportHook.hasActiveRestrictions = () => true;\n      mockUseReportHook.isNearViolationLimit = () => true;\n\n      const { getByText } = render(<ReportHistoryScreen />);\n\n      await waitFor(() => {\n        // Violation points\n        expect(getByText('違反ポイント')).toBeTruthy();\n        expect(getByText('15 / 20')).toBeTruthy();\n\n        // Warning message\n        expect(getByText(/違反ポイントが高くなっています/)).toBeTruthy();\n\n        // Active restrictions\n        expect(getByText('利用制限')).toBeTruthy();\n        expect(getByText('投稿制限')).toBeTruthy();\n        expect(getByText('複数の違反により投稿が制限されています')).toBeTruthy();\n      });\n    });\n\n    it('should handle report detail press', async () => {\n      const mockReports = [\n        {\n          id: 'report-1',\n          reporterId: mockUser.uid,\n          targetType: ReportTargetType.TOILET,\n          targetId: 'toilet-1',\n          reason: ReportReason.FAKE_INFORMATION,\n          description: 'Contains false information',\n          status: 'under_review' as const,\n          createdAt: new Date('2024-01-01'),\n        },\n      ];\n\n      // Update mock hook with test data\n      mockUseReportHook.reports = mockReports;\n\n      const { getByText } = render(<ReportHistoryScreen />);\n\n      await waitFor(() => {\n        const reportItem = getByText('理由: 虚偽情報');\n        fireEvent.press(reportItem.parent?.parent as any);\n      });\n\n      // Should show alert with details\n      expect(Alert.alert).toHaveBeenCalledWith(\n        '通報詳細',\n        expect.stringContaining('ID: report-1'),\n        [{ text: 'OK' }],\n      );\n    });\n  });\n\n  describe('Report Flow with Restrictions', () => {\n    it('should prevent report submission when user is restricted', async () => {\n      // Mock user has report restriction\n      const mockIsUserRestricted = jest.fn().mockResolvedValue({\n        restricted: true,\n        reason: 'あなたは通報機能の使用が制限されています',\n        endDate: new Date(Date.now() + 86400000),\n      });\n\n      jest.doMock('../../services/reportService', () => ({\n        reportService: {\n          isUserRestricted: mockIsUserRestricted,\n        },\n      }));\n\n      // This would typically be integrated with the actual flow\n      // For now, we're testing the concept\n      const restriction = await mockIsUserRestricted(mockUser.uid, 'report');\n\n      expect(restriction.restricted).toBe(true);\n      expect(restriction.reason).toBeTruthy();\n    });\n  });\n\n  describe('Report Statistics Update', () => {\n    it('should update statistics after successful report', async () => {\n      const onClose = jest.fn();\n\n      const { getByText, rerender } = render(\n        <ReportModal\n          visible={true}\n          onClose={onClose}\n          targetType={ReportTargetType.TOILET}\n          targetId={mockToilet.id}\n        />,\n      );\n\n      // Submit a report\n      fireEvent.press(getByText('スパム'));\n      await waitFor(() => fireEvent.press(getByText('次へ')));\n      await waitFor(() => fireEvent.press(getByText('通報を送信')));\n\n      // Update mock with new report after submission\n      mockUseReportHook.reports = [\n        {\n          id: 'new-report',\n          reporterId: mockUser.uid,\n          targetType: ReportTargetType.TOILET,\n          targetId: mockToilet.id,\n          reason: ReportReason.SPAM,\n          status: 'pending' as const,\n          createdAt: new Date(),\n        },\n      ];\n\n      // Switch to history screen\n      rerender(<ReportHistoryScreen />);\n\n      await waitFor(() => {\n        expect(getByText('1')).toBeTruthy(); // Updated total count\n      });\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/badge/BadgeItem.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { opacity: 'unlocked ? 1 : 0.3' }","line":62,"column":11,"nodeType":"ObjectExpression","endLine":65,"endColumn":12},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"unlocked ? rarityColor : '#ccc'\" }","line":75,"column":11,"nodeType":"ObjectExpression","endLine":77,"endColumn":12},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"unlocked ? '#333' : '#999'\" }","line":85,"column":11,"nodeType":"ObjectExpression","endLine":88,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity } from 'react-native';\nimport { Badge, BadgeRarity } from '../../types/post';\nimport { RARITY_COLORS, CATEGORY_COLORS } from '../../data/badges';\n\ninterface BadgeItemProps {\n  badge: Badge;\n  unlocked: boolean;\n  size?: 'small' | 'medium' | 'large';\n  onPress?: () => void;\n  showDetails?: boolean;\n}\n\nconst BadgeItem: React.FC<BadgeItemProps> = ({\n  badge,\n  unlocked,\n  size = 'medium',\n  onPress,\n  showDetails = false,\n}) => {\n  const sizeConfig = {\n    small: {\n      container: 60,\n      icon: 24,\n      fontSize: 10,\n    },\n    medium: {\n      container: 80,\n      icon: 32,\n      fontSize: 12,\n    },\n    large: {\n      container: 100,\n      icon: 40,\n      fontSize: 14,\n    },\n  };\n\n  const config = sizeConfig[size];\n  const rarityColor = RARITY_COLORS[badge.rarity];\n  const categoryColor = CATEGORY_COLORS[badge.category];\n\n  const containerStyle = [\n    styles.container,\n    {\n      width: config.container,\n      height: config.container,\n      borderColor: unlocked ? rarityColor : '#e0e0e0',\n      backgroundColor: unlocked ? `${rarityColor}15` : '#f5f5f5',\n    },\n    !unlocked && styles.lockedContainer,\n  ];\n\n  const Component = onPress ? TouchableOpacity : View;\n\n  return (\n    <Component style={containerStyle} onPress={onPress} activeOpacity={onPress ? 0.7 : 1}>\n      {/* バッジアイコン */}\n      <Text\n        style={[\n          styles.icon,\n          {\n            fontSize: config.icon,\n            opacity: unlocked ? 1 : 0.3,\n          },\n        ]}\n      >\n        {badge.icon}\n      </Text>\n\n      {/* レア度インジケーター */}\n      <View\n        style={[\n          styles.rarityIndicator,\n          {\n            backgroundColor: unlocked ? rarityColor : '#ccc',\n          },\n        ]}\n      />\n\n      {/* バッジ名 */}\n      <Text\n        style={[\n          styles.name,\n          {\n            fontSize: config.fontSize,\n            color: unlocked ? '#333' : '#999',\n          },\n        ]}\n        numberOfLines={2}\n      >\n        {badge.name}\n      </Text>\n\n      {/* ロック状態 */}\n      {!unlocked && (\n        <View style={styles.lockOverlay}>\n          <Text style={styles.lockIcon}>🔒</Text>\n        </View>\n      )}\n\n      {/* 詳細情報 */}\n      {showDetails && (\n        <View style={styles.detailsContainer}>\n          <Text style={styles.description} numberOfLines={3}>\n            {badge.description}\n          </Text>\n\n          <View style={styles.metaContainer}>\n            <View style={[styles.categoryBadge, { backgroundColor: categoryColor }]}>\n              <Text style={styles.categoryText}>{getCategoryDisplayName(badge.category)}</Text>\n            </View>\n\n            <Text style={styles.rarityText}>{getRarityDisplayName(badge.rarity)}</Text>\n          </View>\n\n          {badge.unlockedAt && (\n            <Text style={styles.unlockedDate}>取得日: {badge.unlockedAt.toLocaleDateString()}</Text>\n          )}\n        </View>\n      )}\n    </Component>\n  );\n};\n\n// カテゴリ表示名\nconst getCategoryDisplayName = (category: string): string => {\n  const categoryNames = {\n    posting: '投稿',\n    reviewing: 'レビュー',\n    exploration: '探索',\n    community: 'コミュニティ',\n    special: '特別',\n  };\n  return categoryNames[category as keyof typeof categoryNames] || category;\n};\n\n// レア度表示名\nconst getRarityDisplayName = (rarity: BadgeRarity): string => {\n  const rarityNames = {\n    [BadgeRarity.COMMON]: 'コモン',\n    [BadgeRarity.UNCOMMON]: 'アンコモン',\n    [BadgeRarity.RARE]: 'レア',\n    [BadgeRarity.EPIC]: 'エピック',\n    [BadgeRarity.LEGENDARY]: 'レジェンダリー',\n  };\n  return rarityNames[rarity];\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    borderRadius: 12,\n    borderWidth: 2,\n    padding: 8,\n    alignItems: 'center',\n    justifyContent: 'center',\n    position: 'relative',\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.1,\n    shadowRadius: 3,\n    elevation: 3,\n  },\n  lockedContainer: {\n    opacity: 0.6,\n  },\n  icon: {\n    textAlign: 'center',\n    marginBottom: 4,\n  },\n  rarityIndicator: {\n    position: 'absolute',\n    top: 4,\n    right: 4,\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n  },\n  name: {\n    textAlign: 'center',\n    fontWeight: '600',\n    lineHeight: 14,\n  },\n  lockOverlay: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n    borderRadius: 10,\n  },\n  lockIcon: {\n    fontSize: 16,\n    opacity: 0.7,\n  },\n  detailsContainer: {\n    marginTop: 8,\n    padding: 12,\n    backgroundColor: '#f8f9fa',\n    borderRadius: 8,\n    width: '100%',\n  },\n  description: {\n    fontSize: 14,\n    color: '#333',\n    lineHeight: 20,\n    marginBottom: 8,\n  },\n  metaContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: 4,\n  },\n  categoryBadge: {\n    paddingHorizontal: 8,\n    paddingVertical: 2,\n    borderRadius: 10,\n  },\n  categoryText: {\n    color: '#fff',\n    fontSize: 10,\n    fontWeight: '600',\n  },\n  rarityText: {\n    fontSize: 10,\n    color: '#666',\n    fontWeight: '500',\n  },\n  unlockedDate: {\n    fontSize: 10,\n    color: '#999',\n    textAlign: 'right',\n  },\n});\n\nexport default BadgeItem;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/common/StarRating.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"isFilled || isHalfFilled ? color : '#E0E0E0'\" }","line":60,"column":17,"nodeType":"ObjectExpression","endLine":63,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo } from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet } from 'react-native';\n\ninterface StarRatingProps {\n  rating: number;\n  maxRating?: number;\n  onRatingChange?: (rating: number) => void;\n  size?: number;\n  color?: string;\n  disabled?: boolean;\n  showValue?: boolean;\n  required?: boolean;\n  label?: string;\n  description?: string;\n}\n\nconst StarRating: React.FC<StarRatingProps> = ({\n  rating,\n  maxRating = 5,\n  onRatingChange,\n  size = 24,\n  color = '#FFD700',\n  disabled = false,\n  showValue = true,\n  required = false,\n  label,\n  description,\n}) => {\n  const handleStarPress = useCallback(\n    (starRating: number) => {\n      if (!disabled && onRatingChange) {\n        onRatingChange(starRating);\n      }\n    },\n    [disabled, onRatingChange],\n  );\n\n  // メモ化された評価値表示\n  const displayRating = useMemo(() => (rating > 0 ? `${rating.toFixed(1)}` : '未評価'), [rating]);\n\n  // メモ化された星の配列\n  const stars = useMemo(\n    () =>\n      Array.from({ length: maxRating }, (_, index) => {\n        const starNumber = index + 1;\n        const isFilled = starNumber <= rating;\n        const isHalfFilled = starNumber - 0.5 === rating;\n\n        return (\n          <TouchableOpacity\n            key={starNumber}\n            style={[styles.star, { width: size, height: size }]}\n            onPress={() => handleStarPress(starNumber)}\n            disabled={disabled}\n            activeOpacity={0.7}\n          >\n            <Text\n              style={[\n                styles.starText,\n                {\n                  fontSize: size,\n                  color: isFilled || isHalfFilled ? color : '#E0E0E0',\n                },\n              ]}\n            >\n              {isFilled ? '★' : isHalfFilled ? '☆' : '☆'}\n            </Text>\n          </TouchableOpacity>\n        );\n      }),\n    [maxRating, rating, size, color, disabled, handleStarPress],\n  );\n\n  return (\n    <View style={styles.container}>\n      {label && (\n        <View style={styles.labelContainer}>\n          <Text style={styles.label}>\n            {label}\n            {required && <Text style={styles.required}> *</Text>}\n          </Text>\n          {description && <Text style={styles.description}>{description}</Text>}\n        </View>\n      )}\n\n      <View style={styles.ratingContainer}>\n        <View style={styles.starsContainer}>{stars}</View>\n\n        {showValue && <Text style={styles.ratingValue}>{displayRating}</Text>}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    marginVertical: 8,\n  },\n  labelContainer: {\n    marginBottom: 8,\n  },\n  label: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n  },\n  required: {\n    color: '#ff4757',\n  },\n  description: {\n    fontSize: 12,\n    color: '#666',\n    marginTop: 2,\n  },\n  ratingContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  starsContainer: {\n    flexDirection: 'row',\n    marginRight: 12,\n  },\n  star: {\n    marginRight: 4,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  starText: {\n    textAlign: 'center',\n    lineHeight: undefined, // デフォルトにリセット\n  },\n  ratingValue: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n    minWidth: 45,\n  },\n});\n\n// React.memo with custom comparison for performance optimization\nexport default React.memo(\n  StarRating,\n  (prevProps, nextProps) =>\n    prevProps.rating === nextProps.rating &&\n    prevProps.maxRating === nextProps.maxRating &&\n    prevProps.size === nextProps.size &&\n    prevProps.color === nextProps.color &&\n    prevProps.disabled === nextProps.disabled &&\n    prevProps.showValue === nextProps.showValue &&\n    prevProps.required === nextProps.required &&\n    prevProps.label === nextProps.label &&\n    prevProps.description === nextProps.description &&\n    prevProps.onRatingChange === nextProps.onRatingChange,\n);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/common/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/map/LocationPicker.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'width' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":22,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'height' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":22,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1933,1936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1933,1936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useState, useCallback, useEffect } from 'react';\nimport {\n  View,\n  StyleSheet,\n  TouchableOpacity,\n  Text,\n  Alert,\n  Dimensions,\n} from 'react-native';\nimport MapView, { PROVIDER_GOOGLE, Region, Marker } from 'react-native-maps';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { Coordinate, DEFAULT_MAP_REGION } from '../../types/maps';\nimport { useLocation } from '../../hooks/useLocation';\n\ninterface LocationPickerProps {\n  selectedLocation: Coordinate | null;\n  onLocationSelect: (location: Coordinate) => void;\n  onCancel: () => void;\n  onConfirm: () => void;\n}\n\nconst { width, height } = Dimensions.get('window');\n\nconst LocationPicker: React.FC<LocationPickerProps> = ({\n  selectedLocation,\n  onLocationSelect,\n  onCancel,\n  onConfirm,\n}) => {\n  const mapRef = useRef<MapView>(null);\n  const [currentRegion, setCurrentRegion] = useState<Region>(\n    selectedLocation\n      ? {\n          latitude: selectedLocation.latitude,\n          longitude: selectedLocation.longitude,\n          latitudeDelta: 0.01,\n          longitudeDelta: 0.01,\n        }\n      : DEFAULT_MAP_REGION\n  );\n\n  const {\n    getCurrentLocation,\n    isLoading: isLocationLoading,\n    showLocationError,\n  } = useLocation();\n\n  // 現在位置に移動\n  const moveToCurrentLocation = useCallback(async () => {\n    try {\n      const userLocation = await getCurrentLocation();\n      if (userLocation && mapRef.current) {\n        const region: Region = {\n          latitude: userLocation.latitude,\n          longitude: userLocation.longitude,\n          latitudeDelta: 0.01,\n          longitudeDelta: 0.01,\n        };\n\n        mapRef.current.animateToRegion(region, 1000);\n        setCurrentRegion(region);\n        onLocationSelect(userLocation);\n      }\n    } catch (error) {\n      showLocationError();\n    }\n  }, [getCurrentLocation, showLocationError, onLocationSelect]);\n\n  // 地図タップ時の処理\n  const handleMapPress = useCallback((event: any) => {\n    const { coordinate } = event.nativeEvent;\n    onLocationSelect(coordinate);\n  }, [onLocationSelect]);\n\n  // 地図の領域変更時の処理\n  const handleRegionChangeComplete = useCallback((region: Region) => {\n    setCurrentRegion(region);\n  }, []);\n\n  // 確定前の確認\n  const handleConfirm = useCallback(() => {\n    if (!selectedLocation) {\n      Alert.alert('エラー', '位置を選択してください');\n      return;\n    }\n\n    Alert.alert(\n      '位置の確認',\n      '選択した位置でよろしいですか？',\n      [\n        { text: 'キャンセル', style: 'cancel' },\n        { text: '確定', onPress: onConfirm },\n      ]\n    );\n  }, [selectedLocation, onConfirm]);\n\n  // 初期位置を現在地に設定\n  useEffect(() => {\n    if (!selectedLocation) {\n      moveToCurrentLocation();\n    }\n  }, [selectedLocation, moveToCurrentLocation]);\n\n  return (\n    <View style={styles.container}>\n      {/* ヘッダー */}\n      <View style={styles.header}>\n        <TouchableOpacity style={styles.headerButton} onPress={onCancel}>\n          <Icon name=\"close\" size={24} color=\"#333\" />\n        </TouchableOpacity>\n        <Text style={styles.headerTitle}>位置を選択</Text>\n        <TouchableOpacity \n          style={[styles.headerButton, styles.confirmButton]} \n          onPress={handleConfirm}\n        >\n          <Text style={styles.confirmButtonText}>確定</Text>\n        </TouchableOpacity>\n      </View>\n\n      {/* 地図 */}\n      <View style={styles.mapContainer}>\n        <MapView\n          ref={mapRef}\n          provider={PROVIDER_GOOGLE}\n          style={styles.map}\n          region={currentRegion}\n          onRegionChangeComplete={handleRegionChangeComplete}\n          onPress={handleMapPress}\n          showsUserLocation={true}\n          showsMyLocationButton={false}\n          showsCompass={true}\n        >\n          {selectedLocation && (\n            <Marker\n              coordinate={selectedLocation}\n              draggable={true}\n              onDragEnd={(event) => {\n                onLocationSelect(event.nativeEvent.coordinate);\n              }}\n            >\n              <View style={styles.markerContainer}>\n                <Icon name=\"location\" size={30} color=\"#ff4757\" />\n              </View>\n            </Marker>\n          )}\n        </MapView>\n\n        {/* 中央の十字線（地図タップ用のガイド） */}\n        <View style={styles.crosshair}>\n          <View style={styles.crosshairHorizontal} />\n          <View style={styles.crosshairVertical} />\n        </View>\n\n        {/* 現在位置ボタン */}\n        <TouchableOpacity\n          style={[styles.locationButton, isLocationLoading && styles.loadingButton]}\n          onPress={moveToCurrentLocation}\n          disabled={isLocationLoading}\n        >\n          <Icon \n            name={isLocationLoading ? \"refresh\" : \"locate\"} \n            size={24} \n            color=\"#4285f4\" \n          />\n        </TouchableOpacity>\n      </View>\n\n      {/* 底部の説明 */}\n      <View style={styles.instructions}>\n        <Text style={styles.instructionText}>\n          📍 地図をタップまたはマーカーをドラッグして位置を選択してください\n        </Text>\n        {selectedLocation && (\n          <View style={styles.coordinates}>\n            <Text style={styles.coordinateText}>\n              緯度: {selectedLocation.latitude.toFixed(6)}\n            </Text>\n            <Text style={styles.coordinateText}>\n              経度: {selectedLocation.longitude.toFixed(6)}\n            </Text>\n          </View>\n        )}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n    backgroundColor: '#fff',\n  },\n  headerButton: {\n    padding: 8,\n    borderRadius: 8,\n  },\n  confirmButton: {\n    backgroundColor: '#4285f4',\n    paddingHorizontal: 16,\n  },\n  confirmButtonText: {\n    color: '#fff',\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  headerTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n  },\n  mapContainer: {\n    flex: 1,\n    position: 'relative',\n  },\n  map: {\n    flex: 1,\n  },\n  crosshair: {\n    position: 'absolute',\n    top: '50%',\n    left: '50%',\n    width: 20,\n    height: 20,\n    marginTop: -10,\n    marginLeft: -10,\n    pointerEvents: 'none',\n  },\n  crosshairHorizontal: {\n    position: 'absolute',\n    top: 9,\n    left: 0,\n    width: 20,\n    height: 2,\n    backgroundColor: '#ff4757',\n  },\n  crosshairVertical: {\n    position: 'absolute',\n    top: 0,\n    left: 9,\n    width: 2,\n    height: 20,\n    backgroundColor: '#ff4757',\n  },\n  locationButton: {\n    position: 'absolute',\n    right: 16,\n    bottom: 100,\n    width: 50,\n    height: 50,\n    borderRadius: 25,\n    backgroundColor: '#fff',\n    justifyContent: 'center',\n    alignItems: 'center',\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.25,\n    shadowRadius: 4,\n    elevation: 5,\n  },\n  loadingButton: {\n    opacity: 0.6,\n  },\n  markerContainer: {\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  instructions: {\n    padding: 16,\n    backgroundColor: '#f8f9fa',\n    borderTopWidth: 1,\n    borderTopColor: '#e0e0e0',\n  },\n  instructionText: {\n    fontSize: 14,\n    color: '#666',\n    textAlign: 'center',\n    marginBottom: 8,\n  },\n  coordinates: {\n    alignItems: 'center',\n  },\n  coordinateText: {\n    fontSize: 12,\n    color: '#999',\n    fontFamily: 'monospace',\n  },\n});\n\nexport default LocationPicker;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/map/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/post/HelpfulVoting.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"userVotedHelpful ? '#4CAF50' : '#f5f5f5'\" }","line":95,"column":11,"nodeType":"ObjectExpression","endLine":98,"endColumn":12},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"userVotedHelpful ? '#fff' : '#666'\" }","line":110,"column":15,"nodeType":"ObjectExpression","endLine":113,"endColumn":16},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"userVotedHelpful ? '#fff' : '#999'\" }","line":123,"column":15,"nodeType":"ObjectExpression","endLine":126,"endColumn":16},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"userVotedNotHelpful ? '#f44336' : '#f5f5f5'\" }","line":138,"column":11,"nodeType":"ObjectExpression","endLine":141,"endColumn":12},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"userVotedNotHelpful ? '#fff' : '#666'\" }","line":157,"column":15,"nodeType":"ObjectExpression","endLine":160,"endColumn":16},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: \"userVotedNotHelpful ? '#fff' : '#999'\" }","line":170,"column":15,"nodeType":"ObjectExpression","endLine":173,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback } from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet, ActivityIndicator } from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { useHelpful } from '../../hooks/useHelpful';\n\ninterface HelpfulVotingProps {\n  toiletId: string;\n  size?: 'small' | 'medium' | 'large';\n  showStats?: boolean;\n  showText?: boolean;\n}\n\nconst HelpfulVoting: React.FC<HelpfulVotingProps> = ({\n  toiletId,\n  size = 'medium',\n  showStats = true,\n  showText = true,\n}) => {\n  const {\n    stats,\n    isLoading,\n    isVoting,\n    userVotedHelpful,\n    userVotedNotHelpful,\n    voteHelpful,\n    voteNotHelpful,\n    removeVote,\n  } = useHelpful(toiletId);\n\n  // メモ化されたサイズ設定\n  const config = useMemo(() => {\n    const sizeConfig = {\n      small: {\n        iconSize: 16,\n        fontSize: 12,\n        padding: 6,\n        gap: 8,\n      },\n      medium: {\n        iconSize: 20,\n        fontSize: 14,\n        padding: 8,\n        gap: 12,\n      },\n      large: {\n        iconSize: 24,\n        fontSize: 16,\n        padding: 10,\n        gap: 16,\n      },\n    };\n    return sizeConfig[size];\n  }, [size]);\n\n  // メモ化されたボタンハンドラー\n  const handleHelpfulPress = useCallback(() => {\n    if (userVotedHelpful) {\n      removeVote();\n    } else {\n      voteHelpful();\n    }\n  }, [userVotedHelpful, removeVote, voteHelpful]);\n\n  const handleNotHelpfulPress = useCallback(() => {\n    if (userVotedNotHelpful) {\n      removeVote();\n    } else {\n      voteNotHelpful();\n    }\n  }, [userVotedNotHelpful, removeVote, voteNotHelpful]);\n\n  // メモ化された統計計算\n  const helpfulPercentage = useMemo(\n    () => (stats.totalVotes > 0 ? Math.round(stats.helpfulRatio * 100) : 0),\n    [stats.helpfulRatio, stats.totalVotes],\n  );\n\n  if (isLoading) {\n    return (\n      <View style={[styles.container, { gap: config.gap }]}>\n        <ActivityIndicator size=\"small\" color=\"#666\" />\n        {showText && (\n          <Text style={[styles.loadingText, { fontSize: config.fontSize }]}>読み込み中...</Text>\n        )}\n      </View>\n    );\n  }\n\n  return (\n    <View style={[styles.container, { gap: config.gap }]}>\n      {/* 役に立ったボタン */}\n      <TouchableOpacity\n        style={[\n          styles.voteButton,\n          {\n            padding: config.padding,\n            backgroundColor: userVotedHelpful ? '#4CAF50' : '#f5f5f5',\n          },\n          isVoting && styles.disabledButton,\n        ]}\n        onPress={handleHelpfulPress}\n        disabled={isVoting}\n        activeOpacity={0.7}\n      >\n        <Icon name=\"thumbs-up\" size={config.iconSize} color={userVotedHelpful ? '#fff' : '#666'} />\n        {showText && (\n          <Text\n            style={[\n              styles.voteText,\n              {\n                fontSize: config.fontSize,\n                color: userVotedHelpful ? '#fff' : '#666',\n              },\n            ]}\n          >\n            役に立った\n          </Text>\n        )}\n        {showStats && (\n          <Text\n            style={[\n              styles.countText,\n              {\n                fontSize: config.fontSize - 2,\n                color: userVotedHelpful ? '#fff' : '#999',\n              },\n            ]}\n          >\n            {stats.helpfulCount}\n          </Text>\n        )}\n      </TouchableOpacity>\n\n      {/* 役に立たなかったボタン */}\n      <TouchableOpacity\n        style={[\n          styles.voteButton,\n          {\n            padding: config.padding,\n            backgroundColor: userVotedNotHelpful ? '#f44336' : '#f5f5f5',\n          },\n          isVoting && styles.disabledButton,\n        ]}\n        onPress={handleNotHelpfulPress}\n        disabled={isVoting}\n        activeOpacity={0.7}\n      >\n        <Icon\n          name=\"thumbs-down\"\n          size={config.iconSize}\n          color={userVotedNotHelpful ? '#fff' : '#666'}\n        />\n        {showText && (\n          <Text\n            style={[\n              styles.voteText,\n              {\n                fontSize: config.fontSize,\n                color: userVotedNotHelpful ? '#fff' : '#666',\n              },\n            ]}\n          >\n            役に立たなかった\n          </Text>\n        )}\n        {showStats && (\n          <Text\n            style={[\n              styles.countText,\n              {\n                fontSize: config.fontSize - 2,\n                color: userVotedNotHelpful ? '#fff' : '#999',\n              },\n            ]}\n          >\n            {stats.notHelpfulCount}\n          </Text>\n        )}\n      </TouchableOpacity>\n\n      {/* 統計情報（詳細） */}\n      {showStats && stats.totalVotes > 0 && (\n        <View style={styles.statsContainer}>\n          <Text style={[styles.statsText, { fontSize: config.fontSize - 2 }]}>\n            {stats.totalVotes}人中{stats.helpfulCount}人が役に立ったと回答\n          </Text>\n          <Text style={[styles.ratioText, { fontSize: config.fontSize - 2 }]}>\n            ({helpfulPercentage}%が役に立った)\n          </Text>\n        </View>\n      )}\n\n      {/* 投票中のローディング */}\n      {isVoting && (\n        <View style={styles.votingOverlay}>\n          <ActivityIndicator size=\"small\" color=\"#4285f4\" />\n        </View>\n      )}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    flexWrap: 'wrap',\n  },\n  voteButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    borderRadius: 20,\n    borderWidth: 1,\n    borderColor: '#e0e0e0',\n    gap: 4,\n  },\n  disabledButton: {\n    opacity: 0.6,\n  },\n  voteText: {\n    fontWeight: '500',\n  },\n  countText: {\n    fontWeight: '600',\n    marginLeft: 2,\n  },\n  loadingText: {\n    color: '#666',\n  },\n  statsContainer: {\n    marginLeft: 8,\n    alignItems: 'flex-start',\n  },\n  statsText: {\n    color: '#666',\n  },\n  ratioText: {\n    color: '#999',\n    fontSize: 11,\n  },\n  votingOverlay: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n    borderRadius: 20,\n  },\n});\n\n// React.memo with custom comparison for performance optimization\nexport default React.memo(\n  HelpfulVoting,\n  (prevProps, nextProps) =>\n    prevProps.toiletId === nextProps.toiletId &&\n    prevProps.size === nextProps.size &&\n    prevProps.showStats === nextProps.showStats &&\n    prevProps.showText === nextProps.showText,\n);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/post/ImagePicker.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'openCamera' and 'openImageLibrary'. Either include them or remove the dependency array.","line":43,"column":6,"nodeType":"ArrayExpression","endLine":43,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [openCamera, openImageLibrary]","fix":{"range":[996,998],"text":"[openCamera, openImageLibrary]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  TouchableOpacity,\n  Image,\n  Alert,\n  ScrollView,\n  Dimensions,\n} from 'react-native';\nimport {\n  launchImageLibrary,\n  launchCamera,\n  MediaType,\n  ImagePickerResponse,\n  PhotoQuality,\n} from 'react-native-image-picker';\nimport Icon from 'react-native-vector-icons/Ionicons';\n\ninterface ImagePickerProps {\n  images: string[];\n  onAddImage: (imagePath: string) => void;\n  onRemoveImage: (index: number) => void;\n  maxImages?: number;\n}\n\nconst { width } = Dimensions.get('window');\nconst imageSize = (width - 48) / 3; // 3列表示、余白を考慮\n\nconst ImagePickerComponent: React.FC<ImagePickerProps> = ({\n  images,\n  onAddImage,\n  onRemoveImage,\n  maxImages = 5,\n}) => {\n  const selectImageSource = useCallback(() => {\n    Alert.alert('画像を選択', '画像の取得方法を選択してください', [\n      { text: 'キャンセル', style: 'cancel' },\n      { text: 'カメラで撮影', onPress: openCamera },\n      { text: 'ライブラリから選択', onPress: openImageLibrary },\n    ]);\n  }, []);\n\n  const openCamera = useCallback(() => {\n    const options = {\n      mediaType: 'photo' as MediaType,\n      quality: 0.8 as PhotoQuality,\n      maxWidth: 1024,\n      maxHeight: 1024,\n    };\n\n    launchCamera(options, (response: ImagePickerResponse) => {\n      if (response.didCancel || response.errorMessage) {\n        return;\n      }\n\n      if (response.assets && response.assets[0]?.uri) {\n        onAddImage(response.assets[0].uri);\n      }\n    });\n  }, [onAddImage]);\n\n  const openImageLibrary = useCallback(() => {\n    const options = {\n      mediaType: 'photo' as MediaType,\n      quality: 0.8 as PhotoQuality,\n      maxWidth: 1024,\n      maxHeight: 1024,\n      selectionLimit: maxImages - images.length,\n    };\n\n    launchImageLibrary(options, (response: ImagePickerResponse) => {\n      if (response.didCancel || response.errorMessage) {\n        return;\n      }\n\n      if (response.assets) {\n        response.assets.forEach(asset => {\n          if (asset.uri) {\n            onAddImage(asset.uri);\n          }\n        });\n      }\n    });\n  }, [onAddImage, maxImages, images.length]);\n\n  const confirmRemoveImage = useCallback(\n    (index: number) => {\n      Alert.alert('画像を削除', 'この画像を削除しますか？', [\n        { text: 'キャンセル', style: 'cancel' },\n        { text: '削除', onPress: () => onRemoveImage(index), style: 'destructive' },\n      ]);\n    },\n    [onRemoveImage],\n  );\n\n  return (\n    <View style={styles.container}>\n      <View style={styles.header}>\n        <Text style={styles.title}>\n          写真 ({images.length}/{maxImages})\n        </Text>\n        <Text style={styles.subtitle}>トイレの写真を追加してください</Text>\n      </View>\n\n      <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.scrollView}>\n        <View style={styles.imageGrid}>\n          {/* 追加ボタン */}\n          {images.length < maxImages && (\n            <TouchableOpacity style={styles.addButton} onPress={selectImageSource}>\n              <Icon name=\"camera\" size={32} color=\"#666\" />\n              <Text style={styles.addButtonText}>写真を追加</Text>\n            </TouchableOpacity>\n          )}\n\n          {/* 画像リスト */}\n          {images.map((image, index) => (\n            <View key={index} style={styles.imageContainer}>\n              <Image source={{ uri: image }} style={styles.image} />\n              <TouchableOpacity\n                style={styles.removeButton}\n                onPress={() => confirmRemoveImage(index)}\n              >\n                <Icon name=\"close-circle\" size={24} color=\"#ff4757\" />\n              </TouchableOpacity>\n            </View>\n          ))}\n        </View>\n      </ScrollView>\n\n      {images.length === 0 && (\n        <View style={styles.emptyState}>\n          <Icon name=\"images-outline\" size={48} color=\"#ccc\" />\n          <Text style={styles.emptyText}>まだ写真がありません</Text>\n          <Text style={styles.emptySubtext}>\n            トイレの外観や内部の写真を追加すると、他のユーザーに役立ちます\n          </Text>\n        </View>\n      )}\n\n      {images.length > 0 && (\n        <View style={styles.tips}>\n          <Icon name=\"information-circle-outline\" size={16} color=\"#666\" />\n          <Text style={styles.tipsText}>\n            写真は他のユーザーがトイレを見つけやすくするために使用されます\n          </Text>\n        </View>\n      )}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    marginVertical: 16,\n  },\n  header: {\n    marginBottom: 12,\n  },\n  title: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 4,\n  },\n  subtitle: {\n    fontSize: 14,\n    color: '#666',\n  },\n  scrollView: {\n    marginHorizontal: -8,\n  },\n  imageGrid: {\n    flexDirection: 'row',\n    paddingHorizontal: 8,\n  },\n  addButton: {\n    width: imageSize,\n    height: imageSize,\n    borderWidth: 2,\n    borderColor: '#ddd',\n    borderStyle: 'dashed',\n    borderRadius: 8,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginHorizontal: 4,\n    backgroundColor: '#f9f9f9',\n  },\n  addButtonText: {\n    fontSize: 12,\n    color: '#666',\n    textAlign: 'center',\n    marginTop: 4,\n  },\n  imageContainer: {\n    position: 'relative',\n    marginHorizontal: 4,\n  },\n  image: {\n    width: imageSize,\n    height: imageSize,\n    borderRadius: 8,\n    backgroundColor: '#f0f0f0',\n  },\n  removeButton: {\n    position: 'absolute',\n    top: -8,\n    right: -8,\n    backgroundColor: '#fff',\n    borderRadius: 12,\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.25,\n    shadowRadius: 4,\n    elevation: 5,\n  },\n  emptyState: {\n    alignItems: 'center',\n    paddingVertical: 32,\n    paddingHorizontal: 16,\n  },\n  emptyText: {\n    fontSize: 16,\n    color: '#999',\n    fontWeight: '600',\n    marginTop: 12,\n    marginBottom: 8,\n  },\n  emptySubtext: {\n    fontSize: 14,\n    color: '#ccc',\n    textAlign: 'center',\n    lineHeight: 20,\n  },\n  tips: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    marginTop: 12,\n    paddingHorizontal: 12,\n    paddingVertical: 8,\n    backgroundColor: '#f8f9fa',\n    borderRadius: 8,\n  },\n  tipsText: {\n    fontSize: 12,\n    color: '#666',\n    flex: 1,\n    marginLeft: 8,\n    lineHeight: 16,\n  },\n});\n\nexport default ImagePickerComponent;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/report/ReportModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/review/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/constants/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/data/badges.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/data/sampleToilets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/__tests__/useReport.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7997,8000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7997,8000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":247,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":247,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8120,8123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8120,8123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { renderHook, act } from '@testing-library/react-native';\nimport { Alert } from 'react-native';\nimport { useReport } from '../useReport';\nimport { ReportTargetType, ReportReason, ReportStatus } from '../../types/post';\n\n// Mock dependencies\njest.mock('../../services/reportService');\njest.mock('../../stores/authStore');\njest.mock('react-native', () => ({\n  Alert: {\n    alert: jest.fn(),\n  },\n}));\n\nconst mockReportService = {\n  submitReport: jest.fn(),\n  getUserReports: jest.fn(),\n  getUserRestrictions: jest.fn(),\n  getUserViolationPoints: jest.fn(),\n  isUserRestricted: jest.fn(),\n};\n\nconst mockUseAuth = {\n  user: { uid: 'test-user-id' },\n};\n\njest.mock('../../services/reportService', () => ({\n  reportService: mockReportService,\n}));\n\njest.mock('../../stores/authStore', () => ({\n  useAuth: () => mockUseAuth,\n}));\n\ndescribe('useReport', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockReportService.submitReport.mockResolvedValue(undefined);\n    mockReportService.getUserReports.mockResolvedValue([]);\n    mockReportService.getUserRestrictions.mockResolvedValue([]);\n    mockReportService.getUserViolationPoints.mockResolvedValue(0);\n    mockReportService.isUserRestricted.mockResolvedValue({ restricted: false });\n  });\n\n  describe('submitReport', () => {\n    it('should submit report successfully', async () => {\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const success = await result.current.submitReport(\n          ReportTargetType.TOILET,\n          'toilet-123',\n          ReportReason.SPAM,\n          'Test description',\n        );\n        expect(success).toBe(true);\n      });\n\n      expect(mockReportService.submitReport).toHaveBeenCalledWith(\n        'test-user-id',\n        ReportTargetType.TOILET,\n        'toilet-123',\n        ReportReason.SPAM,\n        'Test description',\n        undefined,\n      );\n      expect(Alert.alert).toHaveBeenCalledWith(\n        '通報完了',\n        '通報を受け付けました。確認後、適切な対応を行います。',\n        [{ text: 'OK' }],\n      );\n    });\n\n    it('should handle submit error', async () => {\n      mockReportService.submitReport.mockRejectedValue(new Error('Submit failed'));\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const success = await result.current.submitReport(\n          ReportTargetType.TOILET,\n          'toilet-123',\n          ReportReason.SPAM,\n        );\n        expect(success).toBe(false);\n      });\n\n      expect(Alert.alert).toHaveBeenCalledWith('エラー', '通報の送信に失敗しました');\n    });\n\n    it('should show error when user is not logged in', async () => {\n      mockUseAuth.user = null;\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const success = await result.current.submitReport(\n          ReportTargetType.TOILET,\n          'toilet-123',\n          ReportReason.SPAM,\n        );\n        expect(success).toBe(false);\n      });\n\n      expect(Alert.alert).toHaveBeenCalledWith('エラー', 'ログインが必要です');\n    });\n  });\n\n  describe('checkRestriction', () => {\n    it('should check user restriction for specific action', async () => {\n      mockReportService.isUserRestricted.mockResolvedValue({\n        restricted: true,\n        reason: 'Test restriction',\n        endDate: new Date(),\n      });\n\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const restriction = await result.current.checkRestriction('post');\n        expect(restriction.restricted).toBe(true);\n        expect(restriction.reason).toBe('Test restriction');\n      });\n\n      expect(mockReportService.isUserRestricted).toHaveBeenCalledWith('test-user-id', 'post');\n    });\n\n    it('should return not restricted when user is not logged in', async () => {\n      mockUseAuth.user = null;\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const restriction = await result.current.checkRestriction('post');\n        expect(restriction.restricted).toBe(false);\n      });\n    });\n  });\n\n  describe('executeWithRestrictionCheck', () => {\n    it('should execute callback when user is not restricted', async () => {\n      mockReportService.isUserRestricted.mockResolvedValue({ restricted: false });\n      const mockCallback = jest.fn().mockResolvedValue(undefined);\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const success = await result.current.executeWithRestrictionCheck(\n          'post',\n          mockCallback,\n          'テスト操作',\n        );\n        expect(success).toBe(true);\n      });\n\n      expect(mockCallback).toHaveBeenCalled();\n      expect(Alert.alert).not.toHaveBeenCalled();\n    });\n\n    it('should show restriction alert and not execute callback when user is restricted', async () => {\n      mockReportService.isUserRestricted.mockResolvedValue({\n        restricted: true,\n        reason: 'あなたのアカウントは制限されています',\n        endDate: new Date('2024-12-31'),\n      });\n      const mockCallback = jest.fn();\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const success = await result.current.executeWithRestrictionCheck(\n          'post',\n          mockCallback,\n          'テスト操作',\n        );\n        expect(success).toBe(false);\n      });\n\n      expect(mockCallback).not.toHaveBeenCalled();\n      expect(Alert.alert).toHaveBeenCalledWith(\n        'テスト操作が制限されています',\n        expect.stringContaining('あなたのアカウントは制限されています'),\n        [{ text: 'OK' }],\n      );\n    });\n\n    it('should handle callback errors', async () => {\n      mockReportService.isUserRestricted.mockResolvedValue({ restricted: false });\n      const mockCallback = jest.fn().mockRejectedValue(new Error('Callback error'));\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        const success = await result.current.executeWithRestrictionCheck('post', mockCallback);\n        expect(success).toBe(false);\n      });\n\n      expect(mockCallback).toHaveBeenCalled();\n    });\n  });\n\n  describe('helper functions', () => {\n    it('should return correct reason display names', () => {\n      const { result } = renderHook(() => useReport());\n\n      expect(result.current.getReasonDisplayName(ReportReason.SPAM)).toBe('スパム');\n      expect(result.current.getReasonDisplayName(ReportReason.INAPPROPRIATE_CONTENT)).toBe(\n        '不適切なコンテンツ',\n      );\n      expect(result.current.getReasonDisplayName(ReportReason.HARASSMENT)).toBe('嫌がらせ');\n    });\n\n    it('should return correct status display names', () => {\n      const { result } = renderHook(() => useReport());\n\n      expect(result.current.getStatusDisplayName(ReportStatus.PENDING)).toBe('審査待ち');\n      expect(result.current.getStatusDisplayName(ReportStatus.RESOLVED)).toBe('解決済み');\n      expect(result.current.getStatusDisplayName(ReportStatus.DISMISSED)).toBe('却下');\n    });\n\n    it('should return correct status colors', () => {\n      const { result } = renderHook(() => useReport());\n\n      expect(result.current.getStatusColor(ReportStatus.PENDING)).toBe('#FF9800');\n      expect(result.current.getStatusColor(ReportStatus.RESOLVED)).toBe('#4CAF50');\n      expect(result.current.getStatusColor(ReportStatus.DISMISSED)).toBe('#757575');\n    });\n  });\n\n  describe('state calculations', () => {\n    it('should calculate risk levels correctly', async () => {\n      mockReportService.getUserViolationPoints.mockResolvedValue(15);\n      const { result } = renderHook(() => useReport());\n\n      // Wait for initial data load\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 0));\n      });\n\n      expect(result.current.isNearViolationLimit()).toBe(true);\n      expect(result.current.isHighRiskUser).toBe(true);\n    });\n\n    it('should detect active restrictions', async () => {\n      mockReportService.getUserRestrictions.mockResolvedValue([\n        {\n          id: 'restriction-1',\n          userId: 'test-user-id',\n          type: 'post_restriction' as any,\n          reason: 'Test',\n          startDate: new Date(),\n          isActive: true,\n          createdBy: 'system' as any,\n        },\n      ]);\n\n      const { result } = renderHook(() => useReport());\n\n      // Wait for initial data load\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 0));\n      });\n\n      expect(result.current.hasActiveRestrictions()).toBe(true);\n      expect(result.current.activeRestrictionCount).toBe(1);\n    });\n  });\n\n  describe('data loading', () => {\n    it('should load user data on mount when user is logged in', async () => {\n      renderHook(() => useReport());\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 0));\n      });\n\n      expect(mockReportService.getUserReports).toHaveBeenCalledWith('test-user-id');\n      expect(mockReportService.getUserRestrictions).toHaveBeenCalledWith('test-user-id');\n      expect(mockReportService.getUserViolationPoints).toHaveBeenCalledWith('test-user-id');\n    });\n\n    it('should not load data when user is not logged in', () => {\n      mockUseAuth.user = null;\n      renderHook(() => useReport());\n\n      expect(mockReportService.getUserReports).not.toHaveBeenCalled();\n      expect(mockReportService.getUserRestrictions).not.toHaveBeenCalled();\n      expect(mockReportService.getUserViolationPoints).not.toHaveBeenCalled();\n    });\n\n    it('should refresh all data when refresh is called', async () => {\n      const { result } = renderHook(() => useReport());\n\n      await act(async () => {\n        await result.current.refresh();\n      });\n\n      expect(mockReportService.getUserReports).toHaveBeenCalledWith('test-user-id');\n      expect(mockReportService.getUserRestrictions).toHaveBeenCalledWith('test-user-id');\n      expect(mockReportService.getUserViolationPoints).toHaveBeenCalledWith('test-user-id');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/index.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":16,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":16,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[527,556],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[649,691],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1117,1150],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState } from 'react';\nimport Geolocation from '@react-native-community/geolocation';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { apiService } from '../services/api';\n\n// Location hook\nexport const useLocation = () => {\n  const [location, setLocation] = useState<{\n    latitude: number;\n    longitude: number;\n  } | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    console.log('位置情報の取得を開始...');\n    \n    // より寛容な設定で位置情報を取得\n    Geolocation.getCurrentPosition(\n      position => {\n        console.log('位置情報取得成功:', position.coords);\n        setLocation({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n        });\n        setError(null);\n        setLoading(false);\n      },\n      positionError => {\n        console.error('位置情報取得エラー:', positionError);\n        console.error('エラーコード:', positionError.code);\n        console.error('エラーメッセージ:', positionError.message);\n        \n        // デフォルトの位置情報（東京駅）を設定\n        console.log('デフォルト位置情報を使用: 東京駅');\n        setLocation({\n          latitude: 35.6812,\n          longitude: 139.7671,\n        });\n        setError('位置情報の取得に失敗したため、デフォルト位置（東京駅）を使用しています');\n        setLoading(false);\n      },\n      { \n        enableHighAccuracy: false, // 精度を下げて速度を上げる\n        timeout: 30000, // タイムアウトを30秒に延長\n        maximumAge: 300000 // キャッシュを5分間有効にする\n      },\n    );\n  }, []);\n\n  return { location, error, loading };\n};\n\n// Reviews hooks\nexport const useReviews = (params?: { limit?: number; offset?: number }) =>\n  useQuery({\n    queryKey: ['reviews', params],\n    queryFn: () => apiService.getReviews(params),\n  });\n\nexport const useReviewsByPlace = (placeId: string) =>\n  useQuery({\n    queryKey: ['reviews', 'place', placeId],\n    queryFn: () => apiService.getReviewsByPlace(placeId),\n    enabled: !!placeId,\n  });\n\nexport const useCreateReview = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (review: { placeId: string; rating: number; comment: string; photos?: string[] }) =>\n      apiService.createReview(review),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['reviews'] });\n    },\n  });\n};\n\n// Places hooks\nexport const useSearchPlaces = (query: string, location?: { lat: number; lng: number }) =>\n  useQuery({\n    queryKey: ['places', 'search', query, location],\n    queryFn: () => apiService.searchPlaces(query, location),\n    enabled: !!query,\n  });\n\nexport const useNearbyPlaces = (location: { lat: number; lng: number }, radius = 1000) =>\n  useQuery({\n    queryKey: ['places', 'nearby', location, radius],\n    queryFn: () => apiService.getNearbyPlaces(location, radius),\n    enabled: !!location,\n  });\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useBadges.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2665,2668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2665,2668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\nimport { Alert } from 'react-native';\nimport { Badge, UserBadges } from '../types/post';\nimport { badgeService } from '../services/badgeService';\nimport { useAuth } from '../stores/authStore';\n\ninterface UseBadgesState {\n  userBadges: UserBadges | null;\n  unlockedBadgeDetails: Badge[];\n  allBadges: Badge[];\n  isLoading: boolean;\n  isChecking: boolean;\n}\n\nexport const useBadges = () => {\n  const { user } = useAuth();\n  const [state, setState] = useState<UseBadgesState>({\n    userBadges: null,\n    unlockedBadgeDetails: [],\n    allBadges: badgeService.getAllBadges(),\n    isLoading: false,\n    isChecking: false,\n  });\n\n  // ユーザーのバッジ情報を読み込み\n  const loadUserBadges = useCallback(async () => {\n    if (!user) return;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const [userBadges, badgeDetails] = await Promise.all([\n        badgeService.getUserBadges(user.uid),\n        badgeService.getUserBadgeDetails(user.uid),\n      ]);\n\n      setState(prev => ({\n        ...prev,\n        userBadges,\n        unlockedBadgeDetails: badgeDetails,\n        isLoading: false,\n      }));\n    } catch (error) {\n      console.error('Failed to load user badges:', error);\n      setState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, [user]);\n\n  // バッジ条件をチェック\n  const checkBadgeConditions = useCallback(async (): Promise<string[]> => {\n    if (!user) return [];\n\n    setState(prev => ({ ...prev, isChecking: true }));\n\n    try {\n      const newBadgeIds = await badgeService.checkBadgeConditions(user.uid);\n\n      if (newBadgeIds.length > 0) {\n        // 新しいバッジを取得した場合、データを再読み込み\n        await loadUserBadges();\n\n        // 新しいバッジ取得の通知\n        const newBadges = newBadgeIds\n          .map(id => state.allBadges.find(badge => badge.id === id))\n          .filter((badge): badge is Badge => badge !== undefined);\n\n        if (newBadges.length === 1) {\n          Alert.alert(\n            '🎉 新しいバッジを獲得！',\n            `「${newBadges[0].name}」\\n${newBadges[0].description}`,\n            [{ text: 'OK' }],\n          );\n        } else if (newBadges.length > 1) {\n          Alert.alert(\n            '🎉 複数のバッジを獲得！',\n            `${newBadges.length}個の新しいバッジを獲得しました`,\n            [{ text: 'OK' }],\n          );\n        }\n      }\n\n      setState(prev => ({ ...prev, isChecking: false }));\n      return newBadgeIds;\n    } catch (error) {\n      console.error('Failed to check badge conditions:', error);\n      setState(prev => ({ ...prev, isChecking: false }));\n      return [];\n    }\n  }, [user, loadUserBadges, state.allBadges]);\n\n  // 投稿時のバッジチェック\n  const onToiletPosted = useCallback(\n    async (toiletData: any) => {\n      if (!user) return;\n\n      try {\n        const newBadgeIds = await badgeService.onToiletPosted(user.uid, toiletData);\n\n        if (newBadgeIds.length > 0) {\n          await loadUserBadges();\n\n          // 通知表示\n          const newBadges = newBadgeIds\n            .map(id => state.allBadges.find(badge => badge.id === id))\n            .filter((badge): badge is Badge => badge !== undefined);\n\n          for (const badge of newBadges) {\n            Alert.alert('🎉 新しいバッジを獲得！', `「${badge.name}」\\n${badge.description}`, [\n              { text: 'すごい！' },\n            ]);\n          }\n        }\n      } catch (error) {\n        console.error('Failed to handle toilet posted:', error);\n      }\n    },\n    [user, loadUserBadges, state.allBadges],\n  );\n\n  // 投票時のバッジチェック\n  const onHelpfulVote = useCallback(\n    async (targetUserId: string) => {\n      if (!user) return;\n\n      try {\n        await badgeService.onHelpfulVote(user.uid, targetUserId);\n        // バッジ取得があった可能性があるので、少し遅延してチェック\n        setTimeout(() => {\n          checkBadgeConditions();\n        }, 1000);\n      } catch (error) {\n        console.error('Failed to handle helpful vote:', error);\n      }\n    },\n    [user, checkBadgeConditions],\n  );\n\n  // 初期データの読み込み\n  useEffect(() => {\n    if (user) {\n      loadUserBadges();\n    }\n  }, [user, loadUserBadges]);\n\n  // 計算値\n  const badgeCount = state.userBadges?.unlockedBadges.length || 0;\n  const totalBadges = state.allBadges.length;\n  const completionRate = totalBadges > 0 ? (badgeCount / totalBadges) * 100 : 0;\n\n  // カテゴリ別の取得数\n  const getBadgeCountByCategory = useCallback(\n    (category: string) => {\n      const categoryBadges = state.allBadges.filter(badge => badge.category === category);\n      const unlockedInCategory = state.unlockedBadgeDetails.filter(\n        badge => badge.category === category,\n      );\n      return {\n        unlocked: unlockedInCategory.length,\n        total: categoryBadges.length,\n      };\n    },\n    [state.allBadges, state.unlockedBadgeDetails],\n  );\n\n  // レア度別の取得数\n  const getBadgeCountByRarity = useCallback(\n    (rarity: string) => {\n      const rarityBadges = state.allBadges.filter(badge => badge.rarity === rarity);\n      const unlockedInRarity = state.unlockedBadgeDetails.filter(badge => badge.rarity === rarity);\n      return {\n        unlocked: unlockedInRarity.length,\n        total: rarityBadges.length,\n      };\n    },\n    [state.allBadges, state.unlockedBadgeDetails],\n  );\n\n  // 特定のバッジが取得済みかチェック\n  const hasBadge = useCallback(\n    (badgeId: string) => state.userBadges?.unlockedBadges.includes(badgeId) || false,\n    [state.userBadges],\n  );\n\n  return {\n    // 状態\n    userBadges: state.userBadges,\n    unlockedBadges: state.unlockedBadgeDetails,\n    allBadges: state.allBadges,\n    isLoading: state.isLoading,\n    isChecking: state.isChecking,\n\n    // 計算値\n    badgeCount,\n    totalBadges,\n    completionRate,\n\n    // アクション\n    loadUserBadges,\n    checkBadgeConditions,\n    onToiletPosted,\n    onHelpfulVote,\n    getBadgeCountByCategory,\n    getBadgeCountByRarity,\n    hasBadge,\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useHelpful.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useHistory.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'loadViewHistory'. Either include it or remove the dependency array.","line":41,"column":5,"nodeType":"ArrayExpression","endLine":41,"endColumn":11,"suggestions":[{"desc":"Update the dependencies array to be: [loadViewHistory, user]","fix":{"range":[1119,1125],"text":"[loadViewHistory, user]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\nimport { Alert } from 'react-native';\nimport { ViewHistory, Favorite, UserActivity, UserStats } from '../types/post';\nimport { ToiletLocation } from '../types/maps';\nimport { historyService } from '../services/historyService';\nimport { useAuth } from '../stores/authStore';\n\ninterface UseHistoryState {\n  viewHistory: ViewHistory[];\n  favorites: Favorite[];\n  activities: UserActivity[];\n  userStats: UserStats | null;\n  isLoading: boolean;\n  isUpdating: boolean;\n}\n\nexport const useHistory = () => {\n  const { user } = useAuth();\n  const [state, setState] = useState<UseHistoryState>({\n    viewHistory: [],\n    favorites: [],\n    activities: [],\n    userStats: null,\n    isLoading: false,\n    isUpdating: false,\n  });\n\n  // 閲覧履歴を記録\n  const recordView = useCallback(\n    async (toilet: ToiletLocation) => {\n      if (!user) return;\n\n      try {\n        await historyService.recordView(user.uid, toilet);\n        // 履歴を再読み込み（バックグラウンドで）\n        loadViewHistory();\n      } catch (error) {\n        console.error('Failed to record view:', error);\n      }\n    },\n    [user],\n  );\n\n  // 閲覧履歴を読み込み\n  const loadViewHistory = useCallback(async () => {\n    if (!user) return;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const history = await historyService.getViewHistory(user.uid);\n      setState(prev => ({\n        ...prev,\n        viewHistory: history,\n        isLoading: false,\n      }));\n    } catch (error) {\n      console.error('Failed to load view history:', error);\n      setState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, [user]);\n\n  // 閲覧履歴をクリア\n  const clearViewHistory = useCallback(async () => {\n    if (!user) return;\n\n    Alert.alert('履歴を削除', '閲覧履歴をすべて削除しますか？', [\n      { text: 'キャンセル', style: 'cancel' },\n      {\n        text: '削除',\n        style: 'destructive',\n        onPress: async () => {\n          setState(prev => ({ ...prev, isUpdating: true }));\n          try {\n            await historyService.clearViewHistory(user.uid);\n            setState(prev => ({\n              ...prev,\n              viewHistory: [],\n              isUpdating: false,\n            }));\n            Alert.alert('完了', '履歴を削除しました');\n          } catch (error) {\n            console.error('Failed to clear view history:', error);\n            Alert.alert('エラー', '履歴の削除に失敗しました');\n            setState(prev => ({ ...prev, isUpdating: false }));\n          }\n        },\n      },\n    ]);\n  }, [user]);\n\n  // お気に入りを読み込み\n  const loadFavorites = useCallback(async () => {\n    if (!user) return;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const favorites = await historyService.getFavorites(user.uid);\n      setState(prev => ({\n        ...prev,\n        favorites,\n        isLoading: false,\n      }));\n    } catch (error) {\n      console.error('Failed to load favorites:', error);\n      setState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, [user]);\n\n  // お気に入りに追加\n  const addToFavorites = useCallback(\n    async (toilet: ToiletLocation) => {\n      if (!user) return;\n\n      setState(prev => ({ ...prev, isUpdating: true }));\n\n      try {\n        await historyService.addToFavorites(user.uid, toilet);\n\n        // お気に入り一覧を更新\n        await loadFavorites();\n\n        setState(prev => ({ ...prev, isUpdating: false }));\n        Alert.alert('追加完了', 'お気に入りに追加しました');\n      } catch (error) {\n        console.error('Failed to add to favorites:', error);\n        setState(prev => ({ ...prev, isUpdating: false }));\n\n        if (error instanceof Error) {\n          Alert.alert('エラー', error.message);\n        } else {\n          Alert.alert('エラー', 'お気に入りの追加に失敗しました');\n        }\n      }\n    },\n    [user, loadFavorites],\n  );\n\n  // お気に入りから削除\n  const removeFromFavorites = useCallback(\n    async (toiletId: string) => {\n      if (!user) return;\n\n      setState(prev => ({ ...prev, isUpdating: true }));\n\n      try {\n        await historyService.removeFromFavorites(user.uid, toiletId);\n\n        // お気に入り一覧を更新\n        setState(prev => ({\n          ...prev,\n          favorites: prev.favorites.filter(fav => fav.toiletId !== toiletId),\n          isUpdating: false,\n        }));\n\n        Alert.alert('削除完了', 'お気に入りから削除しました');\n      } catch (error) {\n        console.error('Failed to remove from favorites:', error);\n        setState(prev => ({ ...prev, isUpdating: false }));\n        Alert.alert('エラー', 'お気に入りの削除に失敗しました');\n      }\n    },\n    [user],\n  );\n\n  // お気に入りかどうかチェック\n  const isFavorite = useCallback(\n    (toiletId: string): boolean => state.favorites.some(fav => fav.toiletId === toiletId),\n    [state.favorites],\n  );\n\n  // お気に入りのトグル\n  const toggleFavorite = useCallback(\n    async (toilet: ToiletLocation) => {\n      if (isFavorite(toilet.id)) {\n        await removeFromFavorites(toilet.id);\n      } else {\n        await addToFavorites(toilet);\n      }\n    },\n    [isFavorite, removeFromFavorites, addToFavorites],\n  );\n\n  // アクティビティを読み込み\n  const loadActivities = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const activities = await historyService.getUserActivities(user.uid);\n      setState(prev => ({ ...prev, activities }));\n    } catch (error) {\n      console.error('Failed to load activities:', error);\n    }\n  }, [user]);\n\n  // ユーザー統計を読み込み\n  const loadUserStats = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const stats = await historyService.getUserStats(user.uid);\n      setState(prev => ({ ...prev, userStats: stats }));\n    } catch (error) {\n      console.error('Failed to load user stats:', error);\n    }\n  }, [user]);\n\n  // よく見るトイレを取得\n  const getFrequentlyViewed = useCallback(\n    async (limit: number = 10): Promise<ViewHistory[]> => {\n      if (!user) return [];\n\n      try {\n        return await historyService.getFrequentlyViewed(user.uid, limit);\n      } catch (error) {\n        console.error('Failed to get frequently viewed:', error);\n        return [];\n      }\n    },\n    [user],\n  );\n\n  // 最近のアクティビティを取得（全ユーザー）\n  const getRecentActivities = useCallback(async (limit: number = 20): Promise<UserActivity[]> => {\n    try {\n      return await historyService.getRecentActivities(limit);\n    } catch (error) {\n      console.error('Failed to get recent activities:', error);\n      return [];\n    }\n  }, []);\n\n  // 全データの再読み込み\n  const refresh = useCallback(async () => {\n    if (!user) return;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      await Promise.all([loadViewHistory(), loadFavorites(), loadActivities(), loadUserStats()]);\n    } catch (error) {\n      console.error('Failed to refresh data:', error);\n    } finally {\n      setState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, [user, loadViewHistory, loadFavorites, loadActivities, loadUserStats]);\n\n  // 初期データの読み込み\n  useEffect(() => {\n    if (user) {\n      refresh();\n    }\n  }, [user, refresh]);\n\n  // 統計の便利メソッド\n  const getActivityCount = useCallback(\n    (days: number = 7): number => {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - days);\n\n      return state.activities.filter(activity => activity.createdAt >= cutoffDate).length;\n    },\n    [state.activities],\n  );\n\n  const getViewCountToday = useCallback((): number => {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    return state.viewHistory.filter(view => view.viewedAt >= today).length;\n  }, [state.viewHistory]);\n\n  return {\n    // 状態\n    viewHistory: state.viewHistory,\n    favorites: state.favorites,\n    activities: state.activities,\n    userStats: state.userStats,\n    isLoading: state.isLoading,\n    isUpdating: state.isUpdating,\n\n    // アクション\n    recordView,\n    loadViewHistory,\n    clearViewHistory,\n    loadFavorites,\n    addToFavorites,\n    removeFromFavorites,\n    toggleFavorite,\n    loadActivities,\n    loadUserStats,\n    getFrequentlyViewed,\n    getRecentActivities,\n    refresh,\n\n    // 計算値・ヘルパー\n    isFavorite,\n    favoriteCount: state.favorites.length,\n    historyCount: state.viewHistory.length,\n    activityCount: state.activities.length,\n    getActivityCount,\n    getViewCountToday,\n    hasHistory: state.viewHistory.length > 0,\n    hasFavorites: state.favorites.length > 0,\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useLocation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useNotifications.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'loadNotifications', 'loadSettings', and 'loadUnreadCount'. Either include them or remove the dependency array.","line":38,"column":6,"nodeType":"ArrayExpression","endLine":38,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [user, state.isInitialized, loadNotifications, loadSettings, loadUnreadCount]","fix":{"range":[1193,1220],"text":"[user, state.isInitialized, loadNotifications, loadSettings, loadUnreadCount]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4171,4174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4171,4174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\nimport { PushNotification, NotificationSettings } from '../types/post';\nimport { notificationService } from '../services/notificationService';\nimport { useAuth } from '../stores/authStore';\n\ninterface UseNotificationsState {\n  notifications: PushNotification[];\n  settings: NotificationSettings | null;\n  unreadCount: number;\n  isLoading: boolean;\n  isInitialized: boolean;\n}\n\nexport const useNotifications = () => {\n  const { user } = useAuth();\n  const [state, setState] = useState<UseNotificationsState>({\n    notifications: [],\n    settings: null,\n    unreadCount: 0,\n    isLoading: false,\n    isInitialized: false,\n  });\n\n  // 通知システムの初期化\n  const initializeNotifications = useCallback(async () => {\n    if (!user || state.isInitialized) return;\n\n    try {\n      await notificationService.initialize(user.uid);\n      setState(prev => ({ ...prev, isInitialized: true }));\n\n      // 初期データの読み込み\n      await Promise.all([loadNotifications(), loadSettings(), loadUnreadCount()]);\n    } catch (error) {\n      console.error('Failed to initialize notifications:', error);\n    }\n  }, [user, state.isInitialized]);\n\n  // 通知履歴の読み込み\n  const loadNotifications = useCallback(async () => {\n    if (!user) return;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const notifications = await notificationService.getUserNotifications(user.uid);\n      setState(prev => ({\n        ...prev,\n        notifications,\n        isLoading: false,\n      }));\n    } catch (error) {\n      console.error('Failed to load notifications:', error);\n      setState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, [user]);\n\n  // 通知設定の読み込み\n  const loadSettings = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const settings = await notificationService.getNotificationSettings(user.uid);\n      setState(prev => ({ ...prev, settings }));\n    } catch (error) {\n      console.error('Failed to load notification settings:', error);\n    }\n  }, [user]);\n\n  // 未読数の読み込み\n  const loadUnreadCount = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const unreadCount = await notificationService.getUnreadCount(user.uid);\n      setState(prev => ({ ...prev, unreadCount }));\n    } catch (error) {\n      console.error('Failed to load unread count:', error);\n    }\n  }, [user]);\n\n  // 通知設定の更新\n  const updateSettings = useCallback(\n    async (updates: Partial<NotificationSettings>) => {\n      if (!user) return;\n\n      try {\n        await notificationService.updateNotificationSettings(user.uid, updates);\n        setState(prev => ({\n          ...prev,\n          settings: prev.settings ? { ...prev.settings, ...updates } : null,\n        }));\n      } catch (error) {\n        console.error('Failed to update notification settings:', error);\n        throw error;\n      }\n    },\n    [user],\n  );\n\n  // 通知を既読にする\n  const markAsRead = useCallback(async (notificationId: string) => {\n    try {\n      await notificationService.markAsRead(notificationId);\n\n      setState(prev => ({\n        ...prev,\n        notifications: prev.notifications.map(notification =>\n          notification.id === notificationId ? { ...notification, isRead: true } : notification,\n        ),\n        unreadCount: Math.max(0, prev.unreadCount - 1),\n      }));\n    } catch (error) {\n      console.error('Failed to mark notification as read:', error);\n    }\n  }, []);\n\n  // 全通知を既読にする\n  const markAllAsRead = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      await notificationService.markAllAsRead(user.uid);\n\n      setState(prev => ({\n        ...prev,\n        notifications: prev.notifications.map(notification => ({\n          ...notification,\n          isRead: true,\n        })),\n        unreadCount: 0,\n      }));\n    } catch (error) {\n      console.error('Failed to mark all notifications as read:', error);\n    }\n  }, [user]);\n\n  // 通知の手動送信（デバッグ用）\n  const sendTestNotification = useCallback(\n    async (title: string, body: string) => {\n      if (!user) return;\n\n      try {\n        await notificationService.sendNotification(user.uid, 'community_news' as any, title, body);\n\n        // 通知履歴を再読み込み\n        setTimeout(() => {\n          loadNotifications();\n          loadUnreadCount();\n        }, 1000);\n      } catch (error) {\n        console.error('Failed to send test notification:', error);\n      }\n    },\n    [user, loadNotifications, loadUnreadCount],\n  );\n\n  // バッジ取得通知\n  const sendBadgeNotification = useCallback(\n    async (badgeName: string, badgeId: string) => {\n      if (!user) return;\n\n      try {\n        await notificationService.sendBadgeUnlockedNotification(user.uid, badgeName, badgeId);\n\n        // 通知履歴を更新\n        setTimeout(() => {\n          loadNotifications();\n          loadUnreadCount();\n        }, 500);\n      } catch (error) {\n        console.error('Failed to send badge notification:', error);\n      }\n    },\n    [user, loadNotifications, loadUnreadCount],\n  );\n\n  // 「役に立った」通知\n  const sendHelpfulVoteNotification = useCallback(\n    async (toiletTitle: string, toiletId: string) => {\n      if (!user) return;\n\n      try {\n        await notificationService.sendHelpfulVoteNotification(user.uid, toiletTitle, toiletId);\n\n        // 通知履歴を更新\n        setTimeout(() => {\n          loadNotifications();\n          loadUnreadCount();\n        }, 500);\n      } catch (error) {\n        console.error('Failed to send helpful vote notification:', error);\n      }\n    },\n    [user, loadNotifications, loadUnreadCount],\n  );\n\n  // アプリ状態変更の監視\n  useEffect(() => {\n    const handleAppStateChange = (nextAppState: AppStateStatus) => {\n      if (nextAppState === 'active' && user) {\n        // アプリがアクティブになったら未読数を更新\n        loadUnreadCount();\n      }\n    };\n\n    const subscription = AppState.addEventListener('change', handleAppStateChange);\n    return () => subscription?.remove();\n  }, [user, loadUnreadCount]);\n\n  // 初期化\n  useEffect(() => {\n    if (user && !state.isInitialized) {\n      initializeNotifications();\n    }\n  }, [user, state.isInitialized, initializeNotifications]);\n\n  // 定期的な未読数更新\n  useEffect(() => {\n    if (!user) return;\n\n    const interval = setInterval(() => {\n      loadUnreadCount();\n    }, 60000); // 1分ごと\n\n    return () => clearInterval(interval);\n  }, [user, loadUnreadCount]);\n\n  return {\n    // 状態\n    notifications: state.notifications,\n    settings: state.settings,\n    unreadCount: state.unreadCount,\n    isLoading: state.isLoading,\n    isInitialized: state.isInitialized,\n\n    // アクション\n    loadNotifications,\n    loadSettings,\n    updateSettings,\n    markAsRead,\n    markAllAsRead,\n    sendTestNotification,\n    sendBadgeNotification,\n    sendHelpfulVoteNotification,\n    refresh: () => Promise.all([loadNotifications(), loadSettings(), loadUnreadCount()]),\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useReport.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ViolationRecord' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":18},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'loadUserReports'. Either include it or remove the dependency array.","line":82,"column":5,"nodeType":"ArrayExpression","endLine":82,"endColumn":11,"suggestions":[{"desc":"Update the dependencies array to be: [loadUserReports, user]","fix":{"range":[1929,1935],"text":"[loadUserReports, user]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect, useMemo } from 'react';\nimport { Alert } from 'react-native';\nimport {\n  Report,\n  UserRestriction,\n  ReportTargetType,\n  ReportReason,\n  ReportStatus,\n  ViolationRecord,\n} from '../types/post';\nimport { reportService } from '../services/reportService';\nimport { useAuth } from '../stores/authStore';\n\ninterface UseReportState {\n  reports: Report[];\n  userRestrictions: UserRestriction[];\n  violationPoints: number;\n  isLoading: boolean;\n  isSubmitting: boolean;\n  error: string | null;\n}\n\nexport const useReport = () => {\n  const { user } = useAuth();\n  const [state, setState] = useState<UseReportState>({\n    reports: [],\n    userRestrictions: [],\n    violationPoints: 0,\n    isLoading: false,\n    isSubmitting: false,\n    error: null,\n  });\n\n  // 通報を送信\n  const submitReport = useCallback(\n    async (\n      targetType: ReportTargetType,\n      targetId: string,\n      reason: ReportReason,\n      description?: string,\n      evidence?: string[],\n    ) => {\n      if (!user) {\n        Alert.alert('エラー', 'ログインが必要です');\n        return false;\n      }\n\n      setState(prev => ({ ...prev, isSubmitting: true, error: null }));\n\n      try {\n        await reportService.submitReport(\n          user.uid,\n          targetType,\n          targetId,\n          reason,\n          description,\n          evidence,\n        );\n\n        setState(prev => ({ ...prev, isSubmitting: false }));\n\n        Alert.alert('通報完了', '通報を受け付けました。確認後、適切な対応を行います。', [\n          { text: 'OK' },\n        ]);\n\n        // ユーザーの通報履歴を更新\n        await loadUserReports();\n\n        return true;\n      } catch (error) {\n        console.error('Failed to submit report:', error);\n        setState(prev => ({\n          ...prev,\n          isSubmitting: false,\n          error: error instanceof Error ? error.message : '通報の送信に失敗しました',\n        }));\n\n        Alert.alert('エラー', '通報の送信に失敗しました');\n        return false;\n      }\n    },\n    [user],\n  );\n\n  // ユーザーの通報履歴を読み込み\n  const loadUserReports = useCallback(async () => {\n    if (!user) return;\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const reports = await reportService.getUserReports(user.uid);\n      setState(prev => ({\n        ...prev,\n        reports,\n        isLoading: false,\n      }));\n    } catch (error) {\n      console.error('Failed to load user reports:', error);\n      setState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: '通報履歴の読み込みに失敗しました',\n      }));\n    }\n  }, [user]);\n\n  // ユーザーの制限状況を読み込み\n  const loadUserRestrictions = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const restrictions = await reportService.getUserRestrictions(user.uid);\n      const violationPoints = await reportService.getUserViolationPoints(user.uid);\n\n      setState(prev => ({\n        ...prev,\n        userRestrictions: restrictions,\n        violationPoints,\n      }));\n    } catch (error) {\n      console.error('Failed to load user restrictions:', error);\n    }\n  }, [user]);\n\n  // ユーザーが特定のアクションで制限されているかチェック\n  const checkRestriction = useCallback(\n    async (\n      action: 'post' | 'comment' | 'review' | 'vote',\n    ): Promise<{ restricted: boolean; reason?: string; endDate?: Date }> => {\n      if (!user) {\n        return { restricted: false };\n      }\n\n      try {\n        return await reportService.isUserRestricted(user.uid, action);\n      } catch (error) {\n        console.error('Failed to check restriction:', error);\n        return { restricted: false };\n      }\n    },\n    [user],\n  );\n\n  // 制限チェック付きアクション実行\n  const executeWithRestrictionCheck = useCallback(\n    async (\n      action: 'post' | 'comment' | 'review' | 'vote',\n      callback: () => Promise<void> | void,\n      actionName: string = 'この操作',\n    ): Promise<boolean> => {\n      const restriction = await checkRestriction(action);\n\n      if (restriction.restricted) {\n        const endDateText = restriction.endDate\n          ? `制限は${restriction.endDate.toLocaleDateString('ja-JP')}まで有効です。`\n          : '';\n\n        Alert.alert(`${actionName}が制限されています`, `${restriction.reason}\\n${endDateText}`, [\n          { text: 'OK' },\n        ]);\n        return false;\n      }\n\n      try {\n        await callback();\n        return true;\n      } catch (error) {\n        console.error('Action failed:', error);\n        return false;\n      }\n    },\n    [checkRestriction],\n  );\n\n  // メモ化された表示名マッピング\n  const reasonDisplayNames = useMemo(\n    () => ({\n      [ReportReason.INAPPROPRIATE_CONTENT]: '不適切なコンテンツ',\n      [ReportReason.SPAM]: 'スパム',\n      [ReportReason.HARASSMENT]: '嫌がらせ',\n      [ReportReason.FAKE_INFORMATION]: '虚偽情報',\n      [ReportReason.COPYRIGHT_VIOLATION]: '著作権侵害',\n      [ReportReason.PRIVACY_VIOLATION]: 'プライバシー侵害',\n      [ReportReason.COMMERCIAL_SPAM]: '商業的スパム',\n      [ReportReason.HATE_SPEECH]: 'ヘイトスピーチ',\n      [ReportReason.OTHER]: 'その他',\n    }),\n    [],\n  );\n\n  const statusDisplayNames = useMemo(\n    () => ({\n      [ReportStatus.PENDING]: '審査待ち',\n      [ReportStatus.UNDER_REVIEW]: '審査中',\n      [ReportStatus.RESOLVED]: '解決済み',\n      [ReportStatus.DISMISSED]: '却下',\n      [ReportStatus.AUTO_RESOLVED]: '自動解決',\n    }),\n    [],\n  );\n\n  const statusColors = useMemo(\n    () => ({\n      [ReportStatus.PENDING]: '#FF9800',\n      [ReportStatus.UNDER_REVIEW]: '#2196F3',\n      [ReportStatus.RESOLVED]: '#4CAF50',\n      [ReportStatus.DISMISSED]: '#757575',\n      [ReportStatus.AUTO_RESOLVED]: '#4CAF50',\n    }),\n    [],\n  );\n\n  // 通報理由の表示名を取得\n  const getReasonDisplayName = useCallback(\n    (reason: ReportReason): string => reasonDisplayNames[reason] || reason,\n    [reasonDisplayNames],\n  );\n\n  // 通報ステータスの表示名を取得\n  const getStatusDisplayName = useCallback(\n    (status: ReportStatus): string => statusDisplayNames[status] || status,\n    [statusDisplayNames],\n  );\n\n  // ステータスの色を取得\n  const getStatusColor = useCallback(\n    (status: ReportStatus): string => statusColors[status] || '#757575',\n    [statusColors],\n  );\n\n  // 全データの再読み込み\n  const refresh = useCallback(async () => {\n    if (!user) return;\n\n    setState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      await Promise.all([loadUserReports(), loadUserRestrictions()]);\n    } catch (error) {\n      console.error('Failed to refresh data:', error);\n      setState(prev => ({\n        ...prev,\n        error: 'データの再読み込みに失敗しました',\n      }));\n    } finally {\n      setState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, [user, loadUserReports, loadUserRestrictions]);\n\n  // 初期データの読み込み\n  useEffect(() => {\n    if (user) {\n      refresh();\n    }\n  }, [user, refresh]);\n\n  // メモ化された計算値\n  const hasActiveRestrictions = useMemo(\n    () => state.userRestrictions.length > 0,\n    [state.userRestrictions.length],\n  );\n\n  const getActiveRestrictionTypes = useMemo(\n    () => state.userRestrictions.map(r => r.type),\n    [state.userRestrictions],\n  );\n\n  const isNearViolationLimit = useMemo(\n    () => state.violationPoints >= 15, // 20ポイントで永久停止なので警告\n    [state.violationPoints],\n  );\n\n  const reportCount = useMemo(() => state.reports.length, [state.reports.length]);\n  const activeRestrictionCount = useMemo(\n    () => state.userRestrictions.length,\n    [state.userRestrictions.length],\n  );\n  const isHighRiskUser = useMemo(() => state.violationPoints >= 10, [state.violationPoints]);\n\n  return {\n    // 状態\n    reports: state.reports,\n    userRestrictions: state.userRestrictions,\n    violationPoints: state.violationPoints,\n    isLoading: state.isLoading,\n    isSubmitting: state.isSubmitting,\n    error: state.error,\n\n    // アクション\n    submitReport,\n    loadUserReports,\n    loadUserRestrictions,\n    checkRestriction,\n    executeWithRestrictionCheck,\n    refresh,\n\n    // ヘルパー関数\n    getReasonDisplayName,\n    getStatusDisplayName,\n    getStatusColor,\n\n    // 計算値（メモ化済み）\n    hasActiveRestrictions,\n    getActiveRestrictionTypes,\n    isNearViolationLimit,\n    reportCount,\n    activeRestrictionCount,\n    isHighRiskUser,\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useSearch.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[446,449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[446,449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[456,459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[456,459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[589,592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[589,592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2121,2170],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'loadSearchHistory'. Either include it or remove the dependency array.","line":112,"column":5,"nodeType":"ArrayExpression","endLine":112,"endColumn":31,"suggestions":[{"desc":"Update the dependencies array to be: [user, getCurrentLocation, loadSearchHistory]","fix":{"range":[3158,3184],"text":"[user, getCurrentLocation, loadSearchHistory]"}}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect, useMemo, useRef } from 'react';\nimport { ToiletLocation } from '../types/maps';\nimport { SearchFilters, SearchResult, SortOption, SavedSearch, SearchHistory } from '../types/post';\nimport { searchService } from '../services/searchService';\nimport { useAuth } from '../stores/authStore';\nimport { useLocation } from './useLocation';\n\n// Debounce utility function\nconst useDebounce = <T extends (...args: any[]) => any>(callback: T, delay: number) => {\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  return useCallback(\n    (...args: any[]) => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => callback(...args), delay);\n    },\n    [callback, delay],\n  );\n};\n\ninterface UseSearchState {\n  results: ToiletLocation[];\n  isLoading: boolean;\n  isSearching: boolean;\n  totalCount: number;\n  hasMore: boolean;\n  searchTime: number;\n  error: string | null;\n  savedSearches: SavedSearch[];\n  searchHistory: SearchHistory[];\n}\n\nconst initialFilters: SearchFilters = {\n  query: '',\n  sortBy: SortOption.RELEVANCE,\n};\n\nexport const useSearch = () => {\n  const { user } = useAuth();\n  const { getCurrentLocation } = useLocation();\n\n  const [filters, setFilters] = useState<SearchFilters>(initialFilters);\n  const [state, setState] = useState<UseSearchState>({\n    results: [],\n    isLoading: false,\n    isSearching: false,\n    totalCount: 0,\n    hasMore: false,\n    searchTime: 0,\n    error: null,\n    savedSearches: [],\n    searchHistory: [],\n  });\n\n  const [currentPage, setCurrentPage] = useState(0);\n  const PAGE_SIZE = 20;\n\n  // 検索実行（内部用、デバウンスなし）\n  const executeSearch = useCallback(\n    async (searchFilters: SearchFilters, page: number = 0, append: boolean = false) => {\n      setState(prev => ({\n        ...prev,\n        isSearching: true,\n        error: null,\n        ...(page === 0 && !append ? { results: [] } : {}),\n      }));\n\n      try {\n        // 現在位置を取得\n        let userLocation;\n        try {\n          userLocation = await getCurrentLocation();\n        } catch (error) {\n          console.log('Location not available for search');\n        }\n\n        // 検索実行\n        const result: SearchResult = await searchService.searchToilets(\n          searchFilters,\n          userLocation || undefined,\n          PAGE_SIZE,\n          page * PAGE_SIZE,\n        );\n\n        setState(prev => ({\n          ...prev,\n          results: append ? [...prev.results, ...result.toilets] : result.toilets,\n          totalCount: result.totalCount,\n          hasMore: result.hasMore,\n          searchTime: result.searchTime,\n          isSearching: false,\n        }));\n\n        // 検索履歴を保存（クエリがある場合のみ）\n        if (user && searchFilters.query.trim() && !append) {\n          await searchService.saveSearchHistory(user.uid, searchFilters, result.totalCount);\n          await loadSearchHistory();\n        }\n\n        setCurrentPage(page);\n      } catch (error) {\n        console.error('Search failed:', error);\n        setState(prev => ({\n          ...prev,\n          isSearching: false,\n          error: '検索に失敗しました',\n        }));\n      }\n    },\n    [user, getCurrentLocation],\n  );\n\n  // デバウンス付きの検索関数\n  const debouncedSearch = useDebounce(executeSearch, 300);\n\n  // フィルター更新（最適化版）\n  const updateFilters = useCallback(\n    (updates: Partial<SearchFilters>) => {\n      setFilters(prevFilters => {\n        const newFilters = { ...prevFilters, ...updates };\n\n        // クエリが変更された場合は自動検索（デバウンス）\n        if (updates.query !== undefined) {\n          debouncedSearch(newFilters, 0, false);\n        }\n\n        return newFilters;\n      });\n    },\n    [debouncedSearch],\n  );\n\n  // 次のページを読み込み\n  const loadMore = useCallback(async () => {\n    if (!state.hasMore || state.isSearching) return;\n\n    await executeSearch(filters, currentPage + 1, true);\n  }, [state.hasMore, state.isSearching, filters, currentPage, executeSearch]);\n\n  // 検索をリセット\n  const resetSearch = useCallback(() => {\n    setFilters(initialFilters);\n    setState(prev => ({\n      ...prev,\n      results: [],\n      totalCount: 0,\n      hasMore: false,\n      searchTime: 0,\n      error: null,\n    }));\n    setCurrentPage(0);\n  }, []);\n\n  // 保存された検索条件を読み込み\n  const loadSavedSearches = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const searches = await searchService.getSavedSearches(user.uid);\n      setState(prev => ({ ...prev, savedSearches: searches }));\n    } catch (error) {\n      console.error('Failed to load saved searches:', error);\n    }\n  }, [user]);\n\n  // 検索履歴を読み込み\n  const loadSearchHistory = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      const history = await searchService.getSearchHistory(user.uid);\n      setState(prev => ({ ...prev, searchHistory: history }));\n    } catch (error) {\n      console.error('Failed to load search history:', error);\n    }\n  }, [user]);\n\n  // 検索条件を保存\n  const saveFavoriteSearch = useCallback(\n    async (name: string) => {\n      if (!user) return;\n\n      try {\n        await searchService.saveFavoriteSearch(user.uid, name, filters);\n        await loadSavedSearches();\n      } catch (error) {\n        console.error('Failed to save favorite search:', error);\n        throw error;\n      }\n    },\n    [user, filters, loadSavedSearches],\n  );\n\n  // 保存された検索条件を削除\n  const deleteSavedSearch = useCallback(\n    async (searchId: string) => {\n      try {\n        await searchService.deleteSavedSearch(searchId);\n        await loadSavedSearches();\n      } catch (error) {\n        console.error('Failed to delete saved search:', error);\n        throw error;\n      }\n    },\n    [loadSavedSearches],\n  );\n\n  // 保存された検索条件を適用\n  const applySavedSearch = useCallback(\n    (savedSearch: SavedSearch) => {\n      setFilters(savedSearch.filters);\n      executeSearch(savedSearch.filters, 0, false);\n    },\n    [executeSearch],\n  );\n\n  // 検索履歴から再検索\n  const applyHistorySearch = useCallback(\n    (history: SearchHistory) => {\n      setFilters(history.filters);\n      executeSearch(history.filters, 0, false);\n    },\n    [executeSearch],\n  );\n\n  // クイック検索（よく使われる検索条件）\n  const quickSearch = useCallback(\n    async (type: 'nearby' | 'accessible' | 'highRated' | 'newest') => {\n      let quickFilters: SearchFilters;\n\n      switch (type) {\n        case 'nearby':\n          quickFilters = { ...initialFilters, sortBy: SortOption.DISTANCE, distance: 1 };\n          break;\n        case 'accessible':\n          quickFilters = { ...initialFilters, isAccessible: true, sortBy: SortOption.DISTANCE };\n          break;\n        case 'highRated':\n          quickFilters = { ...initialFilters, rating: 4, sortBy: SortOption.RATING };\n          break;\n        case 'newest':\n          quickFilters = { ...initialFilters, sortBy: SortOption.NEWEST };\n          break;\n        default:\n          quickFilters = initialFilters;\n      }\n\n      setFilters(quickFilters);\n      await executeSearch(quickFilters, 0, false);\n    },\n    [executeSearch],\n  );\n\n  // 初期データの読み込み\n  useEffect(() => {\n    if (user) {\n      loadSavedSearches();\n      loadSearchHistory();\n    }\n  }, [user, loadSavedSearches, loadSearchHistory]);\n\n  // フィルターの便利メソッド\n  const clearFilters = useCallback(() => {\n    setFilters(initialFilters);\n  }, []);\n\n  // メモ化された計算値\n  const hasActiveFilters = useMemo(\n    () =>\n      filters.toiletType !== undefined ||\n      filters.isAccessible !== undefined ||\n      filters.hasWashlet !== undefined ||\n      filters.rating !== undefined ||\n      filters.distance !== undefined ||\n      filters.openNow !== undefined ||\n      filters.sortBy !== SortOption.RELEVANCE,\n    [filters],\n  );\n\n  const hasResults = useMemo(() => state.results.length > 0, [state.results.length]);\n\n  const isEmpty = useMemo(\n    () => !state.isSearching && state.results.length === 0 && filters.query.trim() !== '',\n    [state.isSearching, state.results.length, filters.query],\n  );\n\n  return {\n    // 状態\n    results: state.results,\n    isLoading: state.isLoading,\n    isSearching: state.isSearching,\n    totalCount: state.totalCount,\n    hasMore: state.hasMore,\n    searchTime: state.searchTime,\n    error: state.error,\n    filters,\n    savedSearches: state.savedSearches,\n    searchHistory: state.searchHistory,\n\n    // アクション\n    search: () => executeSearch(filters, 0, false),\n    updateFilters,\n    loadMore,\n    resetSearch,\n    clearFilters,\n    quickSearch,\n    saveFavoriteSearch,\n    deleteSavedSearch,\n    applySavedSearch,\n    applyHistorySearch,\n    refresh: () => Promise.all([loadSavedSearches(), loadSearchHistory()]),\n\n    // 計算値（メモ化済み）\n    hasActiveFilters,\n    hasResults,\n    isEmpty,\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/hooks/useToiletPost.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":298,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":298,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7268,7322],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'react';\nimport { Alert } from 'react-native';\nimport {\n  ToiletPostForm,\n  initialToiletPostForm,\n  validateToiletPost,\n  validateImages,\n  ToiletRatings,\n  DetailedToiletEquipment,\n  ToiletInfo,\n  initialToiletInfo,\n} from '../types/post';\nimport { ToiletType, Coordinate } from '../types/maps';\nimport { useAuth } from '../stores/authStore';\nimport { firestoreService } from '../services/firestoreService';\nimport { useReport } from './useReport';\n\ninterface UseToiletPostState {\n  form: ToiletPostForm;\n  isLoading: boolean;\n  errors: string[];\n}\n\nexport const useToiletPost = () => {\n  const { user } = useAuth();\n  const { executeWithRestrictionCheck } = useReport();\n  const [state, setState] = useState<UseToiletPostState>({\n    form: initialToiletPostForm,\n    isLoading: false,\n    errors: [],\n  });\n\n  // フォームフィールドの更新\n  const updateForm = useCallback((updates: Partial<ToiletPostForm>) => {\n    setState(prev => ({\n      ...prev,\n      form: { ...prev.form, ...updates },\n      errors: [], // エラーをクリア\n    }));\n  }, []);\n\n  // 施設名の更新\n  const updateFacilityTitle = useCallback(\n    (facilityTitle: string) => {\n      updateForm({ facilityTitle });\n    },\n    [updateForm],\n  );\n\n  // 施設説明の更新\n  const updateFacilityDescription = useCallback(\n    (facilityDescription: string) => {\n      updateForm({ facilityDescription });\n    },\n    [updateForm],\n  );\n\n  // トイレタイプの更新\n  const updateType = useCallback(\n    (type: ToiletType) => {\n      updateForm({ type });\n    },\n    [updateForm],\n  );\n\n  // 複数トイレ管理\n  const addToilet = useCallback(() => {\n    setState(prev => {\n      const newToiletId = `toilet_${Date.now()}`;\n      const newToilet: ToiletInfo = {\n        ...initialToiletInfo,\n        id: newToiletId,\n        title: `トイレ${prev.form.toilets.length + 1}`,\n      };\n\n      return {\n        ...prev,\n        form: {\n          ...prev.form,\n          toilets: [...prev.form.toilets, newToilet],\n        },\n        errors: [],\n      };\n    });\n  }, []);\n\n  const removeToilet = useCallback((toiletId: string) => {\n    setState(prev => ({\n      ...prev,\n      form: {\n        ...prev.form,\n        toilets: prev.form.toilets.filter(toilet => toilet.id !== toiletId),\n      },\n      errors: [],\n    }));\n  }, []);\n\n  const updateToilet = useCallback((toiletId: string, updates: Partial<ToiletInfo>) => {\n    setState(prev => ({\n      ...prev,\n      form: {\n        ...prev.form,\n        toilets: prev.form.toilets.map(toilet =>\n          toilet.id === toiletId ? { ...toilet, ...updates } : toilet,\n        ),\n      },\n      errors: [],\n    }));\n  }, []);\n\n  // 位置情報の更新\n  const updateLocation = useCallback(\n    (location: Coordinate) => {\n      updateForm({ location });\n    },\n    [updateForm],\n  );\n\n  // 特定トイレの設備情報を更新\n  const updateToiletFacility = useCallback(\n    (toiletIndex: number, facilityKey: string, value: boolean) => {\n      setState(prev => {\n        const updatedToilets = [...prev.form.toilets];\n        if (updatedToilets[toiletIndex]) {\n          updatedToilets[toiletIndex] = {\n            ...updatedToilets[toiletIndex],\n            facilities: {\n              ...updatedToilets[toiletIndex].facilities,\n              [facilityKey]: value,\n            },\n          };\n        }\n        return {\n          ...prev,\n          form: {\n            ...prev.form,\n            toilets: updatedToilets,\n          },\n          errors: [],\n        };\n      });\n    },\n    [],\n  );\n\n  // 営業時間の更新\n  const updateOpeningHours = useCallback((updates: Partial<ToiletPostForm['openingHours']>) => {\n    setState(prev => ({\n      ...prev,\n      form: {\n        ...prev.form,\n        openingHours: {\n          ...prev.form.openingHours,\n          ...updates,\n        },\n      },\n      errors: [],\n    }));\n  }, []);\n\n  // 追加情報の更新\n  const updateAdditionalInfo = useCallback(\n    (additionalInfo: string) => {\n      updateForm({ additionalInfo });\n    },\n    [updateForm],\n  );\n\n  // 施設画像の追加\n  const addImage = useCallback((imagePath: string) => {\n    setState(prev => {\n      const newImages = [...prev.form.facilityImages, imagePath];\n      const validation = validateImages(newImages);\n\n      if (!validation.isValid) {\n        Alert.alert('エラー', validation.errors.join('\\n'));\n        return prev;\n      }\n\n      return {\n        ...prev,\n        form: {\n          ...prev.form,\n          facilityImages: newImages,\n        },\n        errors: [],\n      };\n    });\n  }, []);\n\n  // 施設画像の削除\n  const removeImage = useCallback((index: number) => {\n    setState(prev => ({\n      ...prev,\n      form: {\n        ...prev.form,\n        facilityImages: prev.form.facilityImages.filter((_, i) => i !== index),\n      },\n      errors: [],\n    }));\n  }, []);\n\n  // 個別トイレ画像の追加\n  const addToiletImage = useCallback((toiletId: string, imagePath: string) => {\n    setState(prev => {\n      const toiletIndex = prev.form.toilets.findIndex(t => t.id === toiletId);\n      if (toiletIndex === -1) return prev;\n\n      const toilet = prev.form.toilets[toiletIndex];\n      const newImages = [...toilet.images, imagePath];\n      const validation = validateImages(newImages);\n\n      if (!validation.isValid) {\n        Alert.alert('エラー', validation.errors.join('\\n'));\n        return prev;\n      }\n\n      return {\n        ...prev,\n        form: {\n          ...prev.form,\n          toilets: prev.form.toilets.map(t =>\n            t.id === toiletId ? { ...t, images: newImages } : t,\n          ),\n        },\n        errors: [],\n      };\n    });\n  }, []);\n\n  // 個別トイレ画像の削除\n  const removeToiletImage = useCallback((toiletId: string, index: number) => {\n    setState(prev => ({\n      ...prev,\n      form: {\n        ...prev.form,\n        toilets: prev.form.toilets.map(t =>\n          t.id === toiletId ? { ...t, images: t.images.filter((_, i) => i !== index) } : t,\n        ),\n      },\n      errors: [],\n    }));\n  }, []);\n\n  // バリデーション実行\n  const validateForm = useCallback(() => {\n    const validation = validateToiletPost(state.form);\n    const facilityImageValidation = validateImages(state.form.facilityImages);\n\n    // 各トイレの画像もバリデーション\n    const toiletImageErrors: string[] = [];\n    state.form.toilets.forEach((toilet, index) => {\n      const toiletValidation = validateImages(toilet.images);\n      if (!toiletValidation.isValid) {\n        toiletImageErrors.push(\n          ...toiletValidation.errors.map(error => `トイレ${index + 1}: ${error}`),\n        );\n      }\n    });\n\n    const allErrors = [\n      ...validation.errors,\n      ...facilityImageValidation.errors,\n      ...toiletImageErrors,\n    ];\n\n    setState(prev => ({\n      ...prev,\n      errors: allErrors,\n    }));\n\n    return allErrors.length === 0;\n  }, [state.form]);\n\n  // フォーム送信（制限チェック付き）\n  const submitForm = useCallback(async () => {\n    if (!user) {\n      Alert.alert('エラー', 'ログインが必要です');\n      return false;\n    }\n\n    // 制限チェック付きで実行\n    return await executeWithRestrictionCheck(\n      'post',\n      async () => {\n        // バリデーション\n        if (!validateForm()) {\n          Alert.alert('入力エラー', state.errors.join('\\n'));\n          throw new Error('Validation failed');\n        }\n\n        setState(prev => ({ ...prev, isLoading: true }));\n\n        try {\n          // Firestoreへの保存処理\n          const toiletId = await firestoreService.createToilet(state.form, user.uid);\n\n          console.log('Toilet created successfully:', toiletId);\n          Alert.alert('成功', 'トイレ情報が投稿されました！');\n\n          // フォームをリセット\n          setState(prev => ({\n            ...prev,\n            form: initialToiletPostForm,\n            isLoading: false,\n            errors: [],\n          }));\n        } catch (error) {\n          console.error('Submit error:', error);\n          Alert.alert(\n            'エラー',\n            error instanceof Error ? error.message : '投稿に失敗しました。もう一度お試しください。',\n          );\n          setState(prev => ({ ...prev, isLoading: false }));\n          throw error;\n        }\n      },\n      'トイレの投稿',\n    );\n  }, [user, validateForm, state.errors, state.form, executeWithRestrictionCheck]);\n\n  // フォームのリセット\n  const resetForm = useCallback(() => {\n    setState({\n      form: initialToiletPostForm,\n      isLoading: false,\n      errors: [],\n    });\n  }, []);\n\n  // 特定トイレの評価軸を更新\n  const updateToiletRating = useCallback(\n    (toiletIndex: number, ratingKey: keyof ToiletRatings, value: number) => {\n      setState(prev => {\n        const updatedToilets = [...prev.form.toilets];\n        if (updatedToilets[toiletIndex]) {\n          updatedToilets[toiletIndex] = {\n            ...updatedToilets[toiletIndex],\n            ratings: {\n              ...updatedToilets[toiletIndex].ratings,\n              [ratingKey]: value,\n            },\n          };\n        }\n        return {\n          ...prev,\n          form: {\n            ...prev.form,\n            toilets: updatedToilets,\n          },\n          errors: [],\n        };\n      });\n    },\n    [],\n  );\n\n  // 特定トイレの詳細設備を更新\n  const updateToiletDetailedEquipment = useCallback(\n    (toiletIndex: number, updates: Partial<DetailedToiletEquipment>) => {\n      setState(prev => {\n        const updatedToilets = [...prev.form.toilets];\n        if (updatedToilets[toiletIndex]) {\n          updatedToilets[toiletIndex] = {\n            ...updatedToilets[toiletIndex],\n            detailedEquipment: {\n              ...updatedToilets[toiletIndex].detailedEquipment,\n              ...updates,\n            },\n          };\n        }\n        return {\n          ...prev,\n          form: {\n            ...prev.form,\n            toilets: updatedToilets,\n          },\n          errors: [],\n        };\n      });\n    },\n    [],\n  );\n\n  // 特定トイレの男性用設備更新\n  const updateToiletMaleEquipment = useCallback(\n    (\n      toiletIndex: number,\n      updates: Partial<NonNullable<DetailedToiletEquipment['maleEquipment']>>,\n    ) => {\n      setState(prev => {\n        const updatedToilets = [...prev.form.toilets];\n        if (updatedToilets[toiletIndex]) {\n          const currentEquipment = updatedToilets[toiletIndex].detailedEquipment;\n          updatedToilets[toiletIndex] = {\n            ...updatedToilets[toiletIndex],\n            detailedEquipment: {\n              ...currentEquipment,\n              maleEquipment: currentEquipment.maleEquipment\n                ? {\n                    ...currentEquipment.maleEquipment,\n                    ...updates,\n                  }\n                : {\n                    urinals: 0,\n                    westernToilets: 0,\n                    ...updates,\n                  },\n            },\n          };\n        }\n        return {\n          ...prev,\n          form: {\n            ...prev.form,\n            toilets: updatedToilets,\n          },\n          errors: [],\n        };\n      });\n    },\n    [],\n  );\n\n  // 特定トイレの女性用設備更新\n  const updateToiletFemaleEquipment = useCallback(\n    (\n      toiletIndex: number,\n      updates: Partial<NonNullable<DetailedToiletEquipment['femaleEquipment']>>,\n    ) => {\n      setState(prev => {\n        const updatedToilets = [...prev.form.toilets];\n        if (updatedToilets[toiletIndex]) {\n          const currentEquipment = updatedToilets[toiletIndex].detailedEquipment;\n          updatedToilets[toiletIndex] = {\n            ...updatedToilets[toiletIndex],\n            detailedEquipment: {\n              ...currentEquipment,\n              femaleEquipment: currentEquipment.femaleEquipment\n                ? {\n                    ...currentEquipment.femaleEquipment,\n                    ...updates,\n                  }\n                : {\n                    japaneseToilets: 0,\n                    westernToilets: 0,\n                    ...updates,\n                  },\n            },\n          };\n        }\n        return {\n          ...prev,\n          form: {\n            ...prev.form,\n            toilets: updatedToilets,\n          },\n          errors: [],\n        };\n      });\n    },\n    [],\n  );\n\n  // 特定トイレの共用設備更新\n  const updateToiletSharedEquipment = useCallback(\n    (\n      toiletIndex: number,\n      updates: Partial<NonNullable<DetailedToiletEquipment['sharedEquipment']>>,\n    ) => {\n      setState(prev => {\n        const updatedToilets = [...prev.form.toilets];\n        if (updatedToilets[toiletIndex]) {\n          const currentEquipment = updatedToilets[toiletIndex].detailedEquipment;\n          updatedToilets[toiletIndex] = {\n            ...updatedToilets[toiletIndex],\n            detailedEquipment: {\n              ...currentEquipment,\n              sharedEquipment: currentEquipment.sharedEquipment\n                ? {\n                    ...currentEquipment.sharedEquipment,\n                    ...updates,\n                  }\n                : {\n                    japaneseToilets: 0,\n                    westernToilets: 0,\n                    ...updates,\n                  },\n            },\n          };\n        }\n        return {\n          ...prev,\n          form: {\n            ...prev.form,\n            toilets: updatedToilets,\n          },\n          errors: [],\n        };\n      });\n    },\n    [],\n  );\n\n  // 特定トイレの追加機能更新\n  const updateToiletAdditionalFeatures = useCallback(\n    (\n      toiletIndex: number,\n      featureKey: keyof DetailedToiletEquipment['additionalFeatures'],\n      value: boolean,\n    ) => {\n      setState(prev => {\n        const updatedToilets = [...prev.form.toilets];\n        if (updatedToilets[toiletIndex]) {\n          updatedToilets[toiletIndex] = {\n            ...updatedToilets[toiletIndex],\n            detailedEquipment: {\n              ...updatedToilets[toiletIndex].detailedEquipment,\n              additionalFeatures: {\n                ...updatedToilets[toiletIndex].detailedEquipment.additionalFeatures,\n                [featureKey]: value,\n              },\n            },\n          };\n        }\n        return {\n          ...prev,\n          form: {\n            ...prev.form,\n            toilets: updatedToilets,\n          },\n          errors: [],\n        };\n      });\n    },\n    [],\n  );\n\n  // エラーのクリア\n  const clearErrors = useCallback(() => {\n    setState(prev => ({ ...prev, errors: [] }));\n  }, []);\n\n  return {\n    // 状態\n    form: state.form,\n    isLoading: state.isLoading,\n    errors: state.errors,\n    isValid: state.errors.length === 0,\n\n    // アクション\n    updateFacilityTitle,\n    updateFacilityDescription,\n    updateType,\n    updateLocation,\n    updateOpeningHours,\n    updateAdditionalInfo,\n    addToilet,\n    removeToilet,\n    updateToilet,\n    addImage,\n    removeImage,\n    addToiletImage,\n    removeToiletImage,\n    validateForm,\n    submitForm,\n    resetForm,\n    clearErrors,\n\n    // 新しいトイレ固有のアクション\n    updateToiletFacility,\n    updateToiletRating,\n    updateToiletDetailedEquipment,\n    updateToiletMaleEquipment,\n    updateToiletFemaleEquipment,\n    updateToiletSharedEquipment,\n    updateToiletAdditionalFeatures,\n\n    // 後方互換性のための関数（最初のトイレに対する操作）\n    updateTitle: useCallback((title: string) => {\n      if (state.form.toilets.length > 0 && state.form.toilets[0]) {\n        updateToilet(state.form.toilets[0].id, { title });\n      }\n    }, [state.form.toilets, updateToilet]),\n    updateDescription: useCallback((description: string) => {\n      if (state.form.toilets.length > 0 && state.form.toilets[0]) {\n        updateToilet(state.form.toilets[0].id, { description });\n      }\n    }, [state.form.toilets, updateToilet]),\n    updateAccessibility: useCallback((isAccessible: boolean) => {\n      if (state.form.toilets.length > 0 && state.form.toilets[0]) {\n        updateToilet(state.form.toilets[0].id, { isAccessible });\n      }\n    }, [state.form.toilets, updateToilet]),\n    updateFacility: (facilityKey: string, value: boolean) =>\n      updateToiletFacility(0, facilityKey, value),\n    updateRating: (ratingKey: keyof ToiletRatings, value: number) =>\n      updateToiletRating(0, ratingKey, value),\n    updateDetailedEquipment: (updates: Partial<DetailedToiletEquipment>) =>\n      updateToiletDetailedEquipment(0, updates),\n    updateMaleEquipment: (\n      updates: Partial<NonNullable<DetailedToiletEquipment['maleEquipment']>>,\n    ) => updateToiletMaleEquipment(0, updates),\n    updateFemaleEquipment: (\n      updates: Partial<NonNullable<DetailedToiletEquipment['femaleEquipment']>>,\n    ) => updateToiletFemaleEquipment(0, updates),\n    updateSharedEquipment: (\n      updates: Partial<NonNullable<DetailedToiletEquipment['sharedEquipment']>>,\n    ) => updateToiletSharedEquipment(0, updates),\n    updateAdditionalFeatures: (\n      featureKey: keyof DetailedToiletEquipment['additionalFeatures'],\n      value: boolean,\n    ) => updateToiletAdditionalFeatures(0, featureKey, value),\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/navigation/AppNavigator.tsx","messages":[{"ruleId":"react/no-unstable-nested-components","severity":1,"message":"Do not define components during render. React will see a new component type on every render and destroy the entire subtree’s DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component “MainTabs” and pass data as props. If you want to allow component creation in props, set allowAsProps option to true.","line":37,"column":19,"nodeType":"ArrowFunctionExpression","endLine":53,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'color' is defined but never used. Allowed unused args must match /^_/u.","line":37,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":36},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { justifyContent: 'center', alignItems: 'center' }","line":52,"column":29,"nodeType":"ObjectExpression","endLine":52,"endColumn":77},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { opacity: 'focused ? 1 : 0.5' }","line":52,"column":92,"nodeType":"ObjectExpression","endLine":52,"endColumn":142},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":66,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":66,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2352,2389],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":70,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":70,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2507,2573],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":74,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":74,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2620,2667],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2850,2891],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":92,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":92,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3037,3098],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { View, ActivityIndicator, StyleSheet, Text } from 'react-native';\n// import Icon from 'react-native-vector-icons/Ionicons';\n\n// Import screens (placeholders for now)\nimport MapScreen from '../screens/map/MapScreen';\nimport PostReviewScreen from '../screens/post/PostReviewScreen';\nimport HistoryScreen from '../screens/history/HistoryScreen';\nimport SettingsScreen from '../screens/settings/SettingsScreen';\nimport LoginScreen from '../screens/auth/LoginScreen';\n\n// Import auth store\nimport { useAuth, useAuthStore } from '../stores/authStore';\n\n// Navigation Types\nexport type RootStackParamList = {\n  Auth: undefined;\n  Main: undefined;\n};\n\nexport type MainTabParamList = {\n  Map: undefined;\n  Post: undefined;\n  History: undefined;\n  Settings: undefined;\n};\n\nconst Stack = createNativeStackNavigator<RootStackParamList>();\nconst Tab = createBottomTabNavigator<MainTabParamList>();\n\nconst MainTabs = () => (\n  <Tab.Navigator\n    screenOptions={({ route }) => ({\n      tabBarIcon: ({ focused, color, size }) => {\n        let icon: string;\n\n        if (route.name === 'Map') {\n          icon = focused ? '🗺️' : '🗺️';\n        } else if (route.name === 'Post') {\n          icon = focused ? '✏️' : '✏️';\n        } else if (route.name === 'History') {\n          icon = focused ? '📝' : '📝';\n        } else if (route.name === 'Settings') {\n          icon = focused ? '⚙️' : '⚙️';\n        } else {\n          icon = '❓';\n        }\n\n        return <View style={{justifyContent: 'center', alignItems: 'center'}}><Text style={{fontSize: size * 0.8, opacity: focused ? 1 : 0.5}}>{icon}</Text></View>;\n      },\n      tabBarActiveTintColor: '#007AFF',\n      tabBarInactiveTintColor: 'gray',\n    })}\n  >\n    <Tab.Screen name=\"Map\" component={MapScreen} options={{ title: 'マップ' }} />\n    <Tab.Screen name=\"Post\" component={PostReviewScreen} options={{ title: '投稿' }} />\n    <Tab.Screen name=\"History\" component={HistoryScreen} options={{ title: '履歴' }} />\n    <Tab.Screen name=\"Settings\" component={SettingsScreen} options={{ title: '設定' }} />\n  </Tab.Navigator>\n);\n\nconst AppNavigator = () => {\n  console.log('AppNavigator: レンダリング中');\n  const { isAuthenticated, isLoading } = useAuth();\n  const initialize = useAuthStore(state => state.initialize);\n\n  console.log('AppNavigator: 認証状態', { isAuthenticated, isLoading });\n\n  // アプリ起動時に認証状態を初期化\n  useEffect(() => {\n    console.log('AppNavigator: useEffect で初期化を開始');\n    try {\n      initialize();\n    } catch (error) {\n      console.error('AppNavigator: 初期化でエラー:', error);\n    }\n  }, [initialize]);\n\n  // 認証状態の確認中はローディング画面を表示\n  if (isLoading) {\n    console.log('AppNavigator: ローディング画面を表示');\n    return (\n      <View style={styles.loadingContainer}>\n        <ActivityIndicator size=\"large\" color=\"#4285f4\" />\n      </View>\n    );\n  }\n\n  console.log('AppNavigator: ナビゲーションを表示', { isAuthenticated });\n\n  return (\n    <NavigationContainer>\n      <Stack.Navigator screenOptions={{ headerShown: false }}>\n        {isAuthenticated ? (\n          <Stack.Screen name=\"Main\" component={MainTabs} />\n        ) : (\n          <Stack.Screen name=\"Auth\" component={LoginScreen} />\n        )}\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n};\n\nconst styles = StyleSheet.create({\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#fff',\n  },\n});\n\nexport default AppNavigator;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/auth/LoginScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/badge/BadgeScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FlatList' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'unlockedBadges' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":21,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":19},{"ruleId":"react/no-unstable-nested-components","severity":1,"message":"Do not define components during render. React will see a new component type on every render and destroy the entire subtree’s DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component “BadgeScreen” and pass data as props.","line":61,"column":36,"nodeType":"ArrowFunctionExpression","endLine":96,"endColumn":4},{"ruleId":"react/no-unstable-nested-components","severity":1,"message":"Do not define components during render. React will see a new component type on every render and destroy the entire subtree’s DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component “BadgeScreen” and pass data as props.","line":99,"column":34,"nodeType":"ArrowFunctionExpression","endLine":132,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  ScrollView,\n  TouchableOpacity,\n  SafeAreaView,\n  Modal,\n  FlatList,\n  ActivityIndicator,\n} from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { Badge, BadgeCategory, BadgeRarity } from '../../types/post';\nimport { useBadges } from '../../hooks/useBadges';\nimport BadgeItem from '../../components/badge/BadgeItem';\nimport { CATEGORY_COLORS, RARITY_COLORS } from '../../data/badges';\n\nconst BadgeScreen: React.FC = () => {\n  const {\n    unlockedBadges,\n    allBadges,\n    isLoading,\n    badgeCount,\n    totalBadges,\n    completionRate,\n    getBadgeCountByCategory,\n    getBadgeCountByRarity,\n    hasBadge,\n  } = useBadges();\n\n  const [selectedCategory, setSelectedCategory] = useState<BadgeCategory | 'all'>('all');\n  const [selectedRarity, setSelectedRarity] = useState<BadgeRarity | 'all'>('all');\n  const [selectedBadge, setSelectedBadge] = useState<Badge | null>(null);\n  const [showBadgeDetail, setShowBadgeDetail] = useState(false);\n\n  // フィルタリングされたバッジ\n  const filteredBadges = allBadges.filter(badge => {\n    if (selectedCategory !== 'all' && badge.category !== selectedCategory) {\n      return false;\n    }\n    if (selectedRarity !== 'all' && badge.rarity !== selectedRarity) {\n      return false;\n    }\n    return true;\n  });\n\n  // バッジ詳細モーダルを開く\n  const handleBadgePress = useCallback((badge: Badge) => {\n    setSelectedBadge(badge);\n    setShowBadgeDetail(true);\n  }, []);\n\n  // バッジ詳細モーダルを閉じる\n  const closeBadgeDetail = useCallback(() => {\n    setShowBadgeDetail(false);\n    setSelectedBadge(null);\n  }, []);\n\n  // カテゴリフィルター\n  const CategoryFilter: React.FC = () => (\n    <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.filterContainer}>\n      <TouchableOpacity\n        style={[styles.filterButton, selectedCategory === 'all' && styles.activeFilter]}\n        onPress={() => setSelectedCategory('all')}\n      >\n        <Text style={[styles.filterText, selectedCategory === 'all' && styles.activeFilterText]}>\n          すべて\n        </Text>\n      </TouchableOpacity>\n\n      {Object.values(BadgeCategory).map(category => {\n        const count = getBadgeCountByCategory(category);\n        return (\n          <TouchableOpacity\n            key={category}\n            style={[\n              styles.filterButton,\n              { borderColor: CATEGORY_COLORS[category] },\n              selectedCategory === category && [\n                styles.activeFilter,\n                { backgroundColor: CATEGORY_COLORS[category] },\n              ],\n            ]}\n            onPress={() => setSelectedCategory(category)}\n          >\n            <Text\n              style={[styles.filterText, selectedCategory === category && styles.activeFilterText]}\n            >\n              {getCategoryDisplayName(category)} ({count.unlocked}/{count.total})\n            </Text>\n          </TouchableOpacity>\n        );\n      })}\n    </ScrollView>\n  );\n\n  // レア度フィルター\n  const RarityFilter: React.FC = () => (\n    <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.filterContainer}>\n      <TouchableOpacity\n        style={[styles.filterButton, selectedRarity === 'all' && styles.activeFilter]}\n        onPress={() => setSelectedRarity('all')}\n      >\n        <Text style={[styles.filterText, selectedRarity === 'all' && styles.activeFilterText]}>\n          すべて\n        </Text>\n      </TouchableOpacity>\n\n      {Object.values(BadgeRarity).map(rarity => {\n        const count = getBadgeCountByRarity(rarity);\n        return (\n          <TouchableOpacity\n            key={rarity}\n            style={[\n              styles.filterButton,\n              { borderColor: RARITY_COLORS[rarity] },\n              selectedRarity === rarity && [\n                styles.activeFilter,\n                { backgroundColor: RARITY_COLORS[rarity] },\n              ],\n            ]}\n            onPress={() => setSelectedRarity(rarity)}\n          >\n            <Text style={[styles.filterText, selectedRarity === rarity && styles.activeFilterText]}>\n              {getRarityDisplayName(rarity)} ({count.unlocked}/{count.total})\n            </Text>\n          </TouchableOpacity>\n        );\n      })}\n    </ScrollView>\n  );\n\n  if (isLoading) {\n    return (\n      <SafeAreaView style={styles.container}>\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color=\"#4285f4\" />\n          <Text style={styles.loadingText}>バッジ情報を読み込み中...</Text>\n        </View>\n      </SafeAreaView>\n    );\n  }\n\n  return (\n    <SafeAreaView style={styles.container}>\n      {/* ヘッダー */}\n      <View style={styles.header}>\n        <Text style={styles.headerTitle}>バッジコレクション</Text>\n        <View style={styles.statsContainer}>\n          <Text style={styles.statsText}>\n            {badgeCount}/{totalBadges} ({completionRate.toFixed(1)}%)\n          </Text>\n          <View style={styles.progressBar}>\n            <View style={[styles.progressFill, { width: `${completionRate}%` }]} />\n          </View>\n        </View>\n      </View>\n\n      <ScrollView style={styles.content}>\n        {/* カテゴリフィルター */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>カテゴリ</Text>\n          <CategoryFilter />\n        </View>\n\n        {/* レア度フィルター */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>レア度</Text>\n          <RarityFilter />\n        </View>\n\n        {/* バッジグリッド */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>バッジ ({filteredBadges.length}個)</Text>\n          <View style={styles.badgeGrid}>\n            {filteredBadges.map(badge => (\n              <BadgeItem\n                key={badge.id}\n                badge={badge}\n                unlocked={hasBadge(badge.id)}\n                size=\"medium\"\n                onPress={() => handleBadgePress(badge)}\n              />\n            ))}\n          </View>\n        </View>\n      </ScrollView>\n\n      {/* バッジ詳細モーダル */}\n      <Modal\n        visible={showBadgeDetail}\n        animationType=\"slide\"\n        presentationStyle=\"pageSheet\"\n        onRequestClose={closeBadgeDetail}\n      >\n        <SafeAreaView style={styles.modalContainer}>\n          <View style={styles.modalHeader}>\n            <TouchableOpacity onPress={closeBadgeDetail}>\n              <Icon name=\"close\" size={24} color=\"#333\" />\n            </TouchableOpacity>\n            <Text style={styles.modalTitle}>バッジ詳細</Text>\n            <View style={styles.placeholder} />\n          </View>\n\n          {selectedBadge && (\n            <ScrollView style={styles.modalContent}>\n              <View style={styles.badgeDetailContainer}>\n                <BadgeItem\n                  badge={selectedBadge}\n                  unlocked={hasBadge(selectedBadge.id)}\n                  size=\"large\"\n                  showDetails={true}\n                />\n\n                {!hasBadge(selectedBadge.id) && (\n                  <View style={styles.conditionContainer}>\n                    <Text style={styles.conditionTitle}>取得条件</Text>\n                    <Text style={styles.conditionText}>{getConditionText(selectedBadge)}</Text>\n                  </View>\n                )}\n              </View>\n            </ScrollView>\n          )}\n        </SafeAreaView>\n      </Modal>\n    </SafeAreaView>\n  );\n};\n\n// カテゴリ表示名\nconst getCategoryDisplayName = (category: BadgeCategory): string => {\n  const categoryNames = {\n    [BadgeCategory.POSTING]: '投稿',\n    [BadgeCategory.REVIEWING]: 'レビュー',\n    [BadgeCategory.EXPLORATION]: '探索',\n    [BadgeCategory.COMMUNITY]: 'コミュニティ',\n    [BadgeCategory.SPECIAL]: '特別',\n  };\n  return categoryNames[category];\n};\n\n// レア度表示名\nconst getRarityDisplayName = (rarity: BadgeRarity): string => {\n  const rarityNames = {\n    [BadgeRarity.COMMON]: 'コモン',\n    [BadgeRarity.UNCOMMON]: 'アンコモン',\n    [BadgeRarity.RARE]: 'レア',\n    [BadgeRarity.EPIC]: 'エピック',\n    [BadgeRarity.LEGENDARY]: 'レジェンダリー',\n  };\n  return rarityNames[rarity];\n};\n\n// 取得条件のテキスト\nconst getConditionText = (badge: Badge): string => {\n  const { condition } = badge;\n\n  switch (condition.type) {\n    case 'count':\n      return `${getTargetDisplayName(condition.target)}を${condition.value}回達成`;\n    case 'rating':\n      return `${getTargetDisplayName(condition.target)}が${condition.value}以上`;\n    case 'streak':\n      return `${condition.value}日間連続で${getTargetDisplayName(condition.target)}`;\n    case 'special':\n      return badge.description;\n    default:\n      return badge.description;\n  }\n};\n\n// ターゲット表示名\nconst getTargetDisplayName = (target: string): string => {\n  const targetNames: Record<string, string> = {\n    toilets_posted: 'トイレ投稿',\n    helpful_votes_given: '「役に立った」投票',\n    helpful_votes_received: '「役に立った」を受ける',\n    unique_areas_posted: '異なる地域での投稿',\n    toilet_types_posted: '異なるタイプのトイレ投稿',\n    accessible_toilets_posted: 'バリアフリートイレ投稿',\n    daily_posts: '毎日投稿',\n    helpful_ratio: '役に立った比率',\n    avg_cleanliness_rating: '平均清潔度評価',\n  };\n  return targetNames[target] || target;\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  loadingText: {\n    marginTop: 16,\n    fontSize: 16,\n    color: '#666',\n  },\n  header: {\n    padding: 16,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  headerTitle: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 8,\n  },\n  statsContainer: {\n    alignItems: 'flex-end',\n  },\n  statsText: {\n    fontSize: 14,\n    color: '#666',\n    marginBottom: 4,\n  },\n  progressBar: {\n    width: 200,\n    height: 6,\n    backgroundColor: '#e0e0e0',\n    borderRadius: 3,\n    overflow: 'hidden',\n  },\n  progressFill: {\n    height: '100%',\n    backgroundColor: '#4285f4',\n    borderRadius: 3,\n  },\n  content: {\n    flex: 1,\n  },\n  section: {\n    padding: 16,\n  },\n  sectionTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 12,\n  },\n  filterContainer: {\n    flexDirection: 'row',\n  },\n  filterButton: {\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n    borderRadius: 16,\n    borderWidth: 1,\n    borderColor: '#e0e0e0',\n    backgroundColor: '#fff',\n    marginRight: 8,\n  },\n  activeFilter: {\n    backgroundColor: '#4285f4',\n    borderColor: '#4285f4',\n  },\n  filterText: {\n    fontSize: 12,\n    color: '#666',\n    fontWeight: '500',\n  },\n  activeFilterText: {\n    color: '#fff',\n  },\n  badgeGrid: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: 12,\n  },\n  modalContainer: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  modalHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    padding: 16,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  modalTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n  },\n  placeholder: {\n    width: 24,\n  },\n  modalContent: {\n    flex: 1,\n    padding: 16,\n  },\n  badgeDetailContainer: {\n    alignItems: 'center',\n  },\n  conditionContainer: {\n    marginTop: 24,\n    padding: 16,\n    backgroundColor: '#f8f9fa',\n    borderRadius: 8,\n    width: '100%',\n  },\n  conditionTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 8,\n  },\n  conditionText: {\n    fontSize: 14,\n    color: '#666',\n    lineHeight: 20,\n  },\n});\n\nexport default BadgeScreen;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/history/HistoryScreen.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":185,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":185,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5423,5468],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":197,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":197,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5737,5791],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  SafeAreaView,\n  FlatList,\n  TouchableOpacity,\n  RefreshControl,\n  Alert,\n  ScrollView,\n} from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { ViewHistory, Favorite, UserActivity, ActivityType } from '../../types/post';\nimport { useHistory } from '../../hooks/useHistory';\nimport { toiletTypeOptions } from '../../types/post';\n\ntype TabType = 'history' | 'favorites' | 'activities';\n\ninterface HistoryItemProps {\n  item: ViewHistory;\n  onPress: (toiletId: string) => void;\n}\n\nconst HistoryItem: React.FC<HistoryItemProps> = ({ item, onPress }) => {\n  const typeOption = toiletTypeOptions.find(option => option.value === item.toiletType);\n  const formatDate = (date: Date) => {\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n\n    if (diffDays === 0) {\n      return '今日';\n    } else if (diffDays === 1) {\n      return '昨日';\n    } else if (diffDays < 7) {\n      return `${diffDays}日前`;\n    } else {\n      return date.toLocaleDateString('ja-JP');\n    }\n  };\n\n  return (\n    <TouchableOpacity\n      style={styles.historyItem}\n      onPress={() => onPress(item.toiletId)}\n      activeOpacity={0.7}\n    >\n      <View style={styles.historyContent}>\n        <View style={styles.historyHeader}>\n          <Text style={styles.historyTitle}>{item.toiletTitle}</Text>\n          <View style={styles.typeContainer}>\n            <Text style={styles.typeIcon}>{typeOption?.icon || '🚽'}</Text>\n            <Text style={styles.typeLabel}>{typeOption?.label || 'その他'}</Text>\n          </View>\n        </View>\n\n        <View style={styles.historyMeta}>\n          <Text style={styles.viewedDate}>{formatDate(item.viewedAt)}</Text>\n          <Text style={styles.viewCount}>閲覧回数: {item.viewCount}回</Text>\n        </View>\n      </View>\n\n      <Icon name=\"chevron-forward\" size={20} color=\"#ccc\" />\n    </TouchableOpacity>\n  );\n};\n\ninterface FavoriteItemProps {\n  item: Favorite;\n  onPress: (toiletId: string) => void;\n  onRemove: (toiletId: string) => void;\n}\n\nconst FavoriteItem: React.FC<FavoriteItemProps> = ({ item, onPress, onRemove }) => {\n  const typeOption = toiletTypeOptions.find(option => option.value === item.toiletType);\n\n  const handleRemove = () => {\n    Alert.alert('お気に入りから削除', `「${item.toiletTitle}」をお気に入りから削除しますか？`, [\n      { text: 'キャンセル', style: 'cancel' },\n      { text: '削除', style: 'destructive', onPress: () => onRemove(item.toiletId) },\n    ]);\n  };\n\n  return (\n    <TouchableOpacity\n      style={styles.favoriteItem}\n      onPress={() => onPress(item.toiletId)}\n      activeOpacity={0.7}\n    >\n      <View style={styles.favoriteContent}>\n        <View style={styles.favoriteHeader}>\n          <Text style={styles.favoriteTitle}>{item.toiletTitle}</Text>\n          <TouchableOpacity onPress={handleRemove} style={styles.removeButton}>\n            <Icon name=\"heart\" size={20} color=\"#ff4444\" />\n          </TouchableOpacity>\n        </View>\n\n        <View style={styles.favoriteInfo}>\n          <View style={styles.typeContainer}>\n            <Text style={styles.typeIcon}>{typeOption?.icon || '🚽'}</Text>\n            <Text style={styles.typeLabel}>{typeOption?.label || 'その他'}</Text>\n          </View>\n          <Text style={styles.addedDate}>{item.addedAt.toLocaleDateString('ja-JP')}に追加</Text>\n        </View>\n      </View>\n    </TouchableOpacity>\n  );\n};\n\ninterface ActivityItemProps {\n  item: UserActivity;\n  onPress: (targetId: string) => void;\n}\n\nconst ActivityItem: React.FC<ActivityItemProps> = ({ item, onPress }) => {\n  const getActivityIcon = (type: ActivityType) => {\n    switch (type) {\n      case ActivityType.TOILET_POSTED:\n        return '📝';\n      case ActivityType.TOILET_UPDATED:\n        return '✏️';\n      case ActivityType.HELPFUL_VOTE:\n        return '👍';\n      case ActivityType.BADGE_EARNED:\n        return '🏆';\n      case ActivityType.FAVORITE_ADDED:\n        return '❤️';\n      case ActivityType.REVIEW_POSTED:\n        return '⭐';\n      default:\n        return '📋';\n    }\n  };\n\n  const formatDateTime = (date: Date) => {\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));\n\n    if (diffHours < 1) {\n      return 'たった今';\n    } else if (diffHours < 24) {\n      return `${diffHours}時間前`;\n    } else {\n      const diffDays = Math.floor(diffHours / 24);\n      return `${diffDays}日前`;\n    }\n  };\n\n  return (\n    <TouchableOpacity\n      style={styles.activityItem}\n      onPress={() => onPress(item.targetId)}\n      activeOpacity={0.7}\n    >\n      <View style={styles.activityIcon}>\n        <Text style={styles.activityEmoji}>{getActivityIcon(item.type)}</Text>\n      </View>\n\n      <View style={styles.activityContent}>\n        <Text style={styles.activityDescription}>{item.description}</Text>\n        <Text style={styles.activityTime}>{formatDateTime(item.createdAt)}</Text>\n      </View>\n    </TouchableOpacity>\n  );\n};\n\nconst HistoryScreen: React.FC = () => {\n  const {\n    viewHistory,\n    favorites,\n    activities,\n    userStats,\n    isLoading,\n    isUpdating,\n    clearViewHistory,\n    removeFromFavorites,\n    refresh,\n  } = useHistory();\n\n  const [activeTab, setActiveTab] = useState<TabType>('history');\n\n  const handleToiletPress = useCallback((toiletId: string) => {\n    console.log('Navigate to toilet:', toiletId);\n    // TODO: 実際のナビゲーション実装\n  }, []);\n\n  const handleRemoveFavorite = useCallback(\n    async (toiletId: string) => {\n      await removeFromFavorites(toiletId);\n    },\n    [removeFromFavorites],\n  );\n\n  const handleActivityPress = useCallback((targetId: string) => {\n    console.log('Navigate to activity target:', targetId);\n    // TODO: 実際のナビゲーション実装\n  }, []);\n\n  const renderHistoryItem = ({ item }: { item: ViewHistory }) => (\n    <HistoryItem item={item} onPress={handleToiletPress} />\n  );\n\n  const renderFavoriteItem = ({ item }: { item: Favorite }) => (\n    <FavoriteItem item={item} onPress={handleToiletPress} onRemove={handleRemoveFavorite} />\n  );\n\n  const renderActivityItem = ({ item }: { item: UserActivity }) => (\n    <ActivityItem item={item} onPress={handleActivityPress} />\n  );\n\n  const renderEmptyState = (type: TabType) => {\n    const messages = {\n      history: {\n        title: '履歴がありません',\n        description: 'トイレの詳細画面を見ると、ここに履歴が表示されます',\n        icon: 'time-outline',\n      },\n      favorites: {\n        title: 'お気に入りがありません',\n        description: 'お気に入りに追加したトイレがここに表示されます',\n        icon: 'heart-outline',\n      },\n      activities: {\n        title: '活動履歴がありません',\n        description: '投稿や評価などの活動がここに表示されます',\n        icon: 'list-outline',\n      },\n    };\n\n    const message = messages[type];\n\n    return (\n      <View style={styles.emptyContainer}>\n        <Icon name={message.icon} size={64} color=\"#ccc\" />\n        <Text style={styles.emptyTitle}>{message.title}</Text>\n        <Text style={styles.emptyDescription}>{message.description}</Text>\n      </View>\n    );\n  };\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case 'history':\n        return (\n          <FlatList\n            data={viewHistory}\n            renderItem={renderHistoryItem}\n            keyExtractor={item => item.id}\n            ListEmptyComponent={() => renderEmptyState('history')}\n            refreshControl={<RefreshControl refreshing={isLoading} onRefresh={refresh} />}\n            showsVerticalScrollIndicator={false}\n            contentContainerStyle={viewHistory.length === 0 ? styles.emptyList : undefined}\n          />\n        );\n\n      case 'favorites':\n        return (\n          <FlatList\n            data={favorites}\n            renderItem={renderFavoriteItem}\n            keyExtractor={item => item.id}\n            ListEmptyComponent={() => renderEmptyState('favorites')}\n            refreshControl={<RefreshControl refreshing={isLoading} onRefresh={refresh} />}\n            showsVerticalScrollIndicator={false}\n            contentContainerStyle={favorites.length === 0 ? styles.emptyList : undefined}\n          />\n        );\n\n      case 'activities':\n        return (\n          <FlatList\n            data={activities}\n            renderItem={renderActivityItem}\n            keyExtractor={item => item.id}\n            ListEmptyComponent={() => renderEmptyState('activities')}\n            refreshControl={<RefreshControl refreshing={isLoading} onRefresh={refresh} />}\n            showsVerticalScrollIndicator={false}\n            contentContainerStyle={activities.length === 0 ? styles.emptyList : undefined}\n          />\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <SafeAreaView style={styles.container}>\n      {/* 統計情報 */}\n      {userStats && (\n        <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.statsContainer}>\n          <View style={styles.statItem}>\n            <Text style={styles.statValue}>{userStats.totalPosts}</Text>\n            <Text style={styles.statLabel}>投稿</Text>\n          </View>\n          <View style={styles.statItem}>\n            <Text style={styles.statValue}>{userStats.totalViews}</Text>\n            <Text style={styles.statLabel}>閲覧</Text>\n          </View>\n          <View style={styles.statItem}>\n            <Text style={styles.statValue}>{userStats.totalFavorites}</Text>\n            <Text style={styles.statLabel}>お気に入り</Text>\n          </View>\n          <View style={styles.statItem}>\n            <Text style={styles.statValue}>{userStats.totalBadges}</Text>\n            <Text style={styles.statLabel}>バッジ</Text>\n          </View>\n        </ScrollView>\n      )}\n\n      {/* タブバー */}\n      <View style={styles.tabBar}>\n        <TouchableOpacity\n          style={[styles.tab, activeTab === 'history' && styles.activeTab]}\n          onPress={() => setActiveTab('history')}\n        >\n          <Icon name=\"time\" size={20} color={activeTab === 'history' ? '#4285f4' : '#999'} />\n          <Text style={[styles.tabText, activeTab === 'history' && styles.activeTabText]}>\n            履歴\n          </Text>\n        </TouchableOpacity>\n\n        <TouchableOpacity\n          style={[styles.tab, activeTab === 'favorites' && styles.activeTab]}\n          onPress={() => setActiveTab('favorites')}\n        >\n          <Icon name=\"heart\" size={20} color={activeTab === 'favorites' ? '#4285f4' : '#999'} />\n          <Text style={[styles.tabText, activeTab === 'favorites' && styles.activeTabText]}>\n            お気に入り\n          </Text>\n        </TouchableOpacity>\n\n        <TouchableOpacity\n          style={[styles.tab, activeTab === 'activities' && styles.activeTab]}\n          onPress={() => setActiveTab('activities')}\n        >\n          <Icon name=\"list\" size={20} color={activeTab === 'activities' ? '#4285f4' : '#999'} />\n          <Text style={[styles.tabText, activeTab === 'activities' && styles.activeTabText]}>\n            活動\n          </Text>\n        </TouchableOpacity>\n      </View>\n\n      {/* アクションバー */}\n      {activeTab === 'history' && viewHistory.length > 0 && (\n        <View style={styles.actionBar}>\n          <Text style={styles.actionBarText}>{viewHistory.length}件の履歴</Text>\n          <TouchableOpacity\n            style={styles.clearButton}\n            onPress={clearViewHistory}\n            disabled={isUpdating}\n          >\n            <Icon name=\"trash-outline\" size={16} color=\"#ff4444\" />\n            <Text style={styles.clearButtonText}>クリア</Text>\n          </TouchableOpacity>\n        </View>\n      )}\n\n      {/* タブコンテンツ */}\n      <View style={styles.content}>{renderTabContent()}</View>\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  statsContainer: {\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    backgroundColor: '#f8f9fa',\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  statItem: {\n    alignItems: 'center',\n    marginRight: 24,\n    minWidth: 60,\n  },\n  statValue: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#333',\n  },\n  statLabel: {\n    fontSize: 12,\n    color: '#666',\n    marginTop: 2,\n  },\n  tabBar: {\n    flexDirection: 'row',\n    backgroundColor: '#fff',\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  tab: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    paddingVertical: 12,\n    paddingHorizontal: 8,\n  },\n  activeTab: {\n    borderBottomWidth: 2,\n    borderBottomColor: '#4285f4',\n  },\n  tabText: {\n    fontSize: 14,\n    color: '#999',\n    marginLeft: 6,\n  },\n  activeTabText: {\n    color: '#4285f4',\n    fontWeight: '600',\n  },\n  actionBar: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n    backgroundColor: '#f8f9fa',\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  actionBarText: {\n    fontSize: 14,\n    color: '#666',\n  },\n  clearButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n    borderRadius: 6,\n    backgroundColor: '#fff',\n    borderWidth: 1,\n    borderColor: '#ff4444',\n  },\n  clearButtonText: {\n    fontSize: 12,\n    color: '#ff4444',\n    marginLeft: 4,\n  },\n  content: {\n    flex: 1,\n  },\n  historyItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n  },\n  historyContent: {\n    flex: 1,\n  },\n  historyHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: 4,\n  },\n  historyTitle: {\n    flex: 1,\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n  },\n  historyMeta: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n  },\n  viewedDate: {\n    fontSize: 12,\n    color: '#666',\n  },\n  viewCount: {\n    fontSize: 12,\n    color: '#999',\n  },\n  favoriteItem: {\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n  },\n  favoriteContent: {\n    flex: 1,\n  },\n  favoriteHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: 4,\n  },\n  favoriteTitle: {\n    flex: 1,\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n  },\n  removeButton: {\n    padding: 4,\n  },\n  favoriteInfo: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n  },\n  addedDate: {\n    fontSize: 12,\n    color: '#666',\n  },\n  typeContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  typeIcon: {\n    fontSize: 14,\n    marginRight: 4,\n  },\n  typeLabel: {\n    fontSize: 12,\n    color: '#666',\n  },\n  activityItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n  },\n  activityIcon: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    backgroundColor: '#f0f0f0',\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginRight: 12,\n  },\n  activityEmoji: {\n    fontSize: 20,\n  },\n  activityContent: {\n    flex: 1,\n  },\n  activityDescription: {\n    fontSize: 14,\n    color: '#333',\n    lineHeight: 20,\n    marginBottom: 2,\n  },\n  activityTime: {\n    fontSize: 12,\n    color: '#999',\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 32,\n  },\n  emptyList: {\n    flex: 1,\n  },\n  emptyTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#999',\n    marginTop: 16,\n    marginBottom: 8,\n  },\n  emptyDescription: {\n    fontSize: 14,\n    color: '#ccc',\n    textAlign: 'center',\n    lineHeight: 20,\n  },\n});\n\nexport default HistoryScreen;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/map/MapScreen.tsx","messages":[{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { fontSize: 24, color: \"isFollowingUser ? '#4285f4' : '#333'\" }","line":127,"column":24,"nodeType":"ObjectExpression","endLine":127,"endColumn":83}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { View, StyleSheet, TouchableOpacity, Text } from 'react-native';\nimport MapView, { PROVIDER_GOOGLE, Region, Marker } from 'react-native-maps';\nimport { useLocation } from '../../hooks/useLocation';\nimport { DEFAULT_MAP_REGION, MapRegion, ToiletLocation } from '../../types/maps';\nimport { getToiletIcon, getToiletTypeColor } from '../../utils/mapUtils';\nimport { sampleToilets } from '../../data/sampleToilets';\n\nconst MapScreen: React.FC = () => {\n  const mapRef = useRef<MapView>(null);\n  const [currentRegion, setCurrentRegion] = useState<MapRegion>(DEFAULT_MAP_REGION);\n  const [isFollowingUser, setIsFollowingUser] = useState(false);\n  const [toiletLocations, setToiletLocations] = useState<ToiletLocation[]>([]);\n  const [userLocation, setUserLocation] = useState<{ latitude: number; longitude: number } | null>(null);\n\n  const {\n    isLoading: isLocationLoading,\n    getCurrentLocation,\n  } = useLocation();\n\n  // 現在位置に移動\n  const moveToCurrentLocation = useCallback(async () => {\n    try {\n      const currentUserLocation = await getCurrentLocation();\n      if (currentUserLocation && mapRef.current) {\n        setUserLocation(currentUserLocation);\n        const region: MapRegion = {\n          latitude: currentUserLocation.latitude,\n          longitude: currentUserLocation.longitude,\n          latitudeDelta: 0.01,\n          longitudeDelta: 0.01,\n        };\n\n        mapRef.current.animateToRegion(region, 1000);\n        setCurrentRegion(region);\n        setIsFollowingUser(true);\n      }\n    } catch (error) {\n      console.error('現在位置取得エラー:', error);\n    }\n  }, [getCurrentLocation]);\n\n  // 地図の領域変更時の処理\n  const handleRegionChangeComplete = useCallback((region: Region) => {\n    const newRegion = {\n      latitude: region.latitude,\n      longitude: region.longitude,\n      latitudeDelta: region.latitudeDelta,\n      longitudeDelta: region.longitudeDelta,\n    };\n    setCurrentRegion(newRegion);\n    setIsFollowingUser(false);\n  }, []);\n\n  // 初期化時にサンプルデータの読み込み\n  useEffect(() => {\n    setToiletLocations(sampleToilets);\n  }, []);\n\n  return (\n    <View style={styles.container}>\n      {/* 地図 */}\n      <MapView\n        ref={mapRef}\n        provider={PROVIDER_GOOGLE}\n        style={styles.map}\n        region={currentRegion}\n        onRegionChangeComplete={handleRegionChangeComplete}\n        showsUserLocation={true}\n        showsMyLocationButton={false}\n        showsCompass={true}\n        showsScale={true}\n        mapType=\"standard\"\n        toolbarEnabled={false}\n        moveOnMarkerPress={false}\n      >\n        {/* トイレマーカー */}\n        {toiletLocations.map(toilet => (\n          <Marker\n            key={toilet.id}\n            coordinate={{\n              latitude: toilet.latitude,\n              longitude: toilet.longitude,\n            }}\n            title={toilet.title}\n            description={toilet.description}\n          >\n            <View\n              style={[styles.markerContainer, { backgroundColor: getToiletTypeColor(toilet.type) }]}\n            >\n              <Text style={styles.markerIcon}>{getToiletIcon(toilet.type)}</Text>\n              {toilet.isAccessible && (\n                <View style={styles.accessibleBadge}>\n                  <Text style={styles.accessibilityIcon}>♿</Text>\n                </View>\n              )}\n            </View>\n          </Marker>\n        ))}\n\n        {/* 現在位置マーカー */}\n        {userLocation && (\n          <Marker\n            coordinate={userLocation}\n            title=\"現在位置\"\n            description=\"あなたの現在位置です\"\n          >\n            <View style={styles.userLocationMarker}>\n              <Text style={styles.userLocationIcon}>●</Text>\n            </View>\n          </Marker>\n        )}\n      </MapView>\n\n      {/* 浮きボタン */}\n      <View style={styles.floatingButtons}>\n        {/* 現在位置ボタン */}\n        <TouchableOpacity\n          style={[\n            styles.floatingButton,\n            isFollowingUser && styles.activeButton,\n            isLocationLoading && styles.loadingButton,\n          ]}\n          onPress={moveToCurrentLocation}\n          disabled={isLocationLoading}\n        >\n          <Text style={{fontSize: 24, color: isFollowingUser ? '#4285f4' : '#333'}}>\n            {isLocationLoading ? '🔄' : '📍'}\n          </Text>\n        </TouchableOpacity>\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  map: {\n    flex: 1,\n  },\n  floatingButtons: {\n    position: 'absolute',\n    right: 16,\n    bottom: 100,\n    alignItems: 'center',\n  },\n  floatingButton: {\n    width: 50,\n    height: 50,\n    borderRadius: 25,\n    backgroundColor: '#fff',\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginBottom: 12,\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.25,\n    shadowRadius: 4,\n    elevation: 5,\n  },\n  activeButton: {\n    backgroundColor: '#e3f2fd',\n  },\n  loadingButton: {\n    opacity: 0.6,\n  },\n  markerContainer: {\n    width: 36,\n    height: 36,\n    borderRadius: 18,\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 2,\n    borderColor: '#fff',\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.3,\n    shadowRadius: 4,\n    elevation: 5,\n  },\n  markerIcon: {\n    fontSize: 16,\n  },\n  accessibleBadge: {\n    position: 'absolute',\n    top: -4,\n    right: -4,\n    width: 16,\n    height: 16,\n    borderRadius: 8,\n    backgroundColor: '#4CAF50',\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 1,\n    borderColor: '#fff',\n  },\n  userLocationMarker: {\n    width: 20,\n    height: 20,\n    borderRadius: 10,\n    backgroundColor: '#4285f4',\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderWidth: 3,\n    borderColor: '#fff',\n    shadowColor: '#000',\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.3,\n    shadowRadius: 4,\n    elevation: 5,\n  },\n  userLocationIcon: {\n    fontSize: 8,\n    color: '#fff',\n    fontWeight: 'bold',\n  },\n  accessibilityIcon: {\n    fontSize: 8,\n    color: '#fff',\n  },\n});\n\nexport default MapScreen;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/notifications/NotificationListScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":39},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":147,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4360,4419],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  FlatList,\n  TouchableOpacity,\n  SafeAreaView,\n  RefreshControl,\n  ActivityIndicator,\n} from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { PushNotification, NotificationType } from '../../types/post';\nimport { useNotifications } from '../../hooks/useNotifications';\n\ninterface NotificationItemProps {\n  notification: PushNotification;\n  onPress: (notification: PushNotification) => void;\n}\n\nconst NotificationItem: React.FC<NotificationItemProps> = ({ notification, onPress }) => {\n  const getNotificationIcon = (type: NotificationType): string => {\n    switch (type) {\n      case NotificationType.BADGE_UNLOCKED:\n        return 'trophy';\n      case NotificationType.HELPFUL_VOTE:\n        return 'thumbs-up';\n      case NotificationType.NEW_TOILET_NEARBY:\n        return 'location';\n      case NotificationType.TOILET_UPDATED:\n        return 'refresh';\n      case NotificationType.MAINTENANCE_ALERT:\n        return 'warning';\n      case NotificationType.COMMUNITY_NEWS:\n        return 'newspaper';\n      case NotificationType.WEEKLY_SUMMARY:\n        return 'stats-chart';\n      case NotificationType.ACHIEVEMENT_REMINDER:\n        return 'alarm';\n      default:\n        return 'notifications';\n    }\n  };\n\n  const getNotificationColor = (type: NotificationType): string => {\n    switch (type) {\n      case NotificationType.BADGE_UNLOCKED:\n        return '#FFD700';\n      case NotificationType.HELPFUL_VOTE:\n        return '#4CAF50';\n      case NotificationType.NEW_TOILET_NEARBY:\n        return '#2196F3';\n      case NotificationType.TOILET_UPDATED:\n        return '#FF9800';\n      case NotificationType.MAINTENANCE_ALERT:\n        return '#f44336';\n      case NotificationType.COMMUNITY_NEWS:\n        return '#9C27B0';\n      case NotificationType.WEEKLY_SUMMARY:\n        return '#607D8B';\n      case NotificationType.ACHIEVEMENT_REMINDER:\n        return '#3F51B5';\n      default:\n        return '#666';\n    }\n  };\n\n  const formatDate = (date: Date): string => {\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));\n    const diffDays = Math.floor(diffHours / 24);\n\n    if (diffHours < 1) {\n      const diffMinutes = Math.floor(diffMs / (1000 * 60));\n      return diffMinutes < 1 ? 'たった今' : `${diffMinutes}分前`;\n    } else if (diffHours < 24) {\n      return `${diffHours}時間前`;\n    } else if (diffDays < 7) {\n      return `${diffDays}日前`;\n    } else {\n      return date.toLocaleDateString('ja-JP', {\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n      });\n    }\n  };\n\n  return (\n    <TouchableOpacity\n      style={[styles.notificationItem, !notification.isRead && styles.unreadItem]}\n      onPress={() => onPress(notification)}\n      activeOpacity={0.7}\n    >\n      {/* 通知アイコン */}\n      <View\n        style={[\n          styles.iconContainer,\n          { backgroundColor: `${getNotificationColor(notification.type)}20` },\n        ]}\n      >\n        <Icon\n          name={getNotificationIcon(notification.type)}\n          size={24}\n          color={getNotificationColor(notification.type)}\n        />\n      </View>\n\n      {/* 通知内容 */}\n      <View style={styles.contentContainer}>\n        <Text style={[styles.title, !notification.isRead && styles.unreadTitle]}>\n          {notification.title}\n        </Text>\n\n        <Text style={styles.body} numberOfLines={2}>\n          {notification.body}\n        </Text>\n\n        <Text style={styles.timestamp}>{formatDate(notification.createdAt)}</Text>\n      </View>\n\n      {/* 未読インジケーター */}\n      {!notification.isRead && <View style={styles.unreadIndicator} />}\n    </TouchableOpacity>\n  );\n};\n\nconst NotificationListScreen: React.FC = () => {\n  const { notifications, unreadCount, isLoading, loadNotifications, markAsRead, markAllAsRead } =\n    useNotifications();\n\n  // 通知アイテムをタップしたときの処理\n  const handleNotificationPress = useCallback(\n    async (notification: PushNotification) => {\n      // 未読の場合は既読にする\n      if (!notification.isRead) {\n        await markAsRead(notification.id);\n      }\n\n      // 通知のデータに基づいて画面遷移\n      if (notification.data) {\n        const { screen, toiletId, badgeId } = notification.data;\n\n        // 実際のナビゲーション処理（実装は簡略化）\n        console.log('Navigate to:', { screen, toiletId, badgeId });\n\n        // TODO: 実際のナビゲーション実装\n        // navigation.navigate(screen, { toiletId, badgeId });\n      }\n    },\n    [markAsRead],\n  );\n\n  // 全既読ボタンの処理\n  const handleMarkAllAsRead = useCallback(async () => {\n    if (unreadCount > 0) {\n      await markAllAsRead();\n    }\n  }, [unreadCount, markAllAsRead]);\n\n  // プルリフレッシュ\n  const handleRefresh = useCallback(async () => {\n    await loadNotifications();\n  }, [loadNotifications]);\n\n  // 空の状態のレンダリング\n  const renderEmptyState = () => (\n    <View style={styles.emptyContainer}>\n      <Icon name=\"notifications-off\" size={64} color=\"#ccc\" />\n      <Text style={styles.emptyTitle}>通知がありません</Text>\n      <Text style={styles.emptyDescription}>新しい通知が届くとここに表示されます</Text>\n    </View>\n  );\n\n  // リストアイテムのレンダリング\n  const renderNotificationItem = ({ item }: { item: PushNotification }) => (\n    <NotificationItem notification={item} onPress={handleNotificationPress} />\n  );\n\n  return (\n    <SafeAreaView style={styles.container}>\n      {/* ヘッダー */}\n      <View style={styles.header}>\n        <Text style={styles.headerTitle}>通知</Text>\n        {unreadCount > 0 && (\n          <TouchableOpacity style={styles.markAllButton} onPress={handleMarkAllAsRead}>\n            <Text style={styles.markAllButtonText}>すべて既読</Text>\n          </TouchableOpacity>\n        )}\n      </View>\n\n      {/* 未読数表示 */}\n      {unreadCount > 0 && (\n        <View style={styles.unreadCountContainer}>\n          <Text style={styles.unreadCountText}>{unreadCount}件の未読通知があります</Text>\n        </View>\n      )}\n\n      {/* 通知リスト */}\n      <FlatList\n        data={notifications}\n        renderItem={renderNotificationItem}\n        keyExtractor={item => item.id}\n        refreshControl={\n          <RefreshControl\n            refreshing={isLoading}\n            onRefresh={handleRefresh}\n            colors={['#4285f4']}\n            tintColor=\"#4285f4\"\n          />\n        }\n        ListEmptyComponent={renderEmptyState}\n        showsVerticalScrollIndicator={false}\n        contentContainerStyle={notifications.length === 0 ? styles.emptyList : undefined}\n      />\n\n      {/* ローディング表示 */}\n      {isLoading && notifications.length === 0 && (\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color=\"#4285f4\" />\n          <Text style={styles.loadingText}>通知を読み込み中...</Text>\n        </View>\n      )}\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  headerTitle: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#333',\n  },\n  markAllButton: {\n    paddingHorizontal: 12,\n    paddingVertical: 6,\n    borderRadius: 16,\n    backgroundColor: '#4285f4',\n  },\n  markAllButtonText: {\n    color: '#fff',\n    fontSize: 14,\n    fontWeight: '600',\n  },\n  unreadCountContainer: {\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n    backgroundColor: '#e3f2fd',\n  },\n  unreadCountText: {\n    fontSize: 14,\n    color: '#1976d2',\n    fontWeight: '500',\n  },\n  notificationItem: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n    backgroundColor: '#fff',\n  },\n  unreadItem: {\n    backgroundColor: '#fafafa',\n  },\n  iconContainer: {\n    width: 48,\n    height: 48,\n    borderRadius: 24,\n    justifyContent: 'center',\n    alignItems: 'center',\n    marginRight: 12,\n  },\n  contentContainer: {\n    flex: 1,\n  },\n  title: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n    marginBottom: 4,\n  },\n  unreadTitle: {\n    fontWeight: 'bold',\n  },\n  body: {\n    fontSize: 14,\n    color: '#666',\n    lineHeight: 20,\n    marginBottom: 6,\n  },\n  timestamp: {\n    fontSize: 12,\n    color: '#999',\n  },\n  unreadIndicator: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n    backgroundColor: '#4285f4',\n    marginLeft: 8,\n    marginTop: 8,\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 32,\n  },\n  emptyList: {\n    flex: 1,\n  },\n  emptyTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#999',\n    marginTop: 16,\n    marginBottom: 8,\n  },\n  emptyDescription: {\n    fontSize: 14,\n    color: '#ccc',\n    textAlign: 'center',\n    lineHeight: 20,\n  },\n  loadingContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n  },\n  loadingText: {\n    marginTop: 16,\n    fontSize: 16,\n    color: '#666',\n  },\n});\n\nexport default NotificationListScreen;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/post/PostReviewScreen.tsx","messages":[{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":254,"column":74,"nodeType":"CallExpression","messageId":"missingRadix","endLine":254,"endColumn":88,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[8950,8950],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":266,"column":61,"nodeType":"CallExpression","messageId":"missingRadix","endLine":266,"endColumn":75,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[9568,9568],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":290,"column":64,"nodeType":"CallExpression","messageId":"missingRadix","endLine":290,"endColumn":78,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[10588,10588],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":305,"column":63,"nodeType":"CallExpression","messageId":"missingRadix","endLine":305,"endColumn":77,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[11275,11275],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":331,"column":64,"nodeType":"CallExpression","messageId":"missingRadix","endLine":331,"endColumn":78,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[12405,12405],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]},{"ruleId":"radix","severity":1,"message":"Missing radix parameter.","line":346,"column":63,"nodeType":"CallExpression","messageId":"missingRadix","endLine":346,"endColumn":77,"suggestions":[{"messageId":"addRadixParameter10","fix":{"range":[13092,13092],"text":", 10"},"desc":"Add radix parameter `10` for parsing decimal numbers."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  ScrollView,\n  TextInput,\n  TouchableOpacity,\n  Switch,\n  Modal,\n  Alert,\n  SafeAreaView,\n} from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { useToiletPost } from '../../hooks/useToiletPost';\nimport {\n  toiletTypeOptions,\n  facilityLabels,\n  facilityIcons,\n  ratingCategories,\n  genderTypeOptions,\n  DetailedToiletEquipment,\n} from '../../types/post';\nimport { ToiletType } from '../../types/maps';\nimport LocationPicker from '../../components/map/LocationPicker';\nimport ImagePickerComponent from '../../components/post/ImagePicker';\nimport StarRating from '../../components/common/StarRating';\n\nconst PostReviewScreen: React.FC = () => {\n  const {\n    form,\n    isLoading,\n    errors,\n    updateTitle,\n    updateDescription,\n    updateType,\n    updateAccessibility,\n    updateLocation,\n    updateFacility,\n    updateOpeningHours,\n    updateAdditionalInfo,\n    updateRating,\n    updateDetailedEquipment,\n    updateMaleEquipment,\n    updateFemaleEquipment,\n    updateSharedEquipment,\n    updateAdditionalFeatures,\n    addImage,\n    removeImage,\n    submitForm,\n    resetForm,\n  } = useToiletPost();\n\n  const [showLocationPicker, setShowLocationPicker] = useState(false);\n  const [showTypePicker, setShowTypePicker] = useState(false);\n\n  // 位置選択の確定\n  const handleLocationConfirm = useCallback(() => {\n    setShowLocationPicker(false);\n  }, []);\n\n  // タイプ選択\n  const handleTypeSelect = useCallback(\n    (type: ToiletType) => {\n      updateType(type);\n      setShowTypePicker(false);\n    },\n    [updateType],\n  );\n\n  // フォーム送信\n  const handleSubmit = useCallback(async () => {\n    const success = await submitForm();\n    if (success) {\n      Alert.alert('投稿完了', 'トイレ情報が正常に投稿されました！', [\n        { text: 'OK', onPress: resetForm },\n      ]);\n    }\n  }, [submitForm, resetForm]);\n\n  const selectedTypeOption = toiletTypeOptions.find(option => option.value === form.type);\n\n  return (\n    <SafeAreaView style={styles.container}>\n      {/* ヘッダー */}\n      <View style={styles.header}>\n        <TouchableOpacity onPress={resetForm}>\n          <Icon name=\"close\" size={24} color=\"#333\" />\n        </TouchableOpacity>\n        <Text style={styles.headerTitle}>トイレを投稿</Text>\n        <TouchableOpacity\n          onPress={handleSubmit}\n          disabled={isLoading}\n          style={[styles.submitButton, isLoading && styles.disabledButton]}\n        >\n          <Text style={styles.submitButtonText}>{isLoading ? '投稿中...' : '投稿'}</Text>\n        </TouchableOpacity>\n      </View>\n\n      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>\n        {/* エラー表示 */}\n        {errors.length > 0 && (\n          <View style={styles.errorContainer}>\n            {errors.map((error, index) => (\n              <Text key={index} style={styles.errorText}>\n                • {error}\n              </Text>\n            ))}\n          </View>\n        )}\n\n        {/* 基本情報 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>基本情報</Text>\n\n          {/* タイトル */}\n          <View style={styles.inputGroup}>\n            <Text style={styles.label}>タイトル *</Text>\n            <TextInput\n              style={styles.textInput}\n              value={form.toilets[0]?.title || ''}\n              onChangeText={updateTitle}\n              placeholder=\"例: 東京駅丸の内口トイレ\"\n              maxLength={50}\n            />\n            <Text style={styles.charCount}>{form.toilets[0]?.title.length || 0}/50</Text>\n          </View>\n\n          {/* 説明 */}\n          <View style={styles.inputGroup}>\n            <Text style={styles.label}>説明</Text>\n            <TextInput\n              style={[styles.textInput, styles.textArea]}\n              value={form.toilets[0]?.description || ''}\n              onChangeText={updateDescription}\n              placeholder=\"トイレの特徴や注意点など...\"\n              multiline\n              numberOfLines={4}\n              maxLength={500}\n            />\n            <Text style={styles.charCount}>{form.toilets[0]?.description.length || 0}/500</Text>\n          </View>\n\n          {/* トイレタイプ */}\n          <View style={styles.inputGroup}>\n            <Text style={styles.label}>トイレタイプ *</Text>\n            <TouchableOpacity style={styles.picker} onPress={() => setShowTypePicker(true)}>\n              <Text style={styles.pickerText}>\n                {selectedTypeOption\n                  ? `${selectedTypeOption.icon} ${selectedTypeOption.label}`\n                  : 'タイプを選択'}\n              </Text>\n              <Icon name=\"chevron-down\" size={20} color=\"#666\" />\n            </TouchableOpacity>\n          </View>\n\n          {/* 位置情報 */}\n          <View style={styles.inputGroup}>\n            <Text style={styles.label}>位置情報 *</Text>\n            <TouchableOpacity style={styles.picker} onPress={() => setShowLocationPicker(true)}>\n              <Text style={styles.pickerText}>\n                {form.location\n                  ? `📍 ${form.location.latitude.toFixed(4)}, ${form.location.longitude.toFixed(4)}`\n                  : '位置を選択してください'}\n              </Text>\n              <Icon name=\"chevron-down\" size={20} color=\"#666\" />\n            </TouchableOpacity>\n          </View>\n\n          {/* アクセシビリティ */}\n          <View style={styles.switchGroup}>\n            <View style={styles.switchContent}>\n              <Icon name=\"accessibility\" size={20} color=\"#4CAF50\" style={styles.switchIcon} />\n              <Text style={styles.switchLabel}>バリアフリー対応</Text>\n            </View>\n            <Switch\n              value={form.toilets[0]?.isAccessible || false}\n              onValueChange={updateAccessibility}\n              thumbColor=\"#fff\"\n              trackColor={{ false: '#ccc', true: '#4CAF50' }}\n            />\n          </View>\n        </View>\n\n        {/* 設備情報 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>設備情報</Text>\n          {Object.entries(facilityLabels).map(([key, label]) => (\n            <View key={key} style={styles.switchGroup}>\n              <View style={styles.switchContent}>\n                <Text style={styles.switchIcon}>\n                  {facilityIcons[key as keyof typeof facilityIcons]}\n                </Text>\n                <Text style={styles.switchLabel}>{label}</Text>\n              </View>\n              <Switch\n                value={form.toilets[0]?.facilities[key as keyof typeof facilityLabels] || false}\n                onValueChange={(value: boolean) => updateFacility(key, value)}\n                thumbColor=\"#fff\"\n                trackColor={{ false: '#ccc', true: '#4285f4' }}\n              />\n            </View>\n          ))}\n        </View>\n\n        {/* 詳細設備情報 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>詳細設備情報</Text>\n\n          {/* 男女区分 */}\n          <View style={styles.inputGroup}>\n            <Text style={styles.label}>男女区分</Text>\n            <View style={styles.genderTypeContainer}>\n              {genderTypeOptions.map(option => (\n                <TouchableOpacity\n                  key={option.value}\n                  style={[\n                    styles.genderTypeOption,\n                    form.toilets[0]?.detailedEquipment.genderType === option.value && styles.selectedGenderType,\n                  ]}\n                  onPress={() =>\n                    updateDetailedEquipment({\n                      genderType: option.value as 'separate' | 'shared' | 'multipurpose',\n                      maleEquipment:\n                        option.value === 'separate' ? { urinals: 0, westernToilets: 0 } : null,\n                      femaleEquipment:\n                        option.value === 'separate'\n                          ? { japaneseToilets: 0, westernToilets: 0 }\n                          : null,\n                      sharedEquipment:\n                        option.value !== 'separate'\n                          ? { japaneseToilets: 0, westernToilets: 0 }\n                          : null,\n                    })\n                  }\n                >\n                  <Text style={styles.genderTypeIcon}>{option.icon}</Text>\n                  <Text style={styles.genderTypeLabel}>{option.label}</Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </View>\n\n          {/* 男性用設備（男女別の場合） */}\n          {form.toilets[0]?.detailedEquipment.genderType === 'separate' && (\n            <View style={styles.equipmentSection}>\n              <Text style={styles.equipmentTitle}>🚹 男性用設備</Text>\n              <View style={styles.equipmentRow}>\n                <View style={styles.equipmentItem}>\n                  <Text style={styles.equipmentLabel}>小便器</Text>\n                  <TextInput\n                    style={styles.numberInput}\n                    value={form.toilets[0]?.detailedEquipment.maleEquipment?.urinals?.toString() || '0'}\n                    onChangeText={text => updateMaleEquipment({ urinals: parseInt(text) || 0 })}\n                    keyboardType=\"numeric\"\n                    placeholder=\"0\"\n                  />\n                  <Text style={styles.equipmentUnit}>台</Text>\n                </View>\n                <View style={styles.equipmentItem}>\n                  <Text style={styles.equipmentLabel}>洋式便器</Text>\n                  <TextInput\n                    style={styles.numberInput}\n                    value={form.toilets[0]?.detailedEquipment.maleEquipment?.westernToilets?.toString() || '0'}\n                    onChangeText={text =>\n                      updateMaleEquipment({ westernToilets: parseInt(text) || 0 })\n                    }\n                    keyboardType=\"numeric\"\n                    placeholder=\"0\"\n                  />\n                  <Text style={styles.equipmentUnit}>台</Text>\n                </View>\n              </View>\n            </View>\n          )}\n\n          {/* 女性用設備（男女別の場合） */}\n          {form.toilets[0]?.detailedEquipment.genderType === 'separate' && (\n            <View style={styles.equipmentSection}>\n              <Text style={styles.equipmentTitle}>🚺 女性用設備</Text>\n              <View style={styles.equipmentRow}>\n                <View style={styles.equipmentItem}>\n                  <Text style={styles.equipmentLabel}>和式便器</Text>\n                  <TextInput\n                    style={styles.numberInput}\n                    value={\n                      form.toilets[0]?.detailedEquipment.femaleEquipment?.japaneseToilets?.toString() || '0'\n                    }\n                    onChangeText={text =>\n                      updateFemaleEquipment({ japaneseToilets: parseInt(text) || 0 })\n                    }\n                    keyboardType=\"numeric\"\n                    placeholder=\"0\"\n                  />\n                  <Text style={styles.equipmentUnit}>台</Text>\n                </View>\n                <View style={styles.equipmentItem}>\n                  <Text style={styles.equipmentLabel}>洋式便器</Text>\n                  <TextInput\n                    style={styles.numberInput}\n                    value={\n                      form.toilets[0]?.detailedEquipment.femaleEquipment?.westernToilets?.toString() || '0'\n                    }\n                    onChangeText={text =>\n                      updateFemaleEquipment({ westernToilets: parseInt(text) || 0 })\n                    }\n                    keyboardType=\"numeric\"\n                    placeholder=\"0\"\n                  />\n                  <Text style={styles.equipmentUnit}>台</Text>\n                </View>\n              </View>\n            </View>\n          )}\n\n          {/* 共用設備（共用・多目的の場合） */}\n          {form.toilets[0]?.detailedEquipment.genderType !== 'separate' && (\n            <View style={styles.equipmentSection}>\n              <Text style={styles.equipmentTitle}>\n                {form.toilets[0]?.detailedEquipment.genderType === 'shared' ? '🚽 共用設備' : '♿ 多目的設備'}\n              </Text>\n              <View style={styles.equipmentRow}>\n                <View style={styles.equipmentItem}>\n                  <Text style={styles.equipmentLabel}>和式便器</Text>\n                  <TextInput\n                    style={styles.numberInput}\n                    value={\n                      form.toilets[0]?.detailedEquipment.sharedEquipment?.japaneseToilets?.toString() || '0'\n                    }\n                    onChangeText={text =>\n                      updateSharedEquipment({ japaneseToilets: parseInt(text) || 0 })\n                    }\n                    keyboardType=\"numeric\"\n                    placeholder=\"0\"\n                  />\n                  <Text style={styles.equipmentUnit}>台</Text>\n                </View>\n                <View style={styles.equipmentItem}>\n                  <Text style={styles.equipmentLabel}>洋式便器</Text>\n                  <TextInput\n                    style={styles.numberInput}\n                    value={\n                      form.toilets[0]?.detailedEquipment.sharedEquipment?.westernToilets?.toString() || '0'\n                    }\n                    onChangeText={text =>\n                      updateSharedEquipment({ westernToilets: parseInt(text) || 0 })\n                    }\n                    keyboardType=\"numeric\"\n                    placeholder=\"0\"\n                  />\n                  <Text style={styles.equipmentUnit}>台</Text>\n                </View>\n              </View>\n            </View>\n          )}\n\n          {/* 追加設備 */}\n          <View style={styles.equipmentSection}>\n            <Text style={styles.equipmentTitle}>🔧 追加設備</Text>\n            {Object.entries({\n              hasBabyChangingTable: 'おむつ替え台',\n              hasHandDryer: 'ハンドドライヤー',\n              hasWashlet: 'ウォシュレット',\n              hasPaperTowels: 'ペーパータオル',\n              hasHandSoap: 'ハンドソープ',\n              hasVendingMachine: '自動販売機',\n              hasWheelchairAccess: '車椅子対応',\n            }).map(([key, label]) => (\n              <View key={key} style={styles.switchGroup}>\n                <Text style={styles.switchLabel}>{label}</Text>\n                <Switch\n                  value={\n                    form.toilets[0]?.detailedEquipment.additionalFeatures[\n                      key as keyof DetailedToiletEquipment['additionalFeatures']\n                    ] || false\n                  }\n                  onValueChange={value =>\n                    updateAdditionalFeatures(\n                      key as keyof DetailedToiletEquipment['additionalFeatures'],\n                      value,\n                    )\n                  }\n                  thumbColor=\"#fff\"\n                  trackColor={{ false: '#ccc', true: '#4285f4' }}\n                />\n              </View>\n            ))}\n          </View>\n        </View>\n\n        {/* 営業時間 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>営業時間</Text>\n\n          <View style={styles.switchGroup}>\n            <Text style={styles.switchLabel}>24時間利用可能</Text>\n            <Switch\n              value={form.openingHours.is24Hours}\n              onValueChange={value => updateOpeningHours({ is24Hours: value })}\n              thumbColor=\"#fff\"\n              trackColor={{ false: '#ccc', true: '#4285f4' }}\n            />\n          </View>\n\n          {!form.openingHours.is24Hours && (\n            <View style={styles.timeInputs}>\n              <View style={styles.timeInput}>\n                <Text style={styles.label}>開始時間</Text>\n                <TextInput\n                  style={styles.textInput}\n                  value={form.openingHours.openTime || ''}\n                  onChangeText={time => updateOpeningHours({ openTime: time })}\n                  placeholder=\"09:00\"\n                />\n              </View>\n              <View style={styles.timeInput}>\n                <Text style={styles.label}>終了時間</Text>\n                <TextInput\n                  style={styles.textInput}\n                  value={form.openingHours.closeTime || ''}\n                  onChangeText={time => updateOpeningHours({ closeTime: time })}\n                  placeholder=\"21:00\"\n                />\n              </View>\n            </View>\n          )}\n\n          <View style={styles.inputGroup}>\n            <Text style={styles.label}>営業時間の備考</Text>\n            <TextInput\n              style={styles.textInput}\n              value={form.openingHours.notes || ''}\n              onChangeText={notes => updateOpeningHours({ notes })}\n              placeholder=\"例: 年末年始は休業\"\n            />\n          </View>\n        </View>\n\n        {/* 評価軸 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>評価</Text>\n          {ratingCategories.map(category => (\n            <StarRating\n              key={category.key}\n              rating={form.toilets[0]?.ratings[category.key] || 0}\n              onRatingChange={rating => updateRating(category.key, rating)}\n              label={`${category.icon} ${category.label}`}\n              description={category.description}\n              required={category.required}\n              showValue={true}\n            />\n          ))}\n        </View>\n\n        {/* 写真 */}\n        <View style={styles.section}>\n          <ImagePickerComponent\n            images={form.toilets[0]?.images || []}\n            onAddImage={addImage}\n            onRemoveImage={removeImage}\n            maxImages={5}\n          />\n        </View>\n\n        {/* 追加情報 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>追加情報</Text>\n          <TextInput\n            style={[styles.textInput, styles.textArea]}\n            value={form.additionalInfo}\n            onChangeText={updateAdditionalInfo}\n            placeholder=\"その他気付いた点や注意事項があれば...\"\n            multiline\n            numberOfLines={3}\n            maxLength={300}\n          />\n          <Text style={styles.charCount}>{form.additionalInfo.length}/300</Text>\n        </View>\n\n        {/* 底部スペース */}\n        <View style={styles.bottomSpace} />\n      </ScrollView>\n\n      {/* 位置選択モーダル */}\n      <Modal visible={showLocationPicker} animationType=\"slide\" presentationStyle=\"fullScreen\">\n        <LocationPicker\n          selectedLocation={form.location}\n          onLocationSelect={updateLocation}\n          onCancel={() => setShowLocationPicker(false)}\n          onConfirm={handleLocationConfirm}\n        />\n      </Modal>\n\n      {/* タイプ選択モーダル */}\n      <Modal visible={showTypePicker} animationType=\"slide\" transparent={true}>\n        <View style={styles.modalOverlay}>\n          <View style={styles.typePickerModal}>\n            <View style={styles.modalHeader}>\n              <Text style={styles.modalTitle}>トイレタイプを選択</Text>\n              <TouchableOpacity onPress={() => setShowTypePicker(false)}>\n                <Icon name=\"close\" size={24} color=\"#333\" />\n              </TouchableOpacity>\n            </View>\n            <ScrollView>\n              {toiletTypeOptions.map(option => (\n                <TouchableOpacity\n                  key={option.value}\n                  style={[\n                    styles.typeOption,\n                    form.type === option.value && styles.selectedTypeOption,\n                  ]}\n                  onPress={() => handleTypeSelect(option.value)}\n                >\n                  <Text style={styles.typeIcon}>{option.icon}</Text>\n                  <Text style={styles.typeLabel}>{option.label}</Text>\n                  {form.type === option.value && (\n                    <Icon name=\"checkmark-circle\" size={24} color=\"#4285f4\" />\n                  )}\n                </TouchableOpacity>\n              ))}\n            </ScrollView>\n          </View>\n        </View>\n      </Modal>\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  headerTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n  },\n  submitButton: {\n    backgroundColor: '#4285f4',\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n    borderRadius: 6,\n  },\n  disabledButton: {\n    opacity: 0.6,\n  },\n  submitButtonText: {\n    color: '#fff',\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  content: {\n    flex: 1,\n    paddingHorizontal: 16,\n  },\n  errorContainer: {\n    backgroundColor: '#ffebee',\n    padding: 12,\n    borderRadius: 8,\n    marginVertical: 16,\n    borderLeftWidth: 4,\n    borderLeftColor: '#f44336',\n  },\n  errorText: {\n    color: '#c62828',\n    fontSize: 14,\n    marginBottom: 4,\n  },\n  section: {\n    marginVertical: 16,\n  },\n  sectionTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 16,\n  },\n  inputGroup: {\n    marginBottom: 16,\n  },\n  label: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n    marginBottom: 8,\n  },\n  textInput: {\n    borderWidth: 1,\n    borderColor: '#ddd',\n    borderRadius: 8,\n    paddingHorizontal: 12,\n    paddingVertical: 12,\n    fontSize: 16,\n    backgroundColor: '#fff',\n  },\n  textArea: {\n    height: 100,\n    textAlignVertical: 'top',\n  },\n  charCount: {\n    fontSize: 12,\n    color: '#999',\n    textAlign: 'right',\n    marginTop: 4,\n  },\n  picker: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    borderWidth: 1,\n    borderColor: '#ddd',\n    borderRadius: 8,\n    paddingHorizontal: 12,\n    paddingVertical: 16,\n    backgroundColor: '#fff',\n  },\n  pickerText: {\n    fontSize: 16,\n    color: '#333',\n  },\n  switchGroup: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n  },\n  switchContent: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    flex: 1,\n  },\n  switchIcon: {\n    fontSize: 18,\n    marginRight: 12,\n  },\n  switchLabel: {\n    fontSize: 16,\n    color: '#333',\n  },\n  timeInputs: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    marginTop: 16,\n  },\n  timeInput: {\n    flex: 0.48,\n  },\n  bottomSpace: {\n    height: 50,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n    justifyContent: 'flex-end',\n  },\n  typePickerModal: {\n    backgroundColor: '#fff',\n    borderTopLeftRadius: 20,\n    borderTopRightRadius: 20,\n    maxHeight: '80%',\n  },\n  modalHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 16,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  modalTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n  },\n  typeOption: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 16,\n    paddingVertical: 16,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n  },\n  selectedTypeOption: {\n    backgroundColor: '#e3f2fd',\n  },\n  typeIcon: {\n    fontSize: 24,\n    marginRight: 12,\n  },\n  typeLabel: {\n    fontSize: 16,\n    color: '#333',\n    flex: 1,\n  },\n  genderTypeContainer: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n  },\n  genderTypeOption: {\n    flex: 1,\n    alignItems: 'center',\n    paddingVertical: 12,\n    paddingHorizontal: 8,\n    marginHorizontal: 4,\n    borderRadius: 8,\n    borderWidth: 1,\n    borderColor: '#ddd',\n    backgroundColor: '#fff',\n  },\n  selectedGenderType: {\n    backgroundColor: '#e3f2fd',\n    borderColor: '#4285f4',\n  },\n  genderTypeIcon: {\n    fontSize: 20,\n    marginBottom: 4,\n  },\n  genderTypeLabel: {\n    fontSize: 12,\n    color: '#333',\n    textAlign: 'center',\n  },\n  equipmentSection: {\n    marginTop: 16,\n    padding: 12,\n    backgroundColor: '#f8f9fa',\n    borderRadius: 8,\n  },\n  equipmentTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n    marginBottom: 12,\n  },\n  equipmentRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n  },\n  equipmentItem: {\n    flex: 1,\n    alignItems: 'center',\n    marginHorizontal: 8,\n  },\n  equipmentLabel: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 8,\n    textAlign: 'center',\n  },\n  numberInput: {\n    borderWidth: 1,\n    borderColor: '#ddd',\n    borderRadius: 6,\n    paddingHorizontal: 12,\n    paddingVertical: 8,\n    fontSize: 16,\n    backgroundColor: '#fff',\n    textAlign: 'center',\n    minWidth: 60,\n  },\n  equipmentUnit: {\n    fontSize: 12,\n    color: '#666',\n    marginTop: 4,\n  },\n});\n\nexport default PostReviewScreen;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/report/ReportHistoryScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[477,480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[477,480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { backgroundColor: \"isNearViolationLimit ? '#f44336' : '#4285f4'\" }","line":161,"column":17,"nodeType":"ObjectExpression","endLine":164,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  SafeAreaView,\n  FlatList,\n  TouchableOpacity,\n  RefreshControl,\n  Alert,\n} from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { Report, ReportTargetType, ReportStatus } from '../../types/post';\nimport { useReport } from '../../hooks/useReport';\n\ninterface ReportItemProps {\n  item: Report;\n  onPress: (report: Report) => void;\n  getReasonDisplayName: (reason: any) => string;\n  getStatusDisplayName: (status: ReportStatus) => string;\n  getStatusColor: (status: ReportStatus) => string;\n}\n\nconst ReportItem: React.FC<ReportItemProps> = ({\n  item,\n  onPress,\n  getReasonDisplayName,\n  getStatusDisplayName,\n  getStatusColor,\n}) => {\n  const getTargetTypeIcon = (type: ReportTargetType) => {\n    switch (type) {\n      case ReportTargetType.TOILET:\n        return '🚽';\n      case ReportTargetType.REVIEW:\n        return '⭐';\n      case ReportTargetType.USER:\n        return '👤';\n      case ReportTargetType.COMMENT:\n        return '💬';\n      default:\n        return '📝';\n    }\n  };\n\n  const getTargetTypeDisplayName = (type: ReportTargetType) => {\n    const names = {\n      [ReportTargetType.TOILET]: 'トイレ投稿',\n      [ReportTargetType.REVIEW]: 'レビュー',\n      [ReportTargetType.USER]: 'ユーザー',\n      [ReportTargetType.COMMENT]: 'コメント',\n    };\n    return names[type] || type;\n  };\n\n  const formatDate = (date: Date) =>\n    date.toLocaleDateString('ja-JP', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n\n  return (\n    <TouchableOpacity style={styles.reportItem} onPress={() => onPress(item)} activeOpacity={0.7}>\n      <View style={styles.reportHeader}>\n        <View style={styles.targetInfo}>\n          <Text style={styles.targetIcon}>{getTargetTypeIcon(item.targetType)}</Text>\n          <Text style={styles.targetType}>{getTargetTypeDisplayName(item.targetType)}</Text>\n        </View>\n        <View style={[styles.statusBadge, { backgroundColor: getStatusColor(item.status) }]}>\n          <Text style={styles.statusText}>{getStatusDisplayName(item.status)}</Text>\n        </View>\n      </View>\n\n      <Text style={styles.reasonText}>理由: {getReasonDisplayName(item.reason)}</Text>\n\n      {item.description && (\n        <Text style={styles.descriptionText} numberOfLines={2}>\n          {item.description}\n        </Text>\n      )}\n\n      <View style={styles.reportFooter}>\n        <Text style={styles.dateText}>{formatDate(item.createdAt)}</Text>\n        <Icon name=\"chevron-forward\" size={16} color=\"#ccc\" />\n      </View>\n    </TouchableOpacity>\n  );\n};\n\nconst ReportHistoryScreen: React.FC = () => {\n  const {\n    reports,\n    userRestrictions,\n    violationPoints,\n    isLoading,\n    error,\n    getReasonDisplayName,\n    getStatusDisplayName,\n    getStatusColor,\n    hasActiveRestrictions,\n    isNearViolationLimit,\n    refresh,\n  } = useReport();\n\n  const handleReportPress = useCallback(\n    (report: Report) => {\n      Alert.alert(\n        '通報詳細',\n        `ID: ${report.id}\\n` +\n          `対象: ${report.targetType}\\n` +\n          `理由: ${getReasonDisplayName(report.reason)}\\n` +\n          `状態: ${getStatusDisplayName(report.status)}\\n` +\n          `日時: ${report.createdAt.toLocaleString('ja-JP')}${\n            report.description ? `\\n詳細: ${report.description}` : ''\n          }${report.resolution ? `\\n処理結果: ${report.resolution}` : ''}`,\n        [{ text: 'OK' }],\n      );\n    },\n    [getReasonDisplayName, getStatusDisplayName],\n  );\n\n  const renderReportItem = ({ item }: { item: Report }) => (\n    <ReportItem\n      item={item}\n      onPress={handleReportPress}\n      getReasonDisplayName={getReasonDisplayName}\n      getStatusDisplayName={getStatusDisplayName}\n      getStatusColor={getStatusColor}\n    />\n  );\n\n  const renderEmptyState = () => (\n    <View style={styles.emptyContainer}>\n      <Icon name=\"flag-outline\" size={64} color=\"#ccc\" />\n      <Text style={styles.emptyTitle}>通報履歴がありません</Text>\n      <Text style={styles.emptyDescription}>\n        問題のあるコンテンツを発見した場合は、通報機能をご利用ください\n      </Text>\n    </View>\n  );\n\n  const renderHeader = () => (\n    <View style={styles.headerContainer}>\n      {/* 違反ポイント表示 */}\n      <View style={styles.pointsCard}>\n        <View style={styles.pointsHeader}>\n          <Icon name=\"alert-circle-outline\" size={20} color=\"#666\" />\n          <Text style={styles.pointsTitle}>違反ポイント</Text>\n        </View>\n        <View style={styles.pointsContent}>\n          <Text style={[styles.pointsValue, isNearViolationLimit && styles.dangerPoints]}>\n            {violationPoints} / 20\n          </Text>\n          <View style={styles.pointsBar}>\n            <View\n              style={[\n                styles.pointsProgress,\n                {\n                  width: `${Math.min((violationPoints / 20) * 100, 100)}%`,\n                  backgroundColor: isNearViolationLimit ? '#f44336' : '#4285f4',\n                },\n              ]}\n            />\n          </View>\n        </View>\n        {isNearViolationLimit && (\n          <Text style={styles.warningText}>\n            ⚠️ 違反ポイントが高くなっています。20ポイントで永久停止となります。\n          </Text>\n        )}\n      </View>\n\n      {/* アクティブな制限表示 */}\n      {hasActiveRestrictions && (\n        <View style={styles.restrictionsCard}>\n          <View style={styles.restrictionsHeader}>\n            <Icon name=\"lock-closed\" size={20} color=\"#f44336\" />\n            <Text style={styles.restrictionsTitle}>利用制限</Text>\n          </View>\n          {userRestrictions.map(restriction => (\n            <View key={restriction.id} style={styles.restrictionItem}>\n              <Text style={styles.restrictionType}>\n                {getRestrictionTypeDisplayName(restriction.type)}\n              </Text>\n              <Text style={styles.restrictionReason}>{restriction.reason}</Text>\n              {restriction.endDate && (\n                <Text style={styles.restrictionEndDate}>\n                  {restriction.endDate.toLocaleDateString('ja-JP')}まで\n                </Text>\n              )}\n            </View>\n          ))}\n        </View>\n      )}\n\n      {/* 統計情報 */}\n      <View style={styles.statsCard}>\n        <Text style={styles.statsTitle}>通報統計</Text>\n        <View style={styles.statsGrid}>\n          <View style={styles.statItem}>\n            <Text style={styles.statValue}>{reports.length}</Text>\n            <Text style={styles.statLabel}>総通報数</Text>\n          </View>\n          <View style={styles.statItem}>\n            <Text style={styles.statValue}>\n              {reports.filter(r => r.status === 'resolved' || r.status === 'auto_resolved').length}\n            </Text>\n            <Text style={styles.statLabel}>解決済み</Text>\n          </View>\n          <View style={styles.statItem}>\n            <Text style={styles.statValue}>\n              {reports.filter(r => r.status === 'pending' || r.status === 'under_review').length}\n            </Text>\n            <Text style={styles.statLabel}>審査中</Text>\n          </View>\n        </View>\n      </View>\n\n      <Text style={styles.sectionTitle}>通報履歴</Text>\n    </View>\n  );\n\n  const getRestrictionTypeDisplayName = (type: string): string => {\n    const names: { [key: string]: string } = {\n      post_restriction: '投稿制限',\n      comment_restriction: 'コメント制限',\n      review_restriction: 'レビュー制限',\n      vote_restriction: '投票制限',\n      temporary_ban: '一時停止',\n      permanent_ban: '永久停止',\n      warning: '警告',\n    };\n    return names[type] || type;\n  };\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <FlatList\n        data={reports}\n        renderItem={renderReportItem}\n        keyExtractor={item => item.id}\n        ListHeaderComponent={renderHeader}\n        ListEmptyComponent={reports.length === 0 ? renderEmptyState : null}\n        refreshControl={<RefreshControl refreshing={isLoading} onRefresh={refresh} />}\n        showsVerticalScrollIndicator={false}\n        contentContainerStyle={reports.length === 0 ? styles.emptyList : undefined}\n      />\n\n      {error && (\n        <View style={styles.errorContainer}>\n          <Text style={styles.errorText}>{error}</Text>\n        </View>\n      )}\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  headerContainer: {\n    padding: 16,\n  },\n  pointsCard: {\n    backgroundColor: '#f8f9fa',\n    borderRadius: 12,\n    padding: 16,\n    marginBottom: 16,\n  },\n  pointsHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: 12,\n  },\n  pointsTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n    marginLeft: 8,\n  },\n  pointsContent: {\n    marginBottom: 8,\n  },\n  pointsValue: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 8,\n  },\n  dangerPoints: {\n    color: '#f44336',\n  },\n  pointsBar: {\n    height: 8,\n    backgroundColor: '#e0e0e0',\n    borderRadius: 4,\n    overflow: 'hidden',\n  },\n  pointsProgress: {\n    height: '100%',\n    borderRadius: 4,\n  },\n  warningText: {\n    fontSize: 12,\n    color: '#f44336',\n    marginTop: 8,\n    lineHeight: 16,\n  },\n  restrictionsCard: {\n    backgroundColor: '#ffebee',\n    borderRadius: 12,\n    padding: 16,\n    marginBottom: 16,\n    borderLeftWidth: 4,\n    borderLeftColor: '#f44336',\n  },\n  restrictionsHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: 12,\n  },\n  restrictionsTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#f44336',\n    marginLeft: 8,\n  },\n  restrictionItem: {\n    marginBottom: 8,\n  },\n  restrictionType: {\n    fontSize: 14,\n    fontWeight: '600',\n    color: '#333',\n  },\n  restrictionReason: {\n    fontSize: 12,\n    color: '#666',\n    marginTop: 2,\n  },\n  restrictionEndDate: {\n    fontSize: 12,\n    color: '#f44336',\n    marginTop: 2,\n  },\n  statsCard: {\n    backgroundColor: '#f8f9fa',\n    borderRadius: 12,\n    padding: 16,\n    marginBottom: 16,\n  },\n  statsTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n    marginBottom: 12,\n  },\n  statsGrid: {\n    flexDirection: 'row',\n    justifyContent: 'space-around',\n  },\n  statItem: {\n    alignItems: 'center',\n  },\n  statValue: {\n    fontSize: 20,\n    fontWeight: 'bold',\n    color: '#4285f4',\n  },\n  statLabel: {\n    fontSize: 12,\n    color: '#666',\n    marginTop: 4,\n  },\n  sectionTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 16,\n  },\n  reportItem: {\n    backgroundColor: '#fff',\n    borderRadius: 8,\n    padding: 16,\n    marginHorizontal: 16,\n    marginBottom: 8,\n    borderWidth: 1,\n    borderColor: '#f0f0f0',\n    shadowColor: '#000',\n    shadowOffset: { width: 0, height: 1 },\n    shadowOpacity: 0.1,\n    shadowRadius: 2,\n    elevation: 2,\n  },\n  reportHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: 8,\n  },\n  targetInfo: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  targetIcon: {\n    fontSize: 16,\n    marginRight: 8,\n  },\n  targetType: {\n    fontSize: 14,\n    color: '#666',\n  },\n  statusBadge: {\n    paddingHorizontal: 8,\n    paddingVertical: 4,\n    borderRadius: 12,\n  },\n  statusText: {\n    fontSize: 10,\n    color: '#fff',\n    fontWeight: '600',\n  },\n  reasonText: {\n    fontSize: 14,\n    color: '#333',\n    marginBottom: 4,\n  },\n  descriptionText: {\n    fontSize: 12,\n    color: '#666',\n    lineHeight: 16,\n    marginBottom: 8,\n  },\n  reportFooter: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n  },\n  dateText: {\n    fontSize: 12,\n    color: '#999',\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 32,\n  },\n  emptyList: {\n    flex: 1,\n  },\n  emptyTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#999',\n    marginTop: 16,\n    marginBottom: 8,\n  },\n  emptyDescription: {\n    fontSize: 14,\n    color: '#ccc',\n    textAlign: 'center',\n    lineHeight: 20,\n  },\n  errorContainer: {\n    backgroundColor: '#ffebee',\n    padding: 12,\n    borderTopWidth: 1,\n    borderTopColor: '#e0e0e0',\n  },\n  errorText: {\n    color: '#c62828',\n    fontSize: 14,\n    textAlign: 'center',\n  },\n});\n\nexport default ReportHistoryScreen;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/search/SearchScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'savedSearches' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":73,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'searchHistory' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":74,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'applySavedSearch' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":81,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'applyHistorySearch' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":82,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'showSavedSearches' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":89,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setShowSavedSearches' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":89,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'showHistory' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":90,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'setShowHistory' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":90,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":37},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":94,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":94,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2747,2800],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-catch-shadow","severity":1,"message":"Value of 'error' may be overwritten in IE 8 and earlier.","line":112,"column":17,"nodeType":"CatchClause","messageId":"mutable","endLine":114,"endColumn":16},{"ruleId":"@typescript-eslint/no-shadow","severity":1,"message":"'error' is already declared in the upper scope on line 71 column 5.","line":112,"column":24,"nodeType":"Identifier","messageId":"noShadow","endLine":112,"endColumn":29},{"ruleId":"react/no-unstable-nested-components","severity":1,"message":"Do not define components during render. React will see a new component type on every render and destroy the entire subtree’s DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component “SearchScreen” and pass data as props.","line":124,"column":23,"nodeType":"ArrowFunctionExpression","endLine":241,"endColumn":4}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  SafeAreaView,\n  TextInput,\n  TouchableOpacity,\n  FlatList,\n  Modal,\n  ScrollView,\n  Alert,\n} from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { ToiletLocation } from '../../types/maps';\nimport { SortOption } from '../../types/post';\nimport { useSearch } from '../../hooks/useSearch';\nimport { toiletTypeOptions } from '../../types/post';\n\ninterface ToiletListItemProps {\n  toilet: ToiletLocation;\n  onPress: (toilet: ToiletLocation) => void;\n}\n\nconst ToiletListItem: React.FC<ToiletListItemProps> = ({ toilet, onPress }) => {\n  const selectedType = toiletTypeOptions.find(option => option.value === toilet.type);\n\n  return (\n    <TouchableOpacity style={styles.toiletItem} onPress={() => onPress(toilet)} activeOpacity={0.7}>\n      <View style={styles.toiletContent}>\n        <View style={styles.toiletHeader}>\n          <Text style={styles.toiletTitle}>{toilet.title}</Text>\n          <View style={styles.typeContainer}>\n            <Text style={styles.typeIcon}>{selectedType?.icon || '🚽'}</Text>\n            <Text style={styles.typeLabel}>{selectedType?.label || 'その他'}</Text>\n          </View>\n        </View>\n\n        {toilet.description && (\n          <Text style={styles.toiletDescription} numberOfLines={2}>\n            {toilet.description}\n          </Text>\n        )}\n\n        <View style={styles.toiletMeta}>\n          <View style={styles.ratingContainer}>\n            <Icon name=\"star\" size={16} color=\"#FFD700\" />\n            <Text style={styles.ratingText}>{toilet.rating?.toFixed(1) || 'N/A'}</Text>\n            <Text style={styles.reviewCount}>({toilet.reviewCount || 0})</Text>\n          </View>\n\n          {toilet.isAccessible && (\n            <View style={styles.accessibleBadge}>\n              <Icon name=\"accessibility\" size={14} color=\"#4CAF50\" />\n              <Text style={styles.accessibleText}>バリアフリー</Text>\n            </View>\n          )}\n        </View>\n      </View>\n    </TouchableOpacity>\n  );\n};\n\nconst SearchScreen: React.FC = () => {\n  const {\n    results,\n    isSearching,\n    totalCount,\n    hasMore,\n    searchTime,\n    error,\n    filters,\n    savedSearches,\n    searchHistory,\n    updateFilters,\n    loadMore,\n    resetSearch,\n    clearFilters,\n    quickSearch,\n    saveFavoriteSearch,\n    applySavedSearch,\n    applyHistorySearch,\n    hasActiveFilters,\n    hasResults,\n    isEmpty,\n  } = useSearch();\n\n  const [showFilters, setShowFilters] = useState(false);\n  const [showSavedSearches, setShowSavedSearches] = useState(false);\n  const [showHistory, setShowHistory] = useState(false);\n\n  // トイレアイテムをタップ\n  const handleToiletPress = useCallback((toilet: ToiletLocation) => {\n    console.log('Navigate to toilet detail:', toilet.id);\n    // TODO: 実際のナビゲーション実装\n  }, []);\n\n  // 検索条件を保存\n  const handleSaveFavoriteSearch = useCallback(async () => {\n    Alert.prompt(\n      '検索条件を保存',\n      '保存する検索条件の名前を入力してください',\n      [\n        { text: 'キャンセル', style: 'cancel' },\n        {\n          text: '保存',\n          onPress: async (name?: string) => {\n            if (name?.trim()) {\n              try {\n                await saveFavoriteSearch(name.trim());\n                Alert.alert('保存完了', '検索条件を保存しました');\n              } catch (error) {\n                Alert.alert('エラー', '検索条件の保存に失敗しました');\n              }\n            }\n          },\n        },\n      ],\n      'plain-text',\n    );\n  }, [saveFavoriteSearch]);\n\n  // フィルターモーダル\n  const FilterModal = () => (\n    <Modal\n      visible={showFilters}\n      animationType=\"slide\"\n      presentationStyle=\"pageSheet\"\n      onRequestClose={() => setShowFilters(false)}\n    >\n      <SafeAreaView style={styles.modalContainer}>\n        <View style={styles.modalHeader}>\n          <TouchableOpacity onPress={() => setShowFilters(false)}>\n            <Icon name=\"close\" size={24} color=\"#333\" />\n          </TouchableOpacity>\n          <Text style={styles.modalTitle}>検索フィルター</Text>\n          <TouchableOpacity onPress={clearFilters}>\n            <Text style={styles.clearText}>クリア</Text>\n          </TouchableOpacity>\n        </View>\n\n        <ScrollView style={styles.modalContent}>\n          {/* ソート */}\n          <View style={styles.filterSection}>\n            <Text style={styles.filterTitle}>並び順</Text>\n            <View style={styles.sortOptions}>\n              {Object.values(SortOption).map(option => (\n                <TouchableOpacity\n                  key={option}\n                  style={[\n                    styles.sortOption,\n                    filters.sortBy === option && styles.selectedSortOption,\n                  ]}\n                  onPress={() => updateFilters({ sortBy: option })}\n                >\n                  <Text\n                    style={[\n                      styles.sortOptionText,\n                      filters.sortBy === option && styles.selectedSortOptionText,\n                    ]}\n                  >\n                    {getSortDisplayName(option)}\n                  </Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </View>\n\n          {/* トイレタイプ */}\n          <View style={styles.filterSection}>\n            <Text style={styles.filterTitle}>トイレタイプ</Text>\n            <View style={styles.typeOptions}>\n              <TouchableOpacity\n                style={[styles.typeOption, !filters.toiletType && styles.selectedTypeOption]}\n                onPress={() => updateFilters({ toiletType: undefined })}\n              >\n                <Text style={styles.typeOptionText}>すべて</Text>\n              </TouchableOpacity>\n              {toiletTypeOptions.map(option => (\n                <TouchableOpacity\n                  key={option.value}\n                  style={[\n                    styles.typeOption,\n                    filters.toiletType === option.value && styles.selectedTypeOption,\n                  ]}\n                  onPress={() => updateFilters({ toiletType: option.value })}\n                >\n                  <Text style={styles.typeIcon}>{option.icon}</Text>\n                  <Text style={styles.typeOptionText}>{option.label}</Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </View>\n\n          {/* その他のフィルター */}\n          <View style={styles.filterSection}>\n            <Text style={styles.filterTitle}>その他</Text>\n\n            <TouchableOpacity\n              style={[styles.filterToggle, filters.isAccessible && styles.activeFilterToggle]}\n              onPress={() =>\n                updateFilters({\n                  isAccessible: filters.isAccessible ? undefined : true,\n                })\n              }\n            >\n              <Icon name=\"accessibility\" size={20} color=\"#4CAF50\" />\n              <Text style={styles.filterToggleText}>バリアフリー対応</Text>\n              {filters.isAccessible && <Icon name=\"checkmark\" size={20} color=\"#4285f4\" />}\n            </TouchableOpacity>\n\n            <TouchableOpacity\n              style={[styles.filterToggle, filters.hasWashlet && styles.activeFilterToggle]}\n              onPress={() =>\n                updateFilters({\n                  hasWashlet: filters.hasWashlet ? undefined : true,\n                })\n              }\n            >\n              <Text style={styles.filterIcon}>🚿</Text>\n              <Text style={styles.filterToggleText}>ウォシュレット</Text>\n              {filters.hasWashlet && <Icon name=\"checkmark\" size={20} color=\"#4285f4\" />}\n            </TouchableOpacity>\n\n            <TouchableOpacity\n              style={[styles.filterToggle, filters.openNow && styles.activeFilterToggle]}\n              onPress={() =>\n                updateFilters({\n                  openNow: filters.openNow ? undefined : true,\n                })\n              }\n            >\n              <Icon name=\"time\" size={20} color=\"#FF9800\" />\n              <Text style={styles.filterToggleText}>現在営業中</Text>\n              {filters.openNow && <Icon name=\"checkmark\" size={20} color=\"#4285f4\" />}\n            </TouchableOpacity>\n          </View>\n        </ScrollView>\n      </SafeAreaView>\n    </Modal>\n  );\n\n  // 検索結果のレンダリング\n  const renderToiletItem = ({ item }: { item: ToiletLocation }) => (\n    <ToiletListItem toilet={item} onPress={handleToiletPress} />\n  );\n\n  // 空の状態\n  const renderEmptyState = () => {\n    if (isSearching) {\n      return (\n        <View style={styles.emptyContainer}>\n          <Text style={styles.emptyText}>検索中...</Text>\n        </View>\n      );\n    }\n\n    if (isEmpty) {\n      return (\n        <View style={styles.emptyContainer}>\n          <Icon name=\"search\" size={64} color=\"#ccc\" />\n          <Text style={styles.emptyTitle}>見つかりませんでした</Text>\n          <Text style={styles.emptyDescription}>検索条件を変更してもう一度お試しください</Text>\n        </View>\n      );\n    }\n\n    return (\n      <View style={styles.emptyContainer}>\n        <Icon name=\"search\" size={64} color=\"#ccc\" />\n        <Text style={styles.emptyTitle}>検索してください</Text>\n        <Text style={styles.emptyDescription}>キーワードを入力してトイレを検索できます</Text>\n\n        {/* クイック検索 */}\n        <View style={styles.quickSearchContainer}>\n          <Text style={styles.quickSearchTitle}>クイック検索</Text>\n          <View style={styles.quickSearchButtons}>\n            <TouchableOpacity\n              style={styles.quickSearchButton}\n              onPress={() => quickSearch('nearby')}\n            >\n              <Icon name=\"location\" size={20} color=\"#4285f4\" />\n              <Text style={styles.quickSearchText}>近くのトイレ</Text>\n            </TouchableOpacity>\n\n            <TouchableOpacity\n              style={styles.quickSearchButton}\n              onPress={() => quickSearch('accessible')}\n            >\n              <Icon name=\"accessibility\" size={20} color=\"#4CAF50\" />\n              <Text style={styles.quickSearchText}>バリアフリー</Text>\n            </TouchableOpacity>\n\n            <TouchableOpacity\n              style={styles.quickSearchButton}\n              onPress={() => quickSearch('highRated')}\n            >\n              <Icon name=\"star\" size={20} color=\"#FFD700\" />\n              <Text style={styles.quickSearchText}>高評価</Text>\n            </TouchableOpacity>\n\n            <TouchableOpacity\n              style={styles.quickSearchButton}\n              onPress={() => quickSearch('newest')}\n            >\n              <Icon name=\"time\" size={20} color=\"#FF9800\" />\n              <Text style={styles.quickSearchText}>新着</Text>\n            </TouchableOpacity>\n          </View>\n        </View>\n      </View>\n    );\n  };\n\n  return (\n    <SafeAreaView style={styles.container}>\n      {/* 検索バー */}\n      <View style={styles.searchBar}>\n        <View style={styles.searchInputContainer}>\n          <Icon name=\"search\" size={20} color=\"#666\" />\n          <TextInput\n            style={styles.searchInput}\n            placeholder=\"トイレを検索...\"\n            value={filters.query}\n            onChangeText={text => updateFilters({ query: text })}\n            autoCapitalize=\"none\"\n            autoCorrect={false}\n            returnKeyType=\"search\"\n          />\n          {filters.query.length > 0 && (\n            <TouchableOpacity onPress={() => updateFilters({ query: '' })}>\n              <Icon name=\"close-circle\" size={20} color=\"#999\" />\n            </TouchableOpacity>\n          )}\n        </View>\n\n        <TouchableOpacity\n          style={[styles.filterButton, hasActiveFilters && styles.activeFilterButton]}\n          onPress={() => setShowFilters(true)}\n        >\n          <Icon name=\"options\" size={20} color={hasActiveFilters ? '#fff' : '#666'} />\n        </TouchableOpacity>\n      </View>\n\n      {/* アクションバー */}\n      {(hasResults || filters.query.length > 0) && (\n        <View style={styles.actionBar}>\n          <View style={styles.resultInfo}>\n            {isSearching ? (\n              <Text style={styles.resultText}>検索中...</Text>\n            ) : (\n              <Text style={styles.resultText}>\n                {totalCount}件の結果 ({searchTime}ms)\n              </Text>\n            )}\n          </View>\n\n          <View style={styles.actionButtons}>\n            {hasActiveFilters && (\n              <TouchableOpacity style={styles.actionButton} onPress={handleSaveFavoriteSearch}>\n                <Icon name=\"heart-outline\" size={16} color=\"#4285f4\" />\n                <Text style={styles.actionButtonText}>保存</Text>\n              </TouchableOpacity>\n            )}\n\n            <TouchableOpacity style={styles.actionButton} onPress={resetSearch}>\n              <Icon name=\"refresh\" size={16} color=\"#666\" />\n              <Text style={styles.actionButtonText}>リセット</Text>\n            </TouchableOpacity>\n          </View>\n        </View>\n      )}\n\n      {/* 検索結果 */}\n      <FlatList\n        data={results}\n        renderItem={renderToiletItem}\n        keyExtractor={item => item.id}\n        ListEmptyComponent={renderEmptyState}\n        onEndReached={hasMore ? loadMore : undefined}\n        onEndReachedThreshold={0.1}\n        showsVerticalScrollIndicator={false}\n        contentContainerStyle={results.length === 0 ? styles.emptyList : undefined}\n      />\n\n      {/* エラー表示 */}\n      {error && (\n        <View style={styles.errorContainer}>\n          <Text style={styles.errorText}>{error}</Text>\n        </View>\n      )}\n\n      {/* フィルターモーダル */}\n      <FilterModal />\n    </SafeAreaView>\n  );\n};\n\n// ソート表示名\nconst getSortDisplayName = (sort: SortOption): string => {\n  const names = {\n    [SortOption.RELEVANCE]: '関連度',\n    [SortOption.DISTANCE]: '距離',\n    [SortOption.RATING]: '評価',\n    [SortOption.NEWEST]: '新しい順',\n    [SortOption.HELPFUL]: '役に立った順',\n  };\n  return names[sort];\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  searchBar: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  searchInputContainer: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: '#f5f5f5',\n    borderRadius: 25,\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n    marginRight: 12,\n  },\n  searchInput: {\n    flex: 1,\n    fontSize: 16,\n    marginLeft: 8,\n    color: '#333',\n  },\n  filterButton: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    backgroundColor: '#f5f5f5',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  activeFilterButton: {\n    backgroundColor: '#4285f4',\n  },\n  actionBar: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 8,\n    backgroundColor: '#f8f9fa',\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  resultInfo: {\n    flex: 1,\n  },\n  resultText: {\n    fontSize: 14,\n    color: '#666',\n  },\n  actionButtons: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  actionButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 8,\n    paddingVertical: 4,\n    marginLeft: 8,\n  },\n  actionButtonText: {\n    fontSize: 12,\n    color: '#4285f4',\n    marginLeft: 4,\n  },\n  toiletItem: {\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n    backgroundColor: '#fff',\n  },\n  toiletContent: {\n    flex: 1,\n  },\n  toiletHeader: {\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    justifyContent: 'space-between',\n    marginBottom: 4,\n  },\n  toiletTitle: {\n    flex: 1,\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n  },\n  typeContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginLeft: 8,\n  },\n  typeIcon: {\n    fontSize: 16,\n    marginRight: 4,\n  },\n  typeLabel: {\n    fontSize: 12,\n    color: '#666',\n  },\n  toiletDescription: {\n    fontSize: 14,\n    color: '#666',\n    lineHeight: 20,\n    marginBottom: 8,\n  },\n  toiletMeta: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  ratingContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginRight: 12,\n  },\n  ratingText: {\n    fontSize: 14,\n    fontWeight: '600',\n    color: '#333',\n    marginLeft: 4,\n  },\n  reviewCount: {\n    fontSize: 12,\n    color: '#999',\n    marginLeft: 2,\n  },\n  accessibleBadge: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: '#e8f5e8',\n    paddingHorizontal: 6,\n    paddingVertical: 2,\n    borderRadius: 10,\n  },\n  accessibleText: {\n    fontSize: 10,\n    color: '#4CAF50',\n    marginLeft: 2,\n    fontWeight: '600',\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingHorizontal: 32,\n  },\n  emptyList: {\n    flex: 1,\n  },\n  emptyTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#999',\n    marginTop: 16,\n    marginBottom: 8,\n  },\n  emptyDescription: {\n    fontSize: 14,\n    color: '#ccc',\n    textAlign: 'center',\n    lineHeight: 20,\n    marginBottom: 32,\n  },\n  emptyText: {\n    fontSize: 16,\n    color: '#666',\n  },\n  quickSearchContainer: {\n    alignItems: 'center',\n  },\n  quickSearchTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n    marginBottom: 16,\n  },\n  quickSearchButtons: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    justifyContent: 'center',\n    gap: 12,\n  },\n  quickSearchButton: {\n    alignItems: 'center',\n    paddingVertical: 12,\n    paddingHorizontal: 16,\n    borderRadius: 8,\n    borderWidth: 1,\n    borderColor: '#e0e0e0',\n    backgroundColor: '#fff',\n    minWidth: 80,\n  },\n  quickSearchText: {\n    fontSize: 12,\n    color: '#333',\n    marginTop: 4,\n    textAlign: 'center',\n  },\n  errorContainer: {\n    backgroundColor: '#ffebee',\n    padding: 12,\n    borderTopWidth: 1,\n    borderTopColor: '#e0e0e0',\n  },\n  errorText: {\n    color: '#c62828',\n    fontSize: 14,\n    textAlign: 'center',\n  },\n  modalContainer: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  modalHeader: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  modalTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n  },\n  clearText: {\n    fontSize: 16,\n    color: '#4285f4',\n    fontWeight: '600',\n  },\n  modalContent: {\n    flex: 1,\n    padding: 16,\n  },\n  filterSection: {\n    marginBottom: 24,\n  },\n  filterTitle: {\n    fontSize: 16,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 12,\n  },\n  sortOptions: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: 8,\n  },\n  sortOption: {\n    paddingHorizontal: 12,\n    paddingVertical: 8,\n    borderRadius: 16,\n    borderWidth: 1,\n    borderColor: '#e0e0e0',\n    backgroundColor: '#fff',\n  },\n  selectedSortOption: {\n    backgroundColor: '#4285f4',\n    borderColor: '#4285f4',\n  },\n  sortOptionText: {\n    fontSize: 14,\n    color: '#333',\n  },\n  selectedSortOptionText: {\n    color: '#fff',\n  },\n  typeOptions: {\n    gap: 8,\n  },\n  typeOption: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingHorizontal: 12,\n    paddingVertical: 8,\n    borderRadius: 8,\n    borderWidth: 1,\n    borderColor: '#e0e0e0',\n    backgroundColor: '#fff',\n  },\n  selectedTypeOption: {\n    backgroundColor: '#e3f2fd',\n    borderColor: '#4285f4',\n  },\n  typeOptionText: {\n    fontSize: 14,\n    color: '#333',\n    marginLeft: 8,\n  },\n  filterToggle: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: 12,\n    paddingHorizontal: 12,\n    borderRadius: 8,\n    borderWidth: 1,\n    borderColor: '#e0e0e0',\n    backgroundColor: '#fff',\n    marginBottom: 8,\n  },\n  activeFilterToggle: {\n    backgroundColor: '#e3f2fd',\n    borderColor: '#4285f4',\n  },\n  filterIcon: {\n    fontSize: 20,\n    marginRight: 12,\n  },\n  filterToggleText: {\n    flex: 1,\n    fontSize: 14,\n    color: '#333',\n    marginLeft: 8,\n  },\n});\n\nexport default SearchScreen;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/settings/NotificationSettingsScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/settings/SettingsScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/screens/toilet/ToiletDetailScreen.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getToiletIcon' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getToiletTypeColor' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StarRating' is defined but never used. Allowed unused vars must match /^_/u.","line":22,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":18},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":277,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":277,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9572,9599],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":288,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":288,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9919,9946],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":299,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":299,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10268,10297],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"react-native/no-inline-styles","severity":1,"message":"Inline style: { color: '#f44336' }","line":303,"column":52,"nodeType":"ObjectExpression","endLine":303,"endColumn":72}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useEffect } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  ScrollView,\n  TouchableOpacity,\n  Image,\n  Alert,\n  SafeAreaView,\n  Dimensions,\n  Share,\n} from 'react-native';\nimport Icon from 'react-native-vector-icons/Ionicons';\nimport { RouteProp } from '@react-navigation/native';\nimport { StackNavigationProp } from '@react-navigation/stack';\nimport { ToiletLocation } from '../../types/maps';\nimport { firestoreService } from '../../services/firestoreService';\nimport { getToiletIcon, getToiletTypeColor } from '../../utils/mapUtils';\nimport { toiletTypeOptions, facilityLabels, facilityIcons } from '../../types/post';\nimport HelpfulVoting from '../../components/post/HelpfulVoting';\nimport StarRating from '../../components/common/StarRating';\n\ntype RootStackParamList = {\n  ToiletDetail: { toiletId: string };\n};\n\ntype ToiletDetailScreenRouteProp = RouteProp<RootStackParamList, 'ToiletDetail'>;\ntype ToiletDetailScreenNavigationProp = StackNavigationProp<RootStackParamList, 'ToiletDetail'>;\n\ninterface Props {\n  route: ToiletDetailScreenRouteProp;\n  navigation: ToiletDetailScreenNavigationProp;\n}\n\nconst { width: screenWidth } = Dimensions.get('window');\n\nconst ToiletDetailScreen: React.FC<Props> = ({ route, navigation }) => {\n  const { toiletId } = route.params;\n  const [toilet, setToilet] = useState<ToiletLocation | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [selectedImageIndex, setSelectedImageIndex] = useState(0);\n\n  // トイレ詳細データの読み込み\n  const loadToiletDetail = useCallback(async () => {\n    setIsLoading(true);\n    try {\n      const toiletData = await firestoreService.getToilet(toiletId);\n      setToilet(toiletData);\n    } catch (error) {\n      console.error('Failed to load toilet detail:', error);\n      Alert.alert('エラー', 'トイレ情報の読み込みに失敗しました');\n      navigation.goBack();\n    } finally {\n      setIsLoading(false);\n    }\n  }, [toiletId, navigation]);\n\n  // シェア機能\n  const handleShare = useCallback(async () => {\n    if (!toilet) return;\n\n    try {\n      await Share.share({\n        message: `${toilet.title}\\n${toilet.description}\\n\\n#yotas #トイレ情報`,\n        title: toilet.title,\n      });\n    } catch (error) {\n      console.error('Share error:', error);\n    }\n  }, [toilet]);\n\n  // 初期データ読み込み\n  useEffect(() => {\n    loadToiletDetail();\n  }, [loadToiletDetail]);\n\n  const selectedToiletType = toiletTypeOptions.find(option => option.value === toilet?.type);\n\n  if (isLoading) {\n    return (\n      <SafeAreaView style={styles.container}>\n        <View style={styles.loadingContainer}>\n          <Text>読み込み中...</Text>\n        </View>\n      </SafeAreaView>\n    );\n  }\n\n  if (!toilet) {\n    return (\n      <SafeAreaView style={styles.container}>\n        <View style={styles.errorContainer}>\n          <Text>トイレ情報が見つかりません</Text>\n          <TouchableOpacity style={styles.backButton} onPress={() => navigation.goBack()}>\n            <Text style={styles.backButtonText}>戻る</Text>\n          </TouchableOpacity>\n        </View>\n      </SafeAreaView>\n    );\n  }\n\n  return (\n    <SafeAreaView style={styles.container}>\n      {/* ヘッダー */}\n      <View style={styles.header}>\n        <TouchableOpacity style={styles.headerButton} onPress={() => navigation.goBack()}>\n          <Icon name=\"arrow-back\" size={24} color=\"#333\" />\n        </TouchableOpacity>\n        <Text style={styles.headerTitle} numberOfLines={1}>\n          {toilet.title}\n        </Text>\n        <TouchableOpacity style={styles.headerButton} onPress={handleShare}>\n          <Icon name=\"share-outline\" size={24} color=\"#333\" />\n        </TouchableOpacity>\n      </View>\n\n      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>\n        {/* 画像ギャラリー */}\n        {toilet.images && toilet.images.length > 0 && (\n          <View style={styles.imageSection}>\n            <ScrollView\n              horizontal\n              pagingEnabled\n              showsHorizontalScrollIndicator={false}\n              onMomentumScrollEnd={event => {\n                const index = Math.round(event.nativeEvent.contentOffset.x / screenWidth);\n                setSelectedImageIndex(index);\n              }}\n            >\n              {toilet.images.map((imageUrl, index) => (\n                <Image\n                  key={index}\n                  source={{ uri: imageUrl }}\n                  style={styles.image}\n                  resizeMode=\"cover\"\n                />\n              ))}\n            </ScrollView>\n            {toilet.images.length > 1 && (\n              <View style={styles.imageIndicator}>\n                {toilet.images.map((_, index) => (\n                  <View\n                    key={index}\n                    style={[\n                      styles.indicator,\n                      selectedImageIndex === index && styles.activeIndicator,\n                    ]}\n                  />\n                ))}\n              </View>\n            )}\n          </View>\n        )}\n\n        {/* 基本情報 */}\n        <View style={styles.section}>\n          <View style={styles.titleRow}>\n            <View style={styles.titleContainer}>\n              <Text style={styles.title}>{toilet.title}</Text>\n              <View style={styles.typeContainer}>\n                <Text style={styles.typeIcon}>{selectedToiletType?.icon || '🚽'}</Text>\n                <Text style={styles.typeLabel}>{selectedToiletType?.label || 'その他'}</Text>\n              </View>\n            </View>\n            {toilet.isAccessible && (\n              <View style={styles.accessibleBadge}>\n                <Icon name=\"accessibility\" size={16} color=\"#4CAF50\" />\n                <Text style={styles.accessibleText}>バリアフリー</Text>\n              </View>\n            )}\n          </View>\n\n          {toilet.description && <Text style={styles.description}>{toilet.description}</Text>}\n\n          {/* 評価 */}\n          <View style={styles.ratingContainer}>\n            <View style={styles.ratingRow}>\n              <Text style={styles.ratingLabel}>総合評価</Text>\n              <View style={styles.ratingValue}>\n                <Text style={styles.ratingNumber}>{toilet.rating?.toFixed(1) || 'N/A'}</Text>\n                <View style={styles.stars}>\n                  {[1, 2, 3, 4, 5].map(star => (\n                    <Icon\n                      key={star}\n                      name=\"star\"\n                      size={16}\n                      color={star <= Math.round(toilet.rating || 0) ? '#FFD700' : '#E0E0E0'}\n                    />\n                  ))}\n                </View>\n                <Text style={styles.reviewCount}>({toilet.reviewCount}件)</Text>\n              </View>\n            </View>\n          </View>\n\n          {/* 位置情報 */}\n          <View style={styles.locationContainer}>\n            <Icon name=\"location\" size={16} color=\"#666\" />\n            <Text style={styles.locationText}>\n              {toilet.latitude.toFixed(6)}, {toilet.longitude.toFixed(6)}\n            </Text>\n          </View>\n        </View>\n\n        {/* 「役に立った」投票 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>この情報は役に立ちましたか？</Text>\n          <HelpfulVoting toiletId={toilet.id} size=\"large\" showStats={true} showText={true} />\n        </View>\n\n        {/* 設備情報 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>設備情報</Text>\n          <View style={styles.facilitiesGrid}>\n            {Object.entries(facilityLabels).map(([key, label]) => {\n              const hasFeature = toilet.facilities?.[key as keyof typeof toilet.facilities];\n              return (\n                <View\n                  key={key}\n                  style={[\n                    styles.facilityItem,\n                    hasFeature ? styles.facilityAvailable : styles.facilityUnavailable,\n                  ]}\n                >\n                  <Text style={styles.facilityIcon}>\n                    {facilityIcons[key as keyof typeof facilityIcons]}\n                  </Text>\n                  <Text\n                    style={[\n                      styles.facilityLabel,\n                      hasFeature ? styles.facilityLabelAvailable : styles.facilityLabelUnavailable,\n                    ]}\n                  >\n                    {label}\n                  </Text>\n                  <Icon\n                    name={hasFeature ? 'checkmark-circle' : 'close-circle'}\n                    size={16}\n                    color={hasFeature ? '#4CAF50' : '#999'}\n                  />\n                </View>\n              );\n            })}\n          </View>\n        </View>\n\n        {/* 営業時間 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>営業時間</Text>\n          {toilet.openingHours?.is24Hours ? (\n            <Text style={styles.openingHours}>24時間利用可能</Text>\n          ) : (\n            <Text style={styles.openingHours}>\n              {toilet.openingHours?.openTime || '不明'} - {toilet.openingHours?.closeTime || '不明'}\n            </Text>\n          )}\n          {toilet.openingHours?.notes && (\n            <Text style={styles.openingNotes}>{toilet.openingHours.notes}</Text>\n          )}\n        </View>\n\n        {/* 追加情報 */}\n        {toilet.additionalInfo && (\n          <View style={styles.section}>\n            <Text style={styles.sectionTitle}>追加情報</Text>\n            <Text style={styles.additionalInfo}>{toilet.additionalInfo}</Text>\n          </View>\n        )}\n\n        {/* アクションボタン */}\n        <View style={styles.actionSection}>\n          <TouchableOpacity\n            style={styles.actionButton}\n            onPress={() => {\n              // TODO: 地図で表示\n              console.log('Show on map');\n            }}\n          >\n            <Icon name=\"map\" size={20} color=\"#4285f4\" />\n            <Text style={styles.actionButtonText}>地図で表示</Text>\n          </TouchableOpacity>\n\n          <TouchableOpacity\n            style={styles.actionButton}\n            onPress={() => {\n              // TODO: 編集画面へ\n              console.log('Edit toilet');\n            }}\n          >\n            <Icon name=\"create\" size={20} color=\"#4285f4\" />\n            <Text style={styles.actionButtonText}>情報を編集</Text>\n          </TouchableOpacity>\n\n          <TouchableOpacity\n            style={styles.actionButton}\n            onPress={() => {\n              // TODO: 通報機能\n              console.log('Report toilet');\n            }}\n          >\n            <Icon name=\"flag\" size={20} color=\"#f44336\" />\n            <Text style={[styles.actionButtonText, { color: '#f44336' }]}>通報</Text>\n          </TouchableOpacity>\n        </View>\n\n        {/* 投稿者情報 */}\n        <View style={styles.section}>\n          <Text style={styles.sectionTitle}>投稿情報</Text>\n          <Text style={styles.createdInfo}>\n            投稿日: {toilet.createdAt?.toLocaleDateString() || '不明'}\n          </Text>\n          {toilet.updatedAt && toilet.updatedAt !== toilet.createdAt && (\n            <Text style={styles.updatedInfo}>更新日: {toilet.updatedAt.toLocaleDateString()}</Text>\n          )}\n        </View>\n\n        {/* 底部スペース */}\n        <View style={styles.bottomSpace} />\n      </ScrollView>\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n  },\n  loadingContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  errorContainer: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    padding: 20,\n  },\n  backButton: {\n    marginTop: 20,\n    backgroundColor: '#4285f4',\n    paddingHorizontal: 20,\n    paddingVertical: 10,\n    borderRadius: 6,\n  },\n  backButtonText: {\n    color: '#fff',\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  header: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    paddingHorizontal: 16,\n    paddingVertical: 12,\n    borderBottomWidth: 1,\n    borderBottomColor: '#e0e0e0',\n  },\n  headerButton: {\n    width: 40,\n    height: 40,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  headerTitle: {\n    flex: 1,\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n    textAlign: 'center',\n    marginHorizontal: 8,\n  },\n  content: {\n    flex: 1,\n  },\n  imageSection: {\n    position: 'relative',\n  },\n  image: {\n    width: screenWidth,\n    height: 250,\n  },\n  imageIndicator: {\n    position: 'absolute',\n    bottom: 16,\n    left: 0,\n    right: 0,\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  indicator: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n    backgroundColor: 'rgba(255, 255, 255, 0.5)',\n    marginHorizontal: 4,\n  },\n  activeIndicator: {\n    backgroundColor: '#fff',\n  },\n  section: {\n    padding: 16,\n    borderBottomWidth: 1,\n    borderBottomColor: '#f0f0f0',\n  },\n  titleRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'flex-start',\n    marginBottom: 8,\n  },\n  titleContainer: {\n    flex: 1,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 8,\n  },\n  typeContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  typeIcon: {\n    fontSize: 18,\n    marginRight: 6,\n  },\n  typeLabel: {\n    fontSize: 14,\n    color: '#666',\n  },\n  accessibleBadge: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: '#e8f5e8',\n    paddingHorizontal: 8,\n    paddingVertical: 4,\n    borderRadius: 12,\n    marginLeft: 8,\n  },\n  accessibleText: {\n    fontSize: 12,\n    color: '#4CAF50',\n    marginLeft: 4,\n    fontWeight: '600',\n  },\n  description: {\n    fontSize: 16,\n    color: '#333',\n    lineHeight: 24,\n    marginBottom: 16,\n  },\n  ratingContainer: {\n    marginBottom: 12,\n  },\n  ratingRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n  },\n  ratingLabel: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: '#333',\n  },\n  ratingValue: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  ratingNumber: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n    marginRight: 8,\n  },\n  stars: {\n    flexDirection: 'row',\n    marginRight: 8,\n  },\n  reviewCount: {\n    fontSize: 14,\n    color: '#666',\n  },\n  locationContainer: {\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n  locationText: {\n    fontSize: 14,\n    color: '#666',\n    marginLeft: 4,\n  },\n  sectionTitle: {\n    fontSize: 18,\n    fontWeight: 'bold',\n    color: '#333',\n    marginBottom: 12,\n  },\n  facilitiesGrid: {\n    gap: 8,\n  },\n  facilityItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: 8,\n    paddingHorizontal: 12,\n    borderRadius: 8,\n  },\n  facilityAvailable: {\n    backgroundColor: '#e8f5e8',\n  },\n  facilityUnavailable: {\n    backgroundColor: '#f5f5f5',\n  },\n  facilityIcon: {\n    fontSize: 18,\n    marginRight: 8,\n  },\n  facilityLabel: {\n    flex: 1,\n    fontSize: 14,\n  },\n  facilityLabelAvailable: {\n    color: '#333',\n  },\n  facilityLabelUnavailable: {\n    color: '#999',\n  },\n  openingHours: {\n    fontSize: 16,\n    color: '#333',\n    marginBottom: 4,\n  },\n  openingNotes: {\n    fontSize: 14,\n    color: '#666',\n  },\n  additionalInfo: {\n    fontSize: 16,\n    color: '#333',\n    lineHeight: 24,\n  },\n  actionSection: {\n    padding: 16,\n    gap: 12,\n  },\n  actionButton: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingVertical: 12,\n    paddingHorizontal: 16,\n    borderRadius: 8,\n    borderWidth: 1,\n    borderColor: '#e0e0e0',\n    backgroundColor: '#fff',\n  },\n  actionButtonText: {\n    fontSize: 16,\n    color: '#4285f4',\n    marginLeft: 8,\n    fontWeight: '500',\n  },\n  createdInfo: {\n    fontSize: 14,\n    color: '#666',\n    marginBottom: 4,\n  },\n  updatedInfo: {\n    fontSize: 14,\n    color: '#666',\n  },\n  bottomSpace: {\n    height: 20,\n  },\n});\n\nexport default ToiletDetailScreen;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/__tests__/historyService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":163,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4291,4294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4291,4294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":227,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6151,6154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6151,6154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":505,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":505,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14031,14034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14031,14034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { HistoryService } from '../historyService';\nimport { ActivityType } from '../../types/post';\nimport { ToiletType } from '../../types/maps';\n\n// Firebase mock\nconst mockFirestore = {\n  collection: jest.fn(() => ({\n    doc: jest.fn(() => ({\n      id: 'mock-doc-id',\n      ref: {\n        update: jest.fn(() => Promise.resolve()),\n      },\n      set: jest.fn(() => Promise.resolve()),\n      get: jest.fn(() =>\n        Promise.resolve({\n          exists: false,\n          data: () => null,\n        }),\n      ),\n      update: jest.fn(() => Promise.resolve()),\n    })),\n    add: jest.fn(() => Promise.resolve({ id: 'mock-id' })),\n    where: jest.fn(() => ({\n      get: jest.fn(() =>\n        Promise.resolve({\n          empty: true,\n          docs: [],\n          forEach: jest.fn(),\n        }),\n      ),\n      where: jest.fn(() => ({\n        get: jest.fn(() =>\n          Promise.resolve({\n            empty: true,\n            docs: [],\n            forEach: jest.fn(),\n          }),\n        ),\n      })),\n      orderBy: jest.fn(() => ({\n        limit: jest.fn(() => ({\n          get: jest.fn(() =>\n            Promise.resolve({\n              empty: true,\n              docs: [],\n              forEach: jest.fn(),\n            }),\n          ),\n        })),\n        offset: jest.fn(() => ({\n          get: jest.fn(() =>\n            Promise.resolve({\n              empty: true,\n              docs: [],\n              forEach: jest.fn(),\n            }),\n          ),\n        })),\n        desc: jest.fn(() => ({\n          limit: jest.fn(() => ({\n            get: jest.fn(() =>\n              Promise.resolve({\n                empty: true,\n                docs: [],\n                forEach: jest.fn(),\n              }),\n            ),\n          })),\n        })),\n      })),\n    })),\n  })),\n  Timestamp: {\n    now: jest.fn(() => ({ toDate: () => new Date() })),\n    fromDate: jest.fn(date => ({ toDate: () => date })),\n  },\n  batch: jest.fn(() => ({\n    delete: jest.fn(),\n    commit: jest.fn(() => Promise.resolve()),\n  })),\n};\n\njest.mock('@react-native-firebase/firestore', () => ({\n  __esModule: true,\n  default: jest.fn(() => mockFirestore),\n}));\n\ndescribe('HistoryService', () => {\n  let historyService: HistoryService;\n\n  beforeEach(() => {\n    historyService = new HistoryService();\n    jest.clearAllMocks();\n  });\n\n  describe('recordView', () => {\n    const mockToilet = {\n      id: 'toilet-123',\n      title: 'Test Toilet',\n      type: ToiletType.PUBLIC,\n      coordinates: { latitude: 35.6762, longitude: 139.6503 },\n      description: 'Test description',\n      rating: 4.5,\n      reviewCount: 10,\n      isAccessible: true,\n      facilities: {\n        hasWashlet: true,\n        hasHandDryer: false,\n        hasBabyChanging: false,\n        hasMultiPurpose: false,\n        hasPaperTowels: true,\n        hasHandSoap: true,\n        hasVendingMachine: false,\n      },\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      authorId: 'author-123',\n    };\n\n    it('should create new view history when no existing history', async () => {\n      const userId = 'user-123';\n\n      await historyService.recordView(userId, mockToilet);\n\n      expect(mockFirestore.collection).toHaveBeenCalledWith('view_history');\n      expect(mockFirestore.collection().add).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId,\n          toiletId: mockToilet.id,\n          toiletTitle: mockToilet.title,\n          toiletType: mockToilet.type,\n          viewCount: 1,\n        }),\n      );\n    });\n\n    it('should update existing view history when record exists', async () => {\n      const userId = 'user-123';\n      const existingDoc = {\n        data: () => ({ viewCount: 2 }),\n        ref: { update: jest.fn(() => Promise.resolve()) },\n      };\n\n      mockFirestore\n        .collection()\n        .where()\n        .where()\n        .get.mockResolvedValueOnce({\n          empty: false,\n          docs: [existingDoc],\n        });\n\n      await historyService.recordView(userId, mockToilet);\n\n      expect(existingDoc.ref.update).toHaveBeenCalledWith({\n        viewedAt: expect.any(Object),\n        viewCount: 3,\n      });\n    });\n\n    it('should update user stats after recording view', async () => {\n      const userId = 'user-123';\n      const updateUserStatsSpy = jest.spyOn(historyService as any, 'updateUserStats');\n      updateUserStatsSpy.mockResolvedValue(undefined);\n\n      await historyService.recordView(userId, mockToilet);\n\n      expect(updateUserStatsSpy).toHaveBeenCalledWith(userId, { totalViews: 1 });\n    });\n\n    it('should clean up old history records', async () => {\n      const userId = 'user-123';\n      const oldDocs = [{ ref: { delete: jest.fn() } }, { ref: { delete: jest.fn() } }];\n\n      mockFirestore.collection().where().orderBy().offset().get.mockResolvedValueOnce({\n        empty: false,\n        docs: oldDocs,\n      });\n\n      const mockBatch = {\n        delete: jest.fn(),\n        commit: jest.fn(() => Promise.resolve()),\n      };\n      mockFirestore.batch.mockReturnValue(mockBatch);\n\n      await historyService.recordView(userId, mockToilet);\n\n      expect(mockBatch.delete).toHaveBeenCalledTimes(2);\n      expect(mockBatch.commit).toHaveBeenCalled();\n    });\n  });\n\n  describe('getViewHistory', () => {\n    it('should retrieve view history for user', async () => {\n      const userId = 'user-123';\n      const mockDocs = [\n        {\n          id: 'history-1',\n          data: () => ({\n            userId,\n            toiletId: 'toilet-1',\n            toiletTitle: 'Toilet 1',\n            toiletType: ToiletType.PUBLIC,\n            viewedAt: { toDate: () => new Date('2024-01-01') },\n            viewCount: 3,\n          }),\n        },\n        {\n          id: 'history-2',\n          data: () => ({\n            userId,\n            toiletId: 'toilet-2',\n            toiletTitle: 'Toilet 2',\n            toiletType: ToiletType.STATION,\n            viewedAt: { toDate: () => new Date('2024-01-02') },\n            viewCount: 1,\n          }),\n        },\n      ];\n\n      mockFirestore\n        .collection()\n        .where()\n        .orderBy()\n        .limit()\n        .get.mockResolvedValueOnce({\n          forEach: (callback: any) => mockDocs.forEach(callback),\n        });\n\n      const history = await historyService.getViewHistory(userId, 10);\n\n      expect(history).toHaveLength(2);\n      expect(history[0].toiletTitle).toBe('Toilet 1');\n      expect(history[0].viewCount).toBe(3);\n      expect(history[1].toiletTitle).toBe('Toilet 2');\n    });\n\n    it('should return empty array on error', async () => {\n      const userId = 'user-123';\n      mockFirestore\n        .collection()\n        .where()\n        .orderBy()\n        .limit()\n        .get.mockRejectedValue(new Error('Database error'));\n\n      const history = await historyService.getViewHistory(userId);\n      expect(history).toEqual([]);\n    });\n  });\n\n  describe('addToFavorites', () => {\n    const mockToilet = {\n      id: 'toilet-123',\n      title: 'Test Toilet',\n      type: ToiletType.PUBLIC,\n      coordinates: { latitude: 35.6762, longitude: 139.6503 },\n      description: 'Test description',\n      rating: 4.5,\n      reviewCount: 10,\n      isAccessible: true,\n      facilities: {\n        hasWashlet: true,\n        hasHandDryer: false,\n        hasBabyChanging: false,\n        hasMultiPurpose: false,\n        hasPaperTowels: true,\n        hasHandSoap: true,\n        hasVendingMachine: false,\n      },\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      authorId: 'author-123',\n    };\n\n    it('should add toilet to favorites successfully', async () => {\n      const userId = 'user-123';\n\n      await historyService.addToFavorites(userId, mockToilet);\n\n      expect(mockFirestore.collection().add).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId,\n          toiletId: mockToilet.id,\n          toiletTitle: mockToilet.title,\n          toiletType: mockToilet.type,\n        }),\n      );\n    });\n\n    it('should reject duplicate favorites', async () => {\n      const userId = 'user-123';\n\n      mockFirestore\n        .collection()\n        .where()\n        .where()\n        .get.mockResolvedValueOnce({\n          empty: false,\n          docs: [{ id: 'existing-favorite' }],\n        });\n\n      await expect(historyService.addToFavorites(userId, mockToilet)).rejects.toThrow(\n        '既にお気に入りに追加されています',\n      );\n    });\n\n    it('should record activity when adding to favorites', async () => {\n      const userId = 'user-123';\n      const recordActivitySpy = jest.spyOn(historyService, 'recordActivity');\n      recordActivitySpy.mockResolvedValue(undefined);\n\n      await historyService.addToFavorites(userId, mockToilet);\n\n      expect(recordActivitySpy).toHaveBeenCalledWith(\n        userId,\n        ActivityType.FAVORITE_ADDED,\n        mockToilet.id,\n        mockToilet.title,\n        `「${mockToilet.title}」をお気に入りに追加しました`,\n      );\n    });\n  });\n\n  describe('getUserStats', () => {\n    it('should return existing user stats', async () => {\n      const userId = 'user-123';\n      const mockStats = {\n        userId,\n        totalPosts: 5,\n        totalViews: 100,\n        totalFavorites: 10,\n        totalHelpfulVotes: 25,\n        totalBadges: 3,\n        joinedAt: { toDate: () => new Date('2024-01-01') },\n        lastActiveAt: { toDate: () => new Date('2024-01-15') },\n        streak: 7,\n      };\n\n      mockFirestore\n        .collection()\n        .doc()\n        .get.mockResolvedValueOnce({\n          exists: true,\n          data: () => mockStats,\n        });\n\n      const stats = await historyService.getUserStats(userId);\n\n      expect(stats.totalPosts).toBe(5);\n      expect(stats.totalViews).toBe(100);\n      expect(stats.streak).toBe(7);\n    });\n\n    it('should create initial stats for new user', async () => {\n      const userId = 'user-123';\n\n      mockFirestore.collection().doc().get.mockResolvedValueOnce({\n        exists: false,\n      });\n\n      const stats = await historyService.getUserStats(userId);\n\n      expect(stats.totalPosts).toBe(0);\n      expect(stats.totalViews).toBe(0);\n      expect(stats.totalFavorites).toBe(0);\n      expect(mockFirestore.collection().doc().set).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId,\n          totalPosts: 0,\n          totalViews: 0,\n          totalFavorites: 0,\n        }),\n      );\n    });\n  });\n\n  describe('updateUserStats', () => {\n    it('should update user stats correctly', async () => {\n      const userId = 'user-123';\n      const currentStats = {\n        userId,\n        totalPosts: 5,\n        totalViews: 100,\n        totalFavorites: 10,\n        totalHelpfulVotes: 25,\n        totalBadges: 3,\n        joinedAt: new Date('2024-01-01'),\n        lastActiveAt: new Date('2024-01-15'),\n        streak: 7,\n      };\n\n      jest.spyOn(historyService, 'getUserStats').mockResolvedValue(currentStats);\n\n      await historyService.updateUserStats(userId, {\n        totalPosts: 1,\n        totalViews: 5,\n      });\n\n      expect(mockFirestore.collection().doc().update).toHaveBeenCalledWith({\n        totalPosts: 6, // 5 + 1\n        totalViews: 105, // 100 + 5\n        totalFavorites: 10, // unchanged\n        totalHelpfulVotes: 25, // unchanged\n        totalBadges: 3, // unchanged\n        lastActiveAt: expect.any(Object),\n      });\n    });\n\n    it('should not allow negative values', async () => {\n      const userId = 'user-123';\n      const currentStats = {\n        userId,\n        totalPosts: 2,\n        totalViews: 5,\n        totalFavorites: 1,\n        totalHelpfulVotes: 0,\n        totalBadges: 0,\n        joinedAt: new Date('2024-01-01'),\n        lastActiveAt: new Date('2024-01-15'),\n        streak: 0,\n      };\n\n      jest.spyOn(historyService, 'getUserStats').mockResolvedValue(currentStats);\n\n      await historyService.updateUserStats(userId, {\n        totalPosts: -5, // Should result in 0\n        totalFavorites: -2, // Should result in 0\n      });\n\n      expect(mockFirestore.collection().doc().update).toHaveBeenCalledWith(\n        expect.objectContaining({\n          totalPosts: 0,\n          totalFavorites: 0,\n        }),\n      );\n    });\n  });\n\n  describe('clearViewHistory', () => {\n    it('should clear all view history for user', async () => {\n      const userId = 'user-123';\n      const mockDocs = [{ ref: { delete: jest.fn() } }, { ref: { delete: jest.fn() } }];\n\n      mockFirestore.collection().where().get.mockResolvedValueOnce({\n        docs: mockDocs,\n      });\n\n      const mockBatch = {\n        delete: jest.fn(),\n        commit: jest.fn(() => Promise.resolve()),\n      };\n      mockFirestore.batch.mockReturnValue(mockBatch);\n\n      await historyService.clearViewHistory(userId);\n\n      expect(mockBatch.delete).toHaveBeenCalledTimes(2);\n      expect(mockBatch.commit).toHaveBeenCalled();\n    });\n\n    it('should throw error when clearing fails', async () => {\n      const userId = 'user-123';\n      mockFirestore.collection().where().get.mockRejectedValue(new Error('Database error'));\n\n      await expect(historyService.clearViewHistory(userId)).rejects.toThrow(\n        '履歴の削除に失敗しました',\n      );\n    });\n  });\n\n  describe('getFrequentlyViewed', () => {\n    it('should return frequently viewed toilets ordered by view count', async () => {\n      const userId = 'user-123';\n      const mockDocs = [\n        {\n          id: 'history-1',\n          data: () => ({\n            userId,\n            toiletId: 'toilet-1',\n            toiletTitle: 'Most Viewed Toilet',\n            toiletType: ToiletType.PUBLIC,\n            viewedAt: { toDate: () => new Date() },\n            viewCount: 15,\n          }),\n        },\n        {\n          id: 'history-2',\n          data: () => ({\n            userId,\n            toiletId: 'toilet-2',\n            toiletTitle: 'Second Most Viewed',\n            toiletType: ToiletType.STATION,\n            viewedAt: { toDate: () => new Date() },\n            viewCount: 8,\n          }),\n        },\n      ];\n\n      mockFirestore\n        .collection()\n        .where()\n        .orderBy()\n        .limit()\n        .get.mockResolvedValueOnce({\n          forEach: (callback: any) => mockDocs.forEach(callback),\n        });\n\n      const frequently = await historyService.getFrequentlyViewed(userId, 5);\n\n      expect(frequently).toHaveLength(2);\n      expect(frequently[0].viewCount).toBe(15);\n      expect(frequently[1].viewCount).toBe(8);\n      expect(mockFirestore.collection().where).toHaveBeenCalledWith('userId', '==', userId);\n      expect(mockFirestore.collection().where().orderBy).toHaveBeenCalledWith('viewCount', 'desc');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/__tests__/reportService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[126,129],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[126,129],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1577,1580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1577,1580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":66,"column":23,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":66,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4539,4542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4539,4542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":203,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5824,5827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5824,5827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8648,8651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8648,8651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":289,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":289,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8917,8920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8917,8920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":305,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9594,9597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9594,9597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":308,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9734,9737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9734,9737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":313,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9955,9958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9955,9958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Firebase mock (must be before imports)\njest.mock('@react-native-firebase/firestore', () => {\n  const createQueryMock = (): any => ({\n    where: jest.fn(() => createQueryMock()),\n    orderBy: jest.fn(() => createQueryMock()),\n    limit: jest.fn(() => createQueryMock()),\n    offset: jest.fn(() => createQueryMock()),\n    get: jest.fn(() =>\n      Promise.resolve({\n        empty: true,\n        docs: [],\n        size: 0,\n        forEach: jest.fn(),\n      }),\n    ),\n  });\n\n  const mockFirestore = {\n    collection: jest.fn(() => ({\n      doc: jest.fn(() => ({\n        id: 'mock-doc-id',\n        set: jest.fn(() => Promise.resolve()),\n        get: jest.fn(() =>\n          Promise.resolve({\n            exists: false,\n            data: () => null,\n          }),\n        ),\n        update: jest.fn(() => Promise.resolve()),\n      })),\n      add: jest.fn(() => Promise.resolve({ id: 'mock-report-id' })),\n      ...createQueryMock(),\n    })),\n    Timestamp: {\n      now: jest.fn(() => ({ toDate: () => new Date() })),\n      fromDate: jest.fn((date: Date) => ({ toDate: () => date })),\n    },\n    batch: jest.fn(() => ({\n      delete: jest.fn(),\n      commit: jest.fn(() => Promise.resolve()),\n    })),\n  };\n\n  return {\n    __esModule: true,\n    default: jest.fn(() => mockFirestore),\n  };\n});\n\nimport { ReportService } from '../reportService';\nimport {\n  ReportTargetType,\n  ReportReason,\n  ReportStatus,\n  ViolationType,\n  ViolationSeverity,\n  RestrictionType,\n} from '../../types/post';\n\ndescribe('ReportService', () => {\n  let reportService: ReportService;\n  let mockFirestore: any;\n\n  beforeEach(() => {\n    // Get the mocked firestore instance\n    const firestore = require('@react-native-firebase/firestore').default;\n    mockFirestore = firestore();\n\n    reportService = new ReportService();\n    jest.clearAllMocks();\n  });\n\n  describe('submitReport', () => {\n    it('should submit a new report successfully', async () => {\n      const reporterId = 'user-123';\n      const targetType = ReportTargetType.TOILET;\n      const targetId = 'toilet-456';\n      const reason = ReportReason.INAPPROPRIATE_CONTENT;\n      const description = 'Test report description';\n\n      await reportService.submitReport(reporterId, targetType, targetId, reason, description);\n\n      expect(mockFirestore.collection).toHaveBeenCalledWith('reports');\n      expect(mockFirestore.collection().add).toHaveBeenCalledWith(\n        expect.objectContaining({\n          reporterId,\n          targetType,\n          targetId,\n          reason,\n          description,\n          status: ReportStatus.PENDING,\n        }),\n      );\n    });\n\n    it('should reject duplicate reports', async () => {\n      // Mock existing report\n      mockFirestore\n        .collection()\n        .where()\n        .get.mockResolvedValueOnce({\n          empty: false,\n          docs: [{ id: 'existing-report' }],\n        });\n\n      const reporterId = 'user-123';\n      const targetType = ReportTargetType.TOILET;\n      const targetId = 'toilet-456';\n      const reason = ReportReason.SPAM;\n\n      await expect(\n        reportService.submitReport(reporterId, targetType, targetId, reason),\n      ).rejects.toThrow('この対象は既に通報済みです');\n    });\n  });\n\n  describe('addViolationRecord', () => {\n    it('should add violation record and check for restrictions', async () => {\n      const userId = 'user-123';\n      const type = ViolationType.SPAM_POSTING;\n      const severity = ViolationSeverity.MEDIUM;\n      const description = 'Spam violation';\n\n      // Mock getUserViolationPoints to return high points\n      jest.spyOn(reportService, 'getUserViolationPoints').mockResolvedValue(5);\n\n      await reportService.addViolationRecord(userId, type, severity, description);\n\n      expect(mockFirestore.collection).toHaveBeenCalledWith('violation_records');\n      expect(mockFirestore.collection().add).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId,\n          type,\n          severity,\n          description,\n          autoDetected: false,\n          points: 3, // MEDIUM severity = 3 points\n        }),\n      );\n    });\n  });\n\n  describe('getUserViolationPoints', () => {\n    it('should calculate total violation points correctly', async () => {\n      const userId = 'user-123';\n      const mockDocs = [\n        { data: () => ({ points: 3 }) },\n        { data: () => ({ points: 5 }) },\n        { data: () => ({ points: 2 }) },\n      ];\n\n      mockFirestore\n        .collection()\n        .where()\n        .where()\n        .get.mockResolvedValueOnce({\n          forEach: (callback: any) => mockDocs.forEach(callback),\n        });\n\n      const points = await reportService.getUserViolationPoints(userId);\n      expect(points).toBe(10);\n    });\n\n    it('should return 0 when user has no violations', async () => {\n      const userId = 'user-123';\n      mockFirestore\n        .collection()\n        .where()\n        .where()\n        .get.mockResolvedValueOnce({\n          forEach: () => {},\n        });\n\n      const points = await reportService.getUserViolationPoints(userId);\n      expect(points).toBe(0);\n    });\n  });\n\n  describe('getUserRestrictions', () => {\n    it('should return active restrictions for user', async () => {\n      const userId = 'user-123';\n      const mockRestrictions = [\n        {\n          id: 'restriction-1',\n          data: () => ({\n            userId,\n            type: RestrictionType.POST_RESTRICTION,\n            reason: 'Spam violation',\n            startDate: { toDate: () => new Date() },\n            endDate: { toDate: () => new Date(Date.now() + 86400000) }, // 1 day later\n            isActive: true,\n            createdBy: 'system',\n          }),\n        },\n      ];\n\n      mockFirestore\n        .collection()\n        .where()\n        .where()\n        .orderBy()\n        .get.mockResolvedValueOnce({\n          forEach: (callback: any) => mockRestrictions.forEach(callback),\n        });\n\n      const restrictions = await reportService.getUserRestrictions(userId);\n      expect(restrictions).toHaveLength(1);\n      expect(restrictions[0].type).toBe(RestrictionType.POST_RESTRICTION);\n    });\n  });\n\n  describe('isUserRestricted', () => {\n    it('should return true when user has applicable restriction', async () => {\n      const userId = 'user-123';\n\n      // Mock getUserRestrictions to return a post restriction\n      jest.spyOn(reportService, 'getUserRestrictions').mockResolvedValue([\n        {\n          id: 'restriction-1',\n          userId,\n          type: RestrictionType.POST_RESTRICTION,\n          reason: 'Test restriction',\n          startDate: new Date(),\n          endDate: new Date(Date.now() + 86400000),\n          isActive: true,\n          createdBy: 'system',\n        },\n      ]);\n\n      const result = await reportService.isUserRestricted(userId, 'post');\n      expect(result.restricted).toBe(true);\n      expect(result.reason).toBe('Test restriction');\n    });\n\n    it('should return false when user has no applicable restrictions', async () => {\n      const userId = 'user-123';\n\n      // Mock getUserRestrictions to return no restrictions\n      jest.spyOn(reportService, 'getUserRestrictions').mockResolvedValue([]);\n\n      const result = await reportService.isUserRestricted(userId, 'post');\n      expect(result.restricted).toBe(false);\n    });\n\n    it('should check permanent ban for all actions', async () => {\n      const userId = 'user-123';\n\n      // Mock getUserRestrictions to return a permanent ban\n      jest.spyOn(reportService, 'getUserRestrictions').mockResolvedValue([\n        {\n          id: 'restriction-1',\n          userId,\n          type: RestrictionType.PERMANENT_BAN,\n          reason: 'Permanent ban',\n          startDate: new Date(),\n          isActive: true,\n          createdBy: 'system',\n        },\n      ]);\n\n      const postResult = await reportService.isUserRestricted(userId, 'post');\n      const commentResult = await reportService.isUserRestricted(userId, 'comment');\n      const reviewResult = await reportService.isUserRestricted(userId, 'review');\n      const voteResult = await reportService.isUserRestricted(userId, 'vote');\n\n      expect(postResult.restricted).toBe(true);\n      expect(commentResult.restricted).toBe(true);\n      expect(reviewResult.restricted).toBe(true);\n      expect(voteResult.restricted).toBe(true);\n    });\n  });\n\n  describe('getReportCountForTarget', () => {\n    it('should count reports for a specific target', async () => {\n      const targetType = ReportTargetType.TOILET;\n      const targetId = 'toilet-123';\n\n      mockFirestore.collection().where().where().where().get.mockResolvedValueOnce({\n        size: 3,\n      });\n\n      const count = await (reportService as any).getReportCountForTarget(targetType, targetId);\n      expect(count).toBe(3);\n    });\n  });\n\n  describe('violation points calculation', () => {\n    it('should assign correct points for each severity level', () => {\n      const getViolationPoints = (reportService as any).getViolationPoints.bind(reportService);\n\n      expect(getViolationPoints(ViolationSeverity.LOW)).toBe(1);\n      expect(getViolationPoints(ViolationSeverity.MEDIUM)).toBe(3);\n      expect(getViolationPoints(ViolationSeverity.HIGH)).toBe(6);\n      expect(getViolationPoints(ViolationSeverity.CRITICAL)).toBe(12);\n    });\n  });\n\n  describe('auto-detection', () => {\n    it('should trigger violation when report count reaches threshold', async () => {\n      const targetType = ReportTargetType.TOILET;\n      const targetId = 'toilet-123';\n      const reason = ReportReason.SPAM;\n\n      // Mock getReportCountForTarget to return 3 (threshold)\n      jest.spyOn(reportService as any, 'getReportCountForTarget').mockResolvedValue(3);\n\n      // Mock getTargetOwnerId to return a user ID\n      jest.spyOn(reportService as any, 'getTargetOwnerId').mockResolvedValue('owner-123');\n\n      // Mock addViolationRecord\n      const addViolationSpy = jest.spyOn(reportService, 'addViolationRecord').mockResolvedValue();\n\n      await (reportService as any).processAutoDetection(targetType, targetId, reason);\n\n      expect(addViolationSpy).toHaveBeenCalledWith(\n        'owner-123',\n        ViolationType.SPAM_POSTING,\n        ViolationSeverity.MEDIUM,\n        '複数の通報により自動検出: spam',\n        undefined,\n        undefined,\n        true,\n      );\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/__tests__/searchService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3219,3222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3219,3222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3756,3759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3756,3759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4280,4283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4280,4283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":174,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4800,4803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4800,4803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":191,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5307,5310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5307,5310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5845,5848],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5845,5848],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":227,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6452,6455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6452,6455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":244,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6988,6991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6988,6991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7504,7507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7504,7507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":337,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9679,9682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9679,9682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":391,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":391,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":427,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":427,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12366,12369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12366,12369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":433,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":433,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12629,12632],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12629,12632],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":439,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12878,12881],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12878,12881],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":445,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13150,13153],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13150,13153],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":455,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":455,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13511,13514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13511,13514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SearchService } from '../searchService';\nimport { SearchFilters, SortOption } from '../../types/post';\nimport { ToiletType } from '../../types/maps';\n\n// Mock Firebase\nconst mockFirestore = {\n  collection: jest.fn(() => ({\n    doc: jest.fn(() => ({\n      id: 'mock-doc-id',\n      set: jest.fn(() => Promise.resolve()),\n      get: jest.fn(() =>\n        Promise.resolve({\n          exists: false,\n          data: () => null,\n        }),\n      ),\n      update: jest.fn(() => Promise.resolve()),\n      delete: jest.fn(() => Promise.resolve()),\n    })),\n    add: jest.fn(() => Promise.resolve({ id: 'mock-id' })),\n    where: jest.fn(() => ({\n      get: jest.fn(() =>\n        Promise.resolve({\n          empty: true,\n          docs: [],\n          forEach: jest.fn(),\n          size: 0,\n        }),\n      ),\n      orderBy: jest.fn(() => ({\n        limit: jest.fn(() => ({\n          get: jest.fn(() =>\n            Promise.resolve({\n              empty: true,\n              docs: [],\n              forEach: jest.fn(),\n            }),\n          ),\n        })),\n        offset: jest.fn(() => ({\n          get: jest.fn(() =>\n            Promise.resolve({\n              empty: true,\n              docs: [],\n              forEach: jest.fn(),\n            }),\n          ),\n        })),\n      })),\n    })),\n    get: jest.fn(() =>\n      Promise.resolve({\n        empty: true,\n        docs: [],\n        forEach: jest.fn(),\n      }),\n    ),\n    orderBy: jest.fn(() => ({\n      limit: jest.fn(() => ({\n        get: jest.fn(() =>\n          Promise.resolve({\n            empty: true,\n            docs: [],\n            forEach: jest.fn(),\n          }),\n        ),\n      })),\n    })),\n  })),\n  Timestamp: {\n    now: jest.fn(() => ({ toDate: () => new Date() })),\n    fromDate: jest.fn(date => ({ toDate: () => date })),\n  },\n};\n\njest.mock('@react-native-firebase/firestore', () => ({\n  __esModule: true,\n  default: jest.fn(() => mockFirestore),\n}));\n\ndescribe('SearchService', () => {\n  let searchService: SearchService;\n\n  beforeEach(() => {\n    searchService = new SearchService();\n    jest.clearAllMocks();\n  });\n\n  describe('searchToilets', () => {\n    const mockToilets = [\n      {\n        id: 'toilet-1',\n        data: () => ({\n          title: 'Central Station Toilet',\n          type: ToiletType.STATION,\n          description: 'Clean and accessible',\n          rating: 4.5,\n          reviewCount: 20,\n          isAccessible: true,\n          location: { latitude: 35.6762, longitude: 139.6503 },\n          facilities: { hasWashlet: true },\n          createdAt: { toDate: () => new Date('2024-01-01') },\n        }),\n      },\n      {\n        id: 'toilet-2',\n        data: () => ({\n          title: 'Park Public Toilet',\n          type: ToiletType.PARK,\n          description: 'Outdoor facility',\n          rating: 3.8,\n          reviewCount: 15,\n          isAccessible: false,\n          location: { latitude: 35.6763, longitude: 139.6504 },\n          facilities: { hasWashlet: false },\n          createdAt: { toDate: () => new Date('2024-01-02') },\n        }),\n      },\n    ];\n\n    it('should search toilets with text query', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: 'station',\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(1);\n      expect(result.toilets[0].title).toBe('Central Station Toilet');\n      expect(result.totalCount).toBe(1);\n    });\n\n    it('should filter by toilet type', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        toiletType: ToiletType.PARK,\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(1);\n      expect(result.toilets[0].title).toBe('Park Public Toilet');\n    });\n\n    it('should filter by accessibility', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        isAccessible: true,\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(1);\n      expect(result.toilets[0].title).toBe('Central Station Toilet');\n    });\n\n    it('should filter by minimum rating', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        rating: 4.0,\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(1);\n      expect(result.toilets[0].rating).toBeGreaterThanOrEqual(4.0);\n    });\n\n    it('should filter by facilities', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        hasWashlet: true,\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(1);\n      expect(result.toilets[0].title).toBe('Central Station Toilet');\n    });\n\n    it('should sort by distance when user location provided', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        sortBy: SortOption.DISTANCE,\n      };\n\n      const userLocation = { latitude: 35.6762, longitude: 139.6503 };\n\n      const result = await searchService.searchToilets(filters, userLocation);\n\n      expect(result.toilets).toHaveLength(2);\n      // Closest toilet should be first\n      expect(result.toilets[0].title).toBe('Central Station Toilet');\n    });\n\n    it('should sort by rating', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        sortBy: SortOption.RATING,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(2);\n      // Higher rated toilet should be first\n      expect(result.toilets[0].rating).toBeGreaterThan(result.toilets[1].rating);\n    });\n\n    it('should sort by newest', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        sortBy: SortOption.NEWEST,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(2);\n      // Newer toilet should be first\n      expect(result.toilets[0].title).toBe('Park Public Toilet');\n    });\n\n    it('should handle pagination', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: (callback: any) => mockToilets.forEach(callback),\n      });\n\n      const filters: SearchFilters = {\n        query: '',\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters, undefined, 1, 1);\n\n      expect(result.toilets).toHaveLength(1);\n      expect(result.hasMore).toBe(true);\n    });\n\n    it('should return empty result when no toilets match', async () => {\n      mockFirestore.collection().get.mockResolvedValueOnce({\n        forEach: jest.fn(),\n      });\n\n      const filters: SearchFilters = {\n        query: 'nonexistent',\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(0);\n      expect(result.totalCount).toBe(0);\n      expect(result.hasMore).toBe(false);\n    });\n  });\n\n  describe('saveFavoriteSearch', () => {\n    it('should save favorite search successfully', async () => {\n      const userId = 'user-123';\n      const name = 'My Favorite Search';\n      const filters: SearchFilters = {\n        query: 'station',\n        toiletType: ToiletType.STATION,\n        sortBy: SortOption.DISTANCE,\n      };\n\n      await searchService.saveFavoriteSearch(userId, name, filters);\n\n      expect(mockFirestore.collection).toHaveBeenCalledWith('saved_searches');\n      expect(mockFirestore.collection().add).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId,\n          name,\n          filters,\n        }),\n      );\n    });\n  });\n\n  describe('getSavedSearches', () => {\n    it('should retrieve saved searches for user', async () => {\n      const userId = 'user-123';\n      const mockSavedSearches = [\n        {\n          id: 'search-1',\n          data: () => ({\n            userId,\n            name: 'Station Toilets',\n            filters: { query: 'station', sortBy: SortOption.DISTANCE },\n            createdAt: { toDate: () => new Date('2024-01-01') },\n            lastUsed: { toDate: () => new Date('2024-01-05') },\n          }),\n        },\n      ];\n\n      mockFirestore\n        .collection()\n        .where()\n        .orderBy()\n        .get.mockResolvedValueOnce({\n          forEach: (callback: any) => mockSavedSearches.forEach(callback),\n        });\n\n      const searches = await searchService.getSavedSearches(userId);\n\n      expect(searches).toHaveLength(1);\n      expect(searches[0].name).toBe('Station Toilets');\n      expect(searches[0].filters.query).toBe('station');\n    });\n  });\n\n  describe('saveSearchHistory', () => {\n    it('should save search history successfully', async () => {\n      const userId = 'user-123';\n      const filters: SearchFilters = {\n        query: 'park',\n        sortBy: SortOption.RATING,\n      };\n      const resultCount = 5;\n\n      await searchService.saveSearchHistory(userId, filters, resultCount);\n\n      expect(mockFirestore.collection).toHaveBeenCalledWith('search_history');\n      expect(mockFirestore.collection().add).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId,\n          query: 'park',\n          filters,\n          resultCount,\n        }),\n      );\n    });\n\n    it('should not save empty queries', async () => {\n      const userId = 'user-123';\n      const filters: SearchFilters = {\n        query: '',\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      await searchService.saveSearchHistory(userId, filters, 0);\n\n      expect(mockFirestore.collection().add).not.toHaveBeenCalled();\n    });\n\n    it('should limit search history to 50 entries', async () => {\n      const userId = 'user-123';\n      const filters: SearchFilters = {\n        query: 'test',\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const oldSearches = Array(5)\n        .fill(null)\n        .map((_, i) => ({\n          ref: { delete: jest.fn() },\n        }));\n\n      mockFirestore.collection().where().orderBy().offset().get.mockResolvedValueOnce({\n        empty: false,\n        docs: oldSearches,\n      });\n\n      const mockBatch = {\n        delete: jest.fn(),\n        commit: jest.fn(() => Promise.resolve()),\n      };\n      mockFirestore.batch = jest.fn(() => mockBatch);\n\n      await searchService.saveSearchHistory(userId, filters, 5);\n\n      expect(mockBatch.delete).toHaveBeenCalledTimes(5);\n      expect(mockBatch.commit).toHaveBeenCalled();\n    });\n  });\n\n  describe('deleteSavedSearch', () => {\n    it('should delete saved search successfully', async () => {\n      const searchId = 'search-123';\n\n      await searchService.deleteSavedSearch(searchId);\n\n      expect(mockFirestore.collection().doc).toHaveBeenCalledWith(searchId);\n      expect(mockFirestore.collection().doc().delete).toHaveBeenCalled();\n    });\n  });\n\n  describe('text matching', () => {\n    it('should match text in title', () => {\n      const toilet = { title: 'Central Station', description: 'Clean toilet' };\n      const result = (searchService as any).matchesTextSearch(toilet, 'station');\n      expect(result).toBe(true);\n    });\n\n    it('should match text in description', () => {\n      const toilet = { title: 'Public Toilet', description: 'Near the park entrance' };\n      const result = (searchService as any).matchesTextSearch(toilet, 'park');\n      expect(result).toBe(true);\n    });\n\n    it('should be case insensitive', () => {\n      const toilet = { title: 'STATION TOILET', description: 'CLEAN AND MODERN' };\n      const result = (searchService as any).matchesTextSearch(toilet, 'station');\n      expect(result).toBe(true);\n    });\n\n    it('should return false for non-matching text', () => {\n      const toilet = { title: 'Mall Toilet', description: 'Shopping center facility' };\n      const result = (searchService as any).matchesTextSearch(toilet, 'station');\n      expect(result).toBe(false);\n    });\n  });\n\n  describe('distance calculation', () => {\n    it('should calculate distance correctly', () => {\n      const point1 = { latitude: 35.6762, longitude: 139.6503 };\n      const point2 = { latitude: 35.6763, longitude: 139.6504 };\n\n      const distance = (searchService as any).calculateDistance(point1, point2);\n      expect(distance).toBeGreaterThan(0);\n      expect(distance).toBeLessThan(1); // Should be less than 1 km for nearby points\n    });\n  });\n\n  describe('error handling', () => {\n    it('should handle search errors gracefully', async () => {\n      mockFirestore.collection().get.mockRejectedValue(new Error('Database error'));\n\n      const filters: SearchFilters = {\n        query: 'test',\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      const result = await searchService.searchToilets(filters);\n\n      expect(result.toilets).toHaveLength(0);\n      expect(result.totalCount).toBe(0);\n      expect(result.hasMore).toBe(false);\n    });\n\n    it('should handle save search history errors', async () => {\n      mockFirestore.collection().add.mockRejectedValue(new Error('Save error'));\n\n      const userId = 'user-123';\n      const filters: SearchFilters = {\n        query: 'test',\n        sortBy: SortOption.RELEVANCE,\n      };\n\n      // Should not throw error\n      await expect(searchService.saveSearchHistory(userId, filters, 5)).resolves.not.toThrow();\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/authService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":28,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":28,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[615,663],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":31,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":31,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[759,801],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":33,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":33,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[860,910],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[979,982],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[979,982],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1098,1145],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":45,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1254,1297],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1452,1455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1452,1455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":96,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":96,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2755,2821],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":101,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":101,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2896,2956],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":115,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":115,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3222,3278],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3389,3392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3389,3392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import auth from '@react-native-firebase/auth';\nimport { GoogleSignin } from '@react-native-google-signin/google-signin';\n\nexport interface User {\n  uid: string;\n  email: string | null;\n  displayName: string | null;\n  photoURL: string | null;\n}\n\nclass AuthService {\n  constructor() {\n    this.configureGoogleSignIn();\n  }\n\n  private configureGoogleSignIn() {\n    GoogleSignin.configure({\n      webClientId: '787078900732-m6hflbubinifr6rn24gaqvisj15qmaae.apps.googleusercontent.com',\n    });\n  }\n\n  /**\n   * Googleサインインを実行\n   */\n  async signInWithGoogle(): Promise<User> {\n    try {\n      // Google サインイン画面を表示\n      console.log('Checking Google Play Services...');\n      await GoogleSignin.hasPlayServices({ showPlayServicesUpdateDialog: true });\n      \n      console.log('Starting Google Sign In...');\n      const response = await GoogleSignin.signIn();\n      console.log('Google Sign In response:', response);\n      \n      const idToken = response.data?.idToken || (response as any).idToken;\n      if (!idToken) {\n        throw new Error('IDトークンの取得に失敗しました');\n      }\n\n      // Google認証情報を作成\n      console.log('Creating Firebase credential...');\n      const googleCredential = auth.GoogleAuthProvider.credential(idToken);\n\n      // Firebase にサインイン\n      console.log('Signing in with Firebase...');\n      const userCredential = await auth().signInWithCredential(googleCredential);\n\n      return this.formatUser(userCredential.user);\n    } catch (error: any) {\n      console.error('Google sign in error:', error);\n      console.error('Error code:', error.code);\n      console.error('Error message:', error.message);\n      \n      // エラーコード別の詳細メッセージ\n      if (error.code === 'statusCodes.SIGN_IN_CANCELLED') {\n        throw new Error('サインインがキャンセルされました');\n      } else if (error.code === 'statusCodes.IN_PROGRESS') {\n        throw new Error('サインインが進行中です');\n      } else if (error.code === 'statusCodes.PLAY_SERVICES_NOT_AVAILABLE') {\n        throw new Error('Google Play Services が利用できません');\n      } else {\n        throw new Error(`Googleサインインに失敗しました: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * サインアウト\n   */\n  async signOut(): Promise<void> {\n    try {\n      // Firebase からサインアウト\n      await auth().signOut();\n\n      // Google からもサインアウト\n      await GoogleSignin.signOut();\n    } catch (error) {\n      console.error('Sign out error:', error);\n      throw new Error('サインアウトに失敗しました');\n    }\n  }\n\n  /**\n   * 認証状態変更の監視\n   */\n  onAuthStateChanged(callback: (user: User | null) => void): () => void {\n    try {\n      return auth().onAuthStateChanged(firebaseUser => {\n        try {\n          if (firebaseUser) {\n            callback(this.formatUser(firebaseUser));\n          } else {\n            callback(null);\n          }\n        } catch (error) {\n          console.log('authService: onAuthStateChanged コールバックでエラー:', error);\n          callback(null);\n        }\n      });\n    } catch (error) {\n      console.log('authService: onAuthStateChanged でエラー:', error);\n      // ダミー関数を返す\n      return () => {};\n    }\n  }\n\n  /**\n   * 現在のユーザーを取得\n   */\n  getCurrentUser(): User | null {\n    try {\n      const firebaseUser = auth().currentUser;\n      return firebaseUser ? this.formatUser(firebaseUser) : null;\n    } catch (error) {\n      console.log('authService: getCurrentUser でエラー:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Firebase Userオブジェクトを標準形式に変換\n   */\n  private formatUser(firebaseUser: any): User {\n    return {\n      uid: firebaseUser.uid,\n      email: firebaseUser.email,\n      displayName: firebaseUser.displayName,\n      photoURL: firebaseUser.photoURL,\n    };\n  }\n\n  /**\n   * アカウント削除\n   */\n  async deleteAccount(): Promise<void> {\n    try {\n      const user = auth().currentUser;\n      if (user) {\n        await user.delete();\n        await GoogleSignin.signOut();\n      }\n    } catch (error) {\n      console.error('Delete account error:', error);\n      throw new Error('アカウント削除に失敗しました');\n    }\n  }\n\n  /**\n   * ユーザーがサインインしているかチェック\n   */\n  isSignedIn(): boolean {\n    return auth().currentUser !== null;\n  }\n}\n\nexport const authService = new AuthService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/badgeService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userBadges' is defined but never used. Allowed unused args must match /^_/u.","line":119,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6084,6087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6084,6087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6219,6222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6219,6222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import firestore from '@react-native-firebase/firestore';\nimport { Badge, UserBadges, BadgeCategory, BadgeRarity } from '../types/post';\nimport { BADGES } from '../data/badges';\n\nexport class BadgeService {\n  private userBadgesCollection = firestore().collection('user_badges');\n  private userStatsCollection = firestore().collection('user_stats');\n\n  /**\n   * ユーザーのバッジ情報を取得\n   */\n  async getUserBadges(userId: string): Promise<UserBadges> {\n    try {\n      const doc = await this.userBadgesCollection.doc(userId).get();\n\n      if (!doc.exists) {\n        // 新規ユーザーの場合、初期データを作成\n        const initialData: UserBadges = {\n          userId,\n          unlockedBadges: [],\n          progress: {},\n          lastChecked: new Date(),\n        };\n\n        await this.userBadgesCollection.doc(userId).set({\n          ...initialData,\n          lastChecked: firestore.Timestamp.now(),\n        });\n\n        return initialData;\n      }\n\n      const data = doc.data()!;\n      return {\n        userId: data.userId,\n        unlockedBadges: data.unlockedBadges || [],\n        progress: data.progress || {},\n        lastChecked: data.lastChecked?.toDate() || new Date(),\n      };\n    } catch (error) {\n      console.error('Failed to get user badges:', error);\n      throw new Error('バッジ情報の取得に失敗しました');\n    }\n  }\n\n  /**\n   * ユーザーの統計情報を取得\n   */\n  async getUserStats(userId: string): Promise<Record<string, number>> {\n    try {\n      const doc = await this.userStatsCollection.doc(userId).get();\n\n      if (!doc.exists) {\n        return {};\n      }\n\n      return doc.data() || {};\n    } catch (error) {\n      console.error('Failed to get user stats:', error);\n      return {};\n    }\n  }\n\n  /**\n   * ユーザーの統計情報を更新\n   */\n  async updateUserStats(userId: string, stats: Record<string, number>): Promise<void> {\n    try {\n      await this.userStatsCollection.doc(userId).set(stats, { merge: true });\n    } catch (error) {\n      console.error('Failed to update user stats:', error);\n      throw new Error('統計情報の更新に失敗しました');\n    }\n  }\n\n  /**\n   * バッジ取得条件をチェック\n   */\n  async checkBadgeConditions(userId: string): Promise<string[]> {\n    try {\n      const [userBadges, userStats] = await Promise.all([\n        this.getUserBadges(userId),\n        this.getUserStats(userId),\n      ]);\n\n      const newBadges: string[] = [];\n\n      for (const badge of BADGES) {\n        // 既に取得済みのバッジはスキップ\n        if (userBadges.unlockedBadges.includes(badge.id)) {\n          continue;\n        }\n\n        const isUnlocked = this.evaluateBadgeCondition(badge, userStats, userBadges);\n\n        if (isUnlocked) {\n          newBadges.push(badge.id);\n        }\n      }\n\n      // 新しいバッジがある場合、バッジ情報を更新\n      if (newBadges.length > 0) {\n        await this.unlockBadges(userId, newBadges);\n      }\n\n      return newBadges;\n    } catch (error) {\n      console.error('Failed to check badge conditions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * バッジの取得条件を評価\n   */\n  private evaluateBadgeCondition(\n    badge: Badge,\n    userStats: Record<string, number>,\n    userBadges: UserBadges,\n  ): boolean {\n    const { condition } = badge;\n    const currentValue = userStats[condition.target] || 0;\n\n    switch (condition.type) {\n      case 'count':\n        return currentValue >= condition.value;\n\n      case 'rating':\n        // 最小投稿数チェック（品質系バッジ）\n        if (condition.target === 'helpful_ratio' || condition.target.includes('avg_')) {\n          const minPosts = userStats.toilets_posted || 0;\n          if (minPosts < 10) return false;\n        }\n        return currentValue >= condition.value;\n\n      case 'streak':\n        // 連続記録系（実装は簡略化）\n        return currentValue >= condition.value;\n\n      case 'special':\n        // 特別条件（手動付与や特殊ロジック）\n        return this.evaluateSpecialCondition(condition.target, condition.value, userStats);\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * 特別条件の評価\n   */\n  private evaluateSpecialCondition(\n    target: string,\n    value: number,\n    userStats: Record<string, number>,\n  ): boolean {\n    switch (target) {\n      case 'registration_date':\n        // アーリーアダプター判定（ユーザーIDベース等）\n        return (userStats.user_number || 999999) <= value;\n\n      case 'monthly_ranking':\n        // 月間ランキング1位\n        return (userStats.monthly_rank || 999) === value;\n\n      case 'perfect_rating_post':\n        // パーフェクト評価の投稿数\n        return (userStats.perfect_posts || 0) >= value;\n\n      case 'manual_award':\n        // 手動付与フラグ\n        return (userStats.legend_awarded || 0) >= value;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * バッジを取得済みにマーク\n   */\n  async unlockBadges(userId: string, badgeIds: string[]): Promise<void> {\n    try {\n      const userBadges = await this.getUserBadges(userId);\n\n      const updatedBadges = {\n        ...userBadges,\n        unlockedBadges: [...userBadges.unlockedBadges, ...badgeIds],\n        lastChecked: firestore.Timestamp.now(),\n      };\n\n      await this.userBadgesCollection.doc(userId).set(updatedBadges, { merge: true });\n    } catch (error) {\n      console.error('Failed to unlock badges:', error);\n      throw new Error('バッジの取得に失敗しました');\n    }\n  }\n\n  /**\n   * ユーザーの取得済みバッジ詳細を取得\n   */\n  async getUserBadgeDetails(userId: string): Promise<Badge[]> {\n    try {\n      const userBadges = await this.getUserBadges(userId);\n\n      return userBadges.unlockedBadges\n        .map(badgeId => BADGES.find(badge => badge.id === badgeId))\n        .filter((badge): badge is Badge => badge !== undefined)\n        .map(badge => ({\n          ...badge,\n          unlockedAt: new Date(), // 実際の実装では取得日時を保存\n        }));\n    } catch (error) {\n      console.error('Failed to get user badge details:', error);\n      return [];\n    }\n  }\n\n  /**\n   * ユーザーのバッジ進捗を更新\n   */\n  async updateBadgeProgress(userId: string, target: string, value: number): Promise<void> {\n    try {\n      await this.updateUserStats(userId, { [target]: value });\n\n      // バッジ条件をチェックして新しいバッジがあるか確認\n      await this.checkBadgeConditions(userId);\n    } catch (error) {\n      console.error('Failed to update badge progress:', error);\n    }\n  }\n\n  /**\n   * 投稿時の統計更新\n   */\n  async onToiletPosted(userId: string, toiletData: any): Promise<string[]> {\n    try {\n      const userStats = await this.getUserStats(userId);\n\n      const updatedStats: Record<string, any> = {\n        ...userStats,\n        toilets_posted: (userStats.toilets_posted || 0) + 1,\n        accessible_toilets_posted: toiletData.isAccessible\n          ? (userStats.accessible_toilets_posted || 0) + 1\n          : userStats.accessible_toilets_posted || 0,\n      };\n\n      // 地域とタイプの追跡\n      const postedAreas = userStats.posted_areas && typeof userStats.posted_areas === 'string' ? JSON.parse(userStats.posted_areas) : [];\n      const postedTypes = userStats.posted_types && typeof userStats.posted_types === 'string' ? JSON.parse(userStats.posted_types) : [];\n\n      if (toiletData.area && !postedAreas.includes(toiletData.area)) {\n        postedAreas.push(toiletData.area);\n        updatedStats.unique_areas_posted = postedAreas.length;\n        updatedStats.posted_areas = JSON.stringify(postedAreas);\n      }\n\n      if (!postedTypes.includes(toiletData.type)) {\n        postedTypes.push(toiletData.type);\n        updatedStats.toilet_types_posted = postedTypes.length;\n        updatedStats.posted_types = JSON.stringify(postedTypes);\n      }\n\n      await this.updateUserStats(userId, updatedStats);\n\n      // バッジ条件チェック\n      return await this.checkBadgeConditions(userId);\n    } catch (error) {\n      console.error('Failed to handle toilet posted event:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 投票時の統計更新\n   */\n  async onHelpfulVote(voterId: string, targetUserId: string): Promise<void> {\n    try {\n      // 投票者の統計更新\n      const voterStats = await this.getUserStats(voterId);\n      await this.updateUserStats(voterId, {\n        ...voterStats,\n        helpful_votes_given: (voterStats.helpful_votes_given || 0) + 1,\n      });\n\n      // 投稿者の統計更新\n      const targetStats = await this.getUserStats(targetUserId);\n      await this.updateUserStats(targetUserId, {\n        ...targetStats,\n        helpful_votes_received: (targetStats.helpful_votes_received || 0) + 1,\n      });\n\n      // 両者のバッジ条件チェック\n      await Promise.all([\n        this.checkBadgeConditions(voterId),\n        this.checkBadgeConditions(targetUserId),\n      ]);\n    } catch (error) {\n      console.error('Failed to handle helpful vote event:', error);\n    }\n  }\n\n  /**\n   * 全バッジの取得\n   */\n  getAllBadges(): Badge[] {\n    return BADGES;\n  }\n\n  /**\n   * カテゴリ別バッジの取得\n   */\n  getBadgesByCategory(category: BadgeCategory): Badge[] {\n    return BADGES.filter(badge => badge.category === category);\n  }\n\n  /**\n   * レア度別バッジの取得\n   */\n  getBadgesByRarity(rarity: BadgeRarity): Badge[] {\n    return BADGES.filter(badge => badge.rarity === rarity);\n  }\n}\n\n// シングルトンインスタンス\nexport const badgeService = new BadgeService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/firestoreService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2947,2950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2947,2950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":120,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":120,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3745,3830],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":133,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":133,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4284,4400],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":137,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":137,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4506,4555],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":145,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":145,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4735,4791],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4929,4972],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":166,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":166,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5559,5596],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":167,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":167,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5607,5728],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":168,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":168,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[5739,5863],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":186,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6634,6637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6634,6637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":191,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":191,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6732,6782],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6825,6828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6825,6828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8187,8190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8187,8190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":302,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":302,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[9948,9978],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":351,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":351,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11602,11664],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":354,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":354,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11680,11713],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":355,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11734,11737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11734,11737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":403,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":403,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13140,13143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13140,13143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import firestore from '@react-native-firebase/firestore';\nimport storage from '@react-native-firebase/storage';\nimport { ToiletPostForm } from '../types/post';\nimport { ToiletLocation } from '../types/maps';\n\nexport class FirestoreService {\n  private toiletsCollection = firestore().collection('toilets');\n  private imagesRef = storage().ref('toilet-images');\n\n  /**\n   * 画像をFirebase Storageにアップロード\n   */\n  async uploadImages(images: string[], toiletId: string): Promise<string[]> {\n    const uploadPromises = images.map(async (imagePath, index) => {\n      try {\n        const imageRef = this.imagesRef.child(`${toiletId}/${index}.jpg`);\n        await imageRef.putFile(imagePath);\n        const downloadURL = await imageRef.getDownloadURL();\n        return downloadURL;\n      } catch (error) {\n        console.error(`Failed to upload image ${index}:`, error);\n        throw error;\n      }\n    });\n\n    return Promise.all(uploadPromises);\n  }\n\n  /**\n   * トイレ情報をFirestoreに保存（複数トイレ対応）\n   */\n  async createToilet(form: ToiletPostForm, userId: string): Promise<string> {\n    try {\n      // 施設ドキュメントを作成\n      const facilityRef = this.toiletsCollection.doc();\n      const facilityId = facilityRef.id;\n\n      // 施設画像をアップロード\n      let facilityImageUrls: string[] = [];\n      if (form.facilityImages.length > 0) {\n        facilityImageUrls = await this.uploadImages(form.facilityImages, `${facilityId}/facility`);\n      }\n\n      // 施設データ（最初のトイレの情報を使用）\n      const firstToilet = form.toilets[0];\n      if (!firstToilet) {\n        throw new Error('少なくとも1つのトイレ情報が必要です');\n      }\n\n      // 各トイレの画像をアップロード\n      let toiletImageUrls: string[] = [];\n      if (firstToilet.images.length > 0) {\n        toiletImageUrls = await this.uploadImages(firstToilet.images, `${facilityId}/toilet_0`);\n      }\n\n      // Firestoreに保存するデータ（既存の構造を維持）\n      const toiletData = {\n        id: facilityId,\n        title: form.facilityTitle,\n        description: form.facilityDescription,\n        type: form.type,\n        isAccessible: firstToilet.isAccessible,\n        location: {\n          latitude: form.location!.latitude,\n          longitude: form.location!.longitude,\n        },\n        facilities: firstToilet.facilities,\n        openingHours: form.openingHours,\n        additionalInfo: form.additionalInfo,\n        detailedEquipment: firstToilet.detailedEquipment,\n        ratings: firstToilet.ratings,\n        images: [...facilityImageUrls, ...toiletImageUrls],\n        createdBy: userId,\n        createdAt: firestore.Timestamp.now(),\n        updatedAt: firestore.Timestamp.now(),\n        rating: firstToilet.ratings.overall || 0,\n        reviewCount: 1,\n        isActive: true,\n        // 複数トイレ情報を追加フィールドとして保存\n        toilets: form.toilets.map((toilet, index) => ({\n          ...toilet,\n          images: index === 0 ? toiletImageUrls : [], // 現在は最初のトイレの画像のみアップロード\n        })),\n      };\n\n      await facilityRef.set(toiletData);\n      return facilityId;\n    } catch (error: any) {\n      console.error('Failed to create toilet:', error);\n      console.error('Error code:', error.code);\n      console.error('Error message:', error.message);\n      throw new Error(`トイレの投稿に失敗しました: ${error.message}`);\n    }\n  }\n\n  /**\n   * トイレ情報を更新\n   */\n  async updateToilet(toiletId: string, updates: Partial<ToiletLocation>): Promise<void> {\n    try {\n      await this.toiletsCollection.doc(toiletId).update({\n        ...updates,\n        updatedAt: firestore.Timestamp.now(),\n      });\n    } catch (error) {\n      console.error('Failed to update toilet:', error);\n      throw new Error('トイレ情報の更新に失敗しました');\n    }\n  }\n\n  /**\n   * 近くのトイレを検索\n   */\n  async getNearbyToilets(\n    latitude: number,\n    longitude: number,\n    radiusKm: number = 5,\n  ): Promise<ToiletLocation[]> {\n    try {\n      console.log(`位置情報でトイレを検索中: lat=${latitude}, lng=${longitude}, radius=${radiusKm}km`);\n      \n      // 入力値の検証\n      if (!latitude || !longitude || isNaN(latitude) || isNaN(longitude)) {\n        console.error('無効な位置情報:', { latitude, longitude });\n        throw new Error('無効な位置情報が提供されました');\n      }\n      \n      // Firestoreでは地理的クエリが制限されているため、\n      // より寛容な範囲検索を実装（検索範囲を2倍に拡大）\n      const latDelta = (radiusKm * 2) / 111.32; // 緯度1度 ≈ 111.32km\n      const lngDelta = (radiusKm * 2) / (111.32 * Math.cos((latitude * Math.PI) / 180));\n\n      console.log(`検索範囲: lat=${latitude-latDelta}~${latitude+latDelta}, lng=${longitude-lngDelta}~${longitude+lngDelta}`);\n\n      // まずFirestoreへの接続をテスト\n      const testQuery = await this.toiletsCollection.limit(1).get();\n      console.log('Firestore接続テスト成功:', testQuery.size);\n\n      // 複合インデックスを避けるため、単一条件でクエリして後でフィルタリング\n      const snapshot = await this.toiletsCollection\n        .where('isActive', '==', true)\n        .limit(100)\n        .get();\n\n      console.log(`Firestoreクエリ結果: ${snapshot.size}件のドキュメント`);\n\n      const toilets: ToiletLocation[] = [];\n\n      snapshot.forEach(doc => {\n        try {\n          const data = doc.data();\n          console.log(`処理中のドキュメント: ${doc.id}`, data);\n\n          // データの存在確認\n          if (!data.location || !data.location.latitude || !data.location.longitude) {\n            console.warn(`ドキュメント ${doc.id} に位置情報がありません`);\n            return;\n          }\n\n          // 位置情報の範囲チェック（クライアントサイド）\n          const withinLatRange = data.location.latitude >= latitude - latDelta && \n                                data.location.latitude <= latitude + latDelta;\n          const withinLngRange = data.location.longitude >= longitude - lngDelta && \n                                data.location.longitude <= longitude + lngDelta;\n          \n          console.log(`位置チェック: ${data.title}`);\n          console.log(`  緯度: ${data.location.latitude} (範囲: ${latitude - latDelta} ~ ${latitude + latDelta}) = ${withinLatRange}`);\n          console.log(`  経度: ${data.location.longitude} (範囲: ${longitude - lngDelta} ~ ${longitude + lngDelta}) = ${withinLngRange}`);\n          \n          if (withinLatRange && withinLngRange) {\n            toilets.push({\n              id: data.id || doc.id,\n              title: data.title || 'タイトルなし',\n              description: data.description || '',\n              latitude: data.location.latitude,\n              longitude: data.location.longitude,\n              type: data.type || 'public',\n              isAccessible: data.isAccessible || false,\n              rating: data.rating || 0,\n              reviewCount: data.reviewCount || 0,\n              createdBy: data.createdBy || '',\n              createdAt: data.createdAt ? data.createdAt.toDate() : new Date(),\n              updatedAt: data.updatedAt ? data.updatedAt.toDate() : new Date(),\n            });\n          }\n        } catch (docError: any) {\n          console.error(`ドキュメント ${doc.id} の処理でエラー:`, docError);\n        }\n      });\n\n      console.log(`結果: ${toilets.length}件のトイレが見つかりました`);\n      return toilets;\n    } catch (error: any) {\n      console.error('Failed to get nearby toilets:', error);\n      console.error('Error code:', error.code);\n      console.error('Error message:', error.message);\n      console.error('Error stack:', error.stack);\n      \n      // Firestoreの接続エラーかどうかを判定\n      if (error.code === 'unavailable' || error.code === 'permission-denied') {\n        throw new Error('Firestoreへの接続に失敗しました。ネットワーク接続とFirebase設定を確認してください。');\n      } else if (error.code === 'unauthenticated') {\n        throw new Error('認証が必要です。ログインしてから再度お試しください。');\n      } else {\n        throw new Error(`近くのトイレの取得に失敗しました: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * 特定のトイレ情報を取得\n   */\n  async getToilet(toiletId: string): Promise<ToiletLocation | null> {\n    try {\n      const doc = await this.toiletsCollection.doc(toiletId).get();\n\n      if (!doc.exists) {\n        return null;\n      }\n\n      const data = doc.data()!;\n      return {\n        id: data.id,\n        title: data.title,\n        description: data.description,\n        latitude: data.location.latitude,\n        longitude: data.location.longitude,\n        type: data.type,\n        isAccessible: data.isAccessible,\n        rating: data.rating,\n        reviewCount: data.reviewCount,\n        createdBy: data.createdBy,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      };\n    } catch (error: any) {\n      console.error('Failed to get toilet:', error);\n      console.error('Error code:', error.code);\n      console.error('Error message:', error.message);\n      throw new Error(`トイレ情報の取得に失敗しました: ${error.message}`);\n    }\n  }\n\n  /**\n   * ユーザーが投稿したトイレ一覧を取得\n   */\n  async getUserToilets(userId: string): Promise<ToiletLocation[]> {\n    try {\n      const snapshot = await this.toiletsCollection\n        .where('createdBy', '==', userId)\n        .where('isActive', '==', true)\n        .orderBy('createdAt', 'desc')\n        .get();\n\n      const toilets: ToiletLocation[] = [];\n\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        toilets.push({\n          id: data.id,\n          title: data.title,\n          description: data.description,\n          latitude: data.location.latitude,\n          longitude: data.location.longitude,\n          type: data.type,\n          isAccessible: data.isAccessible,\n          rating: data.rating,\n          reviewCount: data.reviewCount,\n          createdBy: data.createdBy,\n          createdAt: data.createdAt.toDate(),\n          updatedAt: data.updatedAt.toDate(),\n        });\n      });\n\n      return toilets;\n    } catch (error) {\n      console.error('Failed to get user toilets:', error);\n      throw new Error('ユーザーのトイレ一覧の取得に失敗しました');\n    }\n  }\n\n  /**\n   * トイレを削除（論理削除）\n   */\n  async deleteToilet(toiletId: string): Promise<void> {\n    try {\n      await this.toiletsCollection.doc(toiletId).update({\n        isActive: false,\n        updatedAt: firestore.Timestamp.now(),\n      });\n    } catch (error) {\n      console.error('Failed to delete toilet:', error);\n      throw new Error('トイレの削除に失敗しました');\n    }\n  }\n\n  /**\n   * テスト用サンプルデータを作成\n   */\n  async createSampleData(): Promise<void> {\n    try {\n      console.log('サンプルデータを作成中...');\n      \n      const sampleToilets = [\n        {\n          title: '東京駅構内トイレ',\n          description: '東京駅丸の内中央口近くの清潔なトイレです',\n          type: 'public',\n          isAccessible: true,\n          location: { latitude: 35.6812, longitude: 139.7671 },\n          facilities: ['washlet', 'handicap'],\n          openingHours: '24時間',\n          additionalInfo: '駅構内にあります',\n          detailedEquipment: { washlet: true, handicapAccess: true },\n          ratings: { overall: 4.5, cleanliness: 4.5, accessibility: 5.0 },\n          images: [],\n          createdBy: 'system',\n          createdAt: firestore.Timestamp.now(),\n          updatedAt: firestore.Timestamp.now(),\n          rating: 4.5,\n          reviewCount: 10,\n          isActive: true,\n        },\n        {\n          title: '新宿駅南口トイレ',\n          description: '新宿駅南口近くの便利なトイレ',\n          type: 'public',\n          isAccessible: true,\n          location: { latitude: 35.6896, longitude: 139.7006 },\n          facilities: ['washlet'],\n          openingHours: '24時間',\n          additionalInfo: '駅近くです',\n          detailedEquipment: { washlet: true, handicapAccess: false },\n          ratings: { overall: 4.0, cleanliness: 4.0, accessibility: 3.5 },\n          images: [],\n          createdBy: 'system',\n          createdAt: firestore.Timestamp.now(),\n          updatedAt: firestore.Timestamp.now(),\n          rating: 4.0,\n          reviewCount: 5,\n          isActive: true,\n        }\n      ];\n\n      for (const toilet of sampleToilets) {\n        const docRef = this.toiletsCollection.doc();\n        await docRef.set({\n          ...toilet,\n          id: docRef.id,\n        });\n        console.log(`サンプルトイレを作成: ${toilet.title} (ID: ${docRef.id})`);\n      }\n\n      console.log('サンプルデータの作成が完了しました');\n    } catch (error: any) {\n      console.error('サンプルデータの作成に失敗:', error);\n      throw new Error(`サンプルデータの作成に失敗しました: ${error.message}`);\n    }\n  }\n\n  /**\n   * トイレ検索（テキスト）\n   */\n  async searchToilets(query: string, limit: number = 20): Promise<ToiletLocation[]> {\n    try {\n      // Firestoreの制限により、単純なテキスト検索を実装\n      // 本格的な検索にはAlgoliaなどの外部サービスを推奨\n      const snapshot = await this.toiletsCollection\n        .where('isActive', '==', true)\n        .orderBy('createdAt', 'desc')\n        .limit(limit)\n        .get();\n\n      const toilets: ToiletLocation[] = [];\n      const lowerQuery = query.toLowerCase();\n\n      snapshot.forEach(doc => {\n        const data = doc.data();\n\n        // クライアントサイドでのテキスト検索\n        if (\n          data.title.toLowerCase().includes(lowerQuery) ||\n          data.description.toLowerCase().includes(lowerQuery)\n        ) {\n          toilets.push({\n            id: data.id,\n            title: data.title,\n            description: data.description,\n            latitude: data.location.latitude,\n            longitude: data.location.longitude,\n            type: data.type,\n            isAccessible: data.isAccessible,\n            rating: data.rating,\n            reviewCount: data.reviewCount,\n            createdBy: data.createdBy,\n            createdAt: data.createdAt.toDate(),\n            updatedAt: data.updatedAt.toDate(),\n          });\n        }\n      });\n\n      return toilets;\n    } catch (error: any) {\n      console.error('Failed to search toilets:', error);\n      console.error('Error code:', error.code);\n      console.error('Error message:', error.message);\n      throw new Error(`トイレの検索に失敗しました: ${error.message}`);\n    }\n  }\n}\n\n// シングルトンインスタンス\nexport const firestoreService = new FirestoreService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/helpfulService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/historyService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1988,1991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1988,1991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":280,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7407,7410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7407,7410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import firestore from '@react-native-firebase/firestore';\nimport { ViewHistory, Favorite, UserActivity, ActivityType, UserStats } from '../types/post';\nimport { ToiletLocation } from '../types/maps';\n\nexport class HistoryService {\n  private viewHistoryCollection = firestore().collection('view_history');\n  private favoritesCollection = firestore().collection('favorites');\n  private activitiesCollection = firestore().collection('user_activities');\n  private userStatsCollection = firestore().collection('user_stats');\n\n  /**\n   * 閲覧履歴を記録\n   */\n  async recordView(userId: string, toilet: ToiletLocation): Promise<void> {\n    try {\n      // 既存の履歴をチェック\n      const existingHistory = await this.viewHistoryCollection\n        .where('userId', '==', userId)\n        .where('toiletId', '==', toilet.id)\n        .get();\n\n      if (!existingHistory.empty) {\n        // 既存の履歴を更新\n        const historyDoc = existingHistory.docs[0];\n        const data = historyDoc.data();\n\n        await historyDoc.ref.update({\n          viewedAt: firestore.Timestamp.now(),\n          viewCount: (data.viewCount || 1) + 1,\n        });\n      } else {\n        // 新しい履歴を作成\n        const historyData: ViewHistory = {\n          id: this.viewHistoryCollection.doc().id,\n          userId,\n          toiletId: toilet.id,\n          toiletTitle: toilet.title,\n          toiletType: toilet.type,\n          viewedAt: new Date(),\n          viewCount: 1,\n        };\n\n        await this.viewHistoryCollection.add({\n          ...historyData,\n          viewedAt: firestore.Timestamp.now(),\n        });\n      }\n\n      // ユーザー統計を更新\n      await this.updateUserStats(userId, { totalViews: 1 });\n\n      // 古い履歴を削除（最新100件のみ保持）\n      const allHistory = await this.viewHistoryCollection\n        .where('userId', '==', userId)\n        .orderBy('viewedAt', 'desc')\n        .get();\n\n      if (allHistory.docs.length > 100) {\n        const batch = firestore().batch();\n        // 100件より古いものを削除\n        allHistory.docs.slice(100).forEach((doc: any) => {\n          batch.delete(doc.ref);\n        });\n        await batch.commit();\n      }\n    } catch (error) {\n      console.error('Failed to record view:', error);\n    }\n  }\n\n  /**\n   * 閲覧履歴を取得\n   */\n  async getViewHistory(userId: string, limit: number = 20): Promise<ViewHistory[]> {\n    try {\n      const snapshot = await this.viewHistoryCollection\n        .where('userId', '==', userId)\n        .orderBy('viewedAt', 'desc')\n        .limit(limit)\n        .get();\n\n      const history: ViewHistory[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        history.push({\n          id: doc.id,\n          userId: data.userId,\n          toiletId: data.toiletId,\n          toiletTitle: data.toiletTitle,\n          toiletType: data.toiletType,\n          viewedAt: data.viewedAt.toDate(),\n          viewCount: data.viewCount || 1,\n        });\n      });\n\n      return history;\n    } catch (error) {\n      console.error('Failed to get view history:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 閲覧履歴をクリア\n   */\n  async clearViewHistory(userId: string): Promise<void> {\n    try {\n      const snapshot = await this.viewHistoryCollection.where('userId', '==', userId).get();\n\n      const batch = firestore().batch();\n      snapshot.docs.forEach(doc => {\n        batch.delete(doc.ref);\n      });\n\n      await batch.commit();\n    } catch (error) {\n      console.error('Failed to clear view history:', error);\n      throw new Error('履歴の削除に失敗しました');\n    }\n  }\n\n  /**\n   * お気に入りに追加\n   */\n  async addToFavorites(userId: string, toilet: ToiletLocation): Promise<void> {\n    try {\n      // 既にお気に入りに追加されているかチェック\n      const existing = await this.favoritesCollection\n        .where('userId', '==', userId)\n        .where('toiletId', '==', toilet.id)\n        .get();\n\n      if (!existing.empty) {\n        throw new Error('既にお気に入りに追加されています');\n      }\n\n      const favoriteData: Favorite = {\n        id: this.favoritesCollection.doc().id,\n        userId,\n        toiletId: toilet.id,\n        toiletTitle: toilet.title,\n        toiletType: toilet.type,\n        addedAt: new Date(),\n      };\n\n      await this.favoritesCollection.add({\n        ...favoriteData,\n        addedAt: firestore.Timestamp.now(),\n      });\n\n      // アクティビティを記録\n      await this.recordActivity(\n        userId,\n        ActivityType.FAVORITE_ADDED,\n        toilet.id,\n        toilet.title,\n        `「${toilet.title}」をお気に入りに追加しました`,\n      );\n\n      // ユーザー統計を更新\n      await this.updateUserStats(userId, { totalFavorites: 1 });\n    } catch (error) {\n      console.error('Failed to add to favorites:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * お気に入りから削除\n   */\n  async removeFromFavorites(userId: string, toiletId: string): Promise<void> {\n    try {\n      const snapshot = await this.favoritesCollection\n        .where('userId', '==', userId)\n        .where('toiletId', '==', toiletId)\n        .get();\n\n      if (snapshot.empty) {\n        throw new Error('お気に入りに登録されていません');\n      }\n\n      const batch = firestore().batch();\n      snapshot.docs.forEach(doc => {\n        batch.delete(doc.ref);\n      });\n\n      await batch.commit();\n\n      // ユーザー統計を更新\n      await this.updateUserStats(userId, { totalFavorites: -1 });\n    } catch (error) {\n      console.error('Failed to remove from favorites:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * お気に入り一覧を取得\n   */\n  async getFavorites(userId: string): Promise<Favorite[]> {\n    try {\n      const snapshot = await this.favoritesCollection\n        .where('userId', '==', userId)\n        .orderBy('addedAt', 'desc')\n        .get();\n\n      const favorites: Favorite[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        favorites.push({\n          id: doc.id,\n          userId: data.userId,\n          toiletId: data.toiletId,\n          toiletTitle: data.toiletTitle,\n          toiletType: data.toiletType,\n          addedAt: data.addedAt.toDate(),\n          lastViewed: data.lastViewed?.toDate(),\n        });\n      });\n\n      return favorites;\n    } catch (error) {\n      console.error('Failed to get favorites:', error);\n      return [];\n    }\n  }\n\n  /**\n   * お気に入りかどうかチェック\n   */\n  async isFavorite(userId: string, toiletId: string): Promise<boolean> {\n    try {\n      const snapshot = await this.favoritesCollection\n        .where('userId', '==', userId)\n        .where('toiletId', '==', toiletId)\n        .get();\n\n      return !snapshot.empty;\n    } catch (error) {\n      console.error('Failed to check favorite status:', error);\n      return false;\n    }\n  }\n\n  /**\n   * ユーザーアクティビティを記録\n   */\n  async recordActivity(\n    userId: string,\n    type: ActivityType,\n    targetId: string,\n    targetTitle: string,\n    description: string,\n  ): Promise<void> {\n    try {\n      const activityData: UserActivity = {\n        id: this.activitiesCollection.doc().id,\n        userId,\n        type,\n        targetId,\n        targetTitle,\n        description,\n        createdAt: new Date(),\n      };\n\n      await this.activitiesCollection.add({\n        ...activityData,\n        createdAt: firestore.Timestamp.now(),\n      });\n\n      // 古いアクティビティを削除（最新200件のみ保持）\n      const allActivities = await this.activitiesCollection\n        .where('userId', '==', userId)\n        .orderBy('createdAt', 'desc')\n        .get();\n\n      if (allActivities.docs.length > 200) {\n        const batch = firestore().batch();\n        // 200件より古いものを削除\n        allActivities.docs.slice(200).forEach((doc: any) => {\n          batch.delete(doc.ref);\n        });\n        await batch.commit();\n      }\n    } catch (error) {\n      console.error('Failed to record activity:', error);\n    }\n  }\n\n  /**\n   * ユーザーアクティビティを取得\n   */\n  async getUserActivities(userId: string, limit: number = 50): Promise<UserActivity[]> {\n    try {\n      const snapshot = await this.activitiesCollection\n        .where('userId', '==', userId)\n        .orderBy('createdAt', 'desc')\n        .limit(limit)\n        .get();\n\n      const activities: UserActivity[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        activities.push({\n          id: doc.id,\n          userId: data.userId,\n          type: data.type,\n          targetId: data.targetId,\n          targetTitle: data.targetTitle,\n          description: data.description,\n          createdAt: data.createdAt.toDate(),\n        });\n      });\n\n      return activities;\n    } catch (error) {\n      console.error('Failed to get user activities:', error);\n      return [];\n    }\n  }\n\n  /**\n   * ユーザー統計を取得\n   */\n  async getUserStats(userId: string): Promise<UserStats> {\n    try {\n      const doc = await this.userStatsCollection.doc(userId).get();\n\n      if (!doc.exists) {\n        // 初期統計データを作成\n        const initialStats: UserStats = {\n          userId,\n          totalPosts: 0,\n          totalViews: 0,\n          totalFavorites: 0,\n          totalHelpfulVotes: 0,\n          totalBadges: 0,\n          joinedAt: new Date(),\n          lastActiveAt: new Date(),\n          streak: 0,\n        };\n\n        await this.userStatsCollection.doc(userId).set({\n          ...initialStats,\n          joinedAt: firestore.Timestamp.now(),\n          lastActiveAt: firestore.Timestamp.now(),\n        });\n\n        return initialStats;\n      }\n\n      const data = doc.data()!;\n      return {\n        userId: data.userId,\n        totalPosts: data.totalPosts || 0,\n        totalViews: data.totalViews || 0,\n        totalFavorites: data.totalFavorites || 0,\n        totalHelpfulVotes: data.totalHelpfulVotes || 0,\n        totalBadges: data.totalBadges || 0,\n        joinedAt: data.joinedAt?.toDate() || new Date(),\n        lastActiveAt: data.lastActiveAt?.toDate() || new Date(),\n        streak: data.streak || 0,\n      };\n    } catch (error) {\n      console.error('Failed to get user stats:', error);\n      throw new Error('統計情報の取得に失敗しました');\n    }\n  }\n\n  /**\n   * ユーザー統計を更新\n   */\n  async updateUserStats(\n    userId: string,\n    updates: Partial<Omit<UserStats, 'userId' | 'joinedAt'>>,\n  ): Promise<void> {\n    try {\n      const currentStats = await this.getUserStats(userId);\n\n      const updatedStats = {\n        totalPosts: Math.max(0, currentStats.totalPosts + (updates.totalPosts || 0)),\n        totalViews: Math.max(0, currentStats.totalViews + (updates.totalViews || 0)),\n        totalFavorites: Math.max(0, currentStats.totalFavorites + (updates.totalFavorites || 0)),\n        totalHelpfulVotes: Math.max(\n          0,\n          currentStats.totalHelpfulVotes + (updates.totalHelpfulVotes || 0),\n        ),\n        totalBadges: Math.max(0, currentStats.totalBadges + (updates.totalBadges || 0)),\n        lastActiveAt: firestore.Timestamp.now(),\n        ...(updates.streak !== undefined && { streak: updates.streak }),\n      };\n\n      await this.userStatsCollection.doc(userId).update(updatedStats);\n    } catch (error) {\n      console.error('Failed to update user stats:', error);\n    }\n  }\n\n  /**\n   * 最近のアクティビティを取得（複数ユーザー）\n   */\n  async getRecentActivities(limit: number = 20): Promise<UserActivity[]> {\n    try {\n      const snapshot = await this.activitiesCollection\n        .orderBy('createdAt', 'desc')\n        .limit(limit)\n        .get();\n\n      const activities: UserActivity[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        activities.push({\n          id: doc.id,\n          userId: data.userId,\n          type: data.type,\n          targetId: data.targetId,\n          targetTitle: data.targetTitle,\n          description: data.description,\n          createdAt: data.createdAt.toDate(),\n        });\n      });\n\n      return activities;\n    } catch (error) {\n      console.error('Failed to get recent activities:', error);\n      return [];\n    }\n  }\n\n  /**\n   * よく見るトイレを取得\n   */\n  async getFrequentlyViewed(userId: string, limit: number = 10): Promise<ViewHistory[]> {\n    try {\n      const snapshot = await this.viewHistoryCollection\n        .where('userId', '==', userId)\n        .orderBy('viewCount', 'desc')\n        .limit(limit)\n        .get();\n\n      const history: ViewHistory[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        history.push({\n          id: doc.id,\n          userId: data.userId,\n          toiletId: data.toiletId,\n          toiletTitle: data.toiletTitle,\n          toiletType: data.toiletType,\n          viewedAt: data.viewedAt.toDate(),\n          viewCount: data.viewCount || 1,\n        });\n      });\n\n      return history;\n    } catch (error) {\n      console.error('Failed to get frequently viewed:', error);\n      return [];\n    }\n  }\n}\n\n// シングルトンインスタンス\nexport const historyService = new HistoryService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/notificationService.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":23,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":23,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[908,959],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":33,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":33,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1281,1335],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5084,5087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5084,5087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":356,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":356,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9706,9709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9706,9709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":370,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10033,10036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10033,10036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":371,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":371,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10050,10101],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":380,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":380,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10311,10363],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":383,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":383,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10419,10469],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":386,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":386,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10514,10553],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":394,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10688,10691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10688,10691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":396,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":396,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10758,10816],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import messaging from '@react-native-firebase/messaging';\nimport firestore from '@react-native-firebase/firestore';\nimport { Platform, PermissionsAndroid } from 'react-native';\nimport { PushNotification, NotificationSettings, PushToken, NotificationType } from '../types/post';\n\nexport class NotificationService {\n  private notificationsCollection = firestore().collection('push_notifications');\n  private settingsCollection = firestore().collection('notification_settings');\n  private tokensCollection = firestore().collection('push_tokens');\n\n  /**\n   * プッシュ通知の初期化\n   */\n  async initialize(userId: string): Promise<void> {\n    try {\n      // 通知権限の確認・リクエスト\n      const authStatus = await messaging().requestPermission();\n      const enabled =\n        authStatus === messaging.AuthorizationStatus.AUTHORIZED ||\n        authStatus === messaging.AuthorizationStatus.PROVISIONAL;\n\n      if (!enabled) {\n        console.log('Push notification permission denied');\n        return;\n      }\n\n      // Android 13以降の追加権限確認\n      if (Platform.OS === 'android' && Platform.Version >= 33) {\n        const granted = await PermissionsAndroid.request(\n          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,\n        );\n        if (granted !== PermissionsAndroid.RESULTS.GRANTED) {\n          console.log('Android notification permission denied');\n          return;\n        }\n      }\n\n      // FCMトークンの取得・保存\n      const token = await messaging().getToken();\n      await this.savePushToken(userId, token);\n\n      // トークン更新の監視\n      messaging().onTokenRefresh(async newToken => {\n        await this.savePushToken(userId, newToken);\n      });\n\n      // フォアグラウンド通知の設定\n      messaging().onMessage(async remoteMessage => {\n        await this.handleForegroundMessage(remoteMessage);\n      });\n\n      // バックグラウンド通知の設定（index.jsで設定済みのはず）\n      messaging().onNotificationOpenedApp(remoteMessage => {\n        this.handleNotificationOpen(remoteMessage);\n      });\n\n      // アプリ起動時の通知チェック\n      messaging()\n        .getInitialNotification()\n        .then(remoteMessage => {\n          if (remoteMessage) {\n            this.handleNotificationOpen(remoteMessage);\n          }\n        });\n    } catch (error) {\n      console.error('Failed to initialize notifications:', error);\n    }\n  }\n\n  /**\n   * プッシュトークンの保存\n   */\n  async savePushToken(userId: string, token: string): Promise<void> {\n    try {\n      const tokenData: PushToken = {\n        userId,\n        token,\n        platform: Platform.OS as 'ios' | 'android',\n        isActive: true,\n        lastUsed: new Date(),\n        createdAt: new Date(),\n      };\n\n      // 既存のトークンを無効化\n      await this.tokensCollection\n        .where('userId', '==', userId)\n        .where('platform', '==', Platform.OS)\n        .get()\n        .then(snapshot => {\n          const batch = firestore().batch();\n          snapshot.docs.forEach(doc => {\n            batch.update(doc.ref, { isActive: false });\n          });\n          return batch.commit();\n        });\n\n      // 新しいトークンを保存\n      await this.tokensCollection.add({\n        ...tokenData,\n        lastUsed: firestore.Timestamp.now(),\n        createdAt: firestore.Timestamp.now(),\n      });\n    } catch (error) {\n      console.error('Failed to save push token:', error);\n    }\n  }\n\n  /**\n   * 通知設定の取得\n   */\n  async getNotificationSettings(userId: string): Promise<NotificationSettings> {\n    try {\n      const doc = await this.settingsCollection.doc(userId).get();\n\n      if (!doc.exists) {\n        // デフォルト設定を作成\n        const defaultSettings: NotificationSettings = {\n          userId,\n          enabled: true,\n          badgeNotifications: true,\n          helpfulVoteNotifications: true,\n          nearbyToiletNotifications: true,\n          updateNotifications: true,\n          newsNotifications: true,\n          summaryNotifications: false,\n          reminderNotifications: true,\n          quietHoursEnabled: false,\n          quietHoursStart: '22:00',\n          quietHoursEnd: '08:00',\n          updatedAt: new Date(),\n        };\n\n        await this.settingsCollection.doc(userId).set({\n          ...defaultSettings,\n          updatedAt: firestore.Timestamp.now(),\n        });\n\n        return defaultSettings;\n      }\n\n      const data = doc.data()!;\n      return {\n        ...data,\n        updatedAt: data.updatedAt?.toDate() || new Date(),\n      } as NotificationSettings;\n    } catch (error) {\n      console.error('Failed to get notification settings:', error);\n      throw new Error('通知設定の取得に失敗しました');\n    }\n  }\n\n  /**\n   * 通知設定の更新\n   */\n  async updateNotificationSettings(\n    userId: string,\n    updates: Partial<NotificationSettings>,\n  ): Promise<void> {\n    try {\n      await this.settingsCollection.doc(userId).update({\n        ...updates,\n        updatedAt: firestore.Timestamp.now(),\n      });\n    } catch (error) {\n      console.error('Failed to update notification settings:', error);\n      throw new Error('通知設定の更新に失敗しました');\n    }\n  }\n\n  /**\n   * 通知の送信（サーバーサイド用）\n   */\n  async sendNotification(\n    userId: string,\n    type: NotificationType,\n    title: string,\n    body: string,\n    data?: Record<string, any>,\n  ): Promise<void> {\n    try {\n      // 通知設定をチェック\n      const settings = await this.getNotificationSettings(userId);\n      if (!settings.enabled || !this.shouldSendNotification(type, settings)) {\n        return;\n      }\n\n      // サイレント時間のチェック\n      if (this.isInQuietHours(settings)) {\n        return;\n      }\n\n      // 通知データを保存\n      const notification: PushNotification = {\n        id: firestore().collection('push_notifications').doc().id,\n        userId,\n        type,\n        title,\n        body,\n        data,\n        isRead: false,\n        createdAt: new Date(),\n      };\n\n      await this.notificationsCollection.add({\n        ...notification,\n        createdAt: firestore.Timestamp.now(),\n      });\n\n      // 実際のプッシュ通知送信（Cloud Functionsで処理）\n      // ここではローカル通知として表示\n      this.showLocalNotification(title, body, data);\n    } catch (error) {\n      console.error('Failed to send notification:', error);\n    }\n  }\n\n  /**\n   * ユーザーの通知履歴を取得\n   */\n  async getUserNotifications(userId: string, limit: number = 20): Promise<PushNotification[]> {\n    try {\n      const snapshot = await this.notificationsCollection\n        .where('userId', '==', userId)\n        .orderBy('createdAt', 'desc')\n        .limit(limit)\n        .get();\n\n      const notifications: PushNotification[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        notifications.push({\n          id: doc.id,\n          userId: data.userId,\n          type: data.type,\n          title: data.title,\n          body: data.body,\n          data: data.data,\n          isRead: data.isRead,\n          createdAt: data.createdAt.toDate(),\n          scheduledAt: data.scheduledAt?.toDate(),\n        });\n      });\n\n      return notifications;\n    } catch (error) {\n      console.error('Failed to get user notifications:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 通知を既読にする\n   */\n  async markAsRead(notificationId: string): Promise<void> {\n    try {\n      await this.notificationsCollection.doc(notificationId).update({\n        isRead: true,\n      });\n    } catch (error) {\n      console.error('Failed to mark notification as read:', error);\n    }\n  }\n\n  /**\n   * 全通知を既読にする\n   */\n  async markAllAsRead(userId: string): Promise<void> {\n    try {\n      const snapshot = await this.notificationsCollection\n        .where('userId', '==', userId)\n        .where('isRead', '==', false)\n        .get();\n\n      const batch = firestore().batch();\n      snapshot.docs.forEach(doc => {\n        batch.update(doc.ref, { isRead: true });\n      });\n\n      await batch.commit();\n    } catch (error) {\n      console.error('Failed to mark all notifications as read:', error);\n    }\n  }\n\n  /**\n   * 未読通知数の取得\n   */\n  async getUnreadCount(userId: string): Promise<number> {\n    try {\n      const snapshot = await this.notificationsCollection\n        .where('userId', '==', userId)\n        .where('isRead', '==', false)\n        .get();\n\n      return snapshot.size;\n    } catch (error) {\n      console.error('Failed to get unread count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * 特定のタイプの通知を送信すべきかチェック\n   */\n  private shouldSendNotification(type: NotificationType, settings: NotificationSettings): boolean {\n    switch (type) {\n      case NotificationType.BADGE_UNLOCKED:\n        return settings.badgeNotifications;\n      case NotificationType.HELPFUL_VOTE:\n        return settings.helpfulVoteNotifications;\n      case NotificationType.NEW_TOILET_NEARBY:\n        return settings.nearbyToiletNotifications;\n      case NotificationType.TOILET_UPDATED:\n        return settings.updateNotifications;\n      case NotificationType.COMMUNITY_NEWS:\n        return settings.newsNotifications;\n      case NotificationType.WEEKLY_SUMMARY:\n        return settings.summaryNotifications;\n      case NotificationType.ACHIEVEMENT_REMINDER:\n        return settings.reminderNotifications;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * サイレント時間かどうかチェック\n   */\n  private isInQuietHours(settings: NotificationSettings): boolean {\n    if (!settings.quietHoursEnabled) {\n      return false;\n    }\n\n    const now = new Date();\n    const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now\n      .getMinutes()\n      .toString()\n      .padStart(2, '0')}`;\n\n    const start = settings.quietHoursStart;\n    const end = settings.quietHoursEnd;\n\n    // 日をまたぐ場合（例: 22:00 - 08:00）\n    if (start > end) {\n      return currentTime >= start || currentTime <= end;\n    }\n    // 同日内の場合（例: 08:00 - 22:00）\n    else {\n      return currentTime >= start && currentTime <= end;\n    }\n  }\n\n  /**\n   * フォアグラウンド通知の処理\n   */\n  private async handleForegroundMessage(remoteMessage: any): Promise<void> {\n    // フォアグラウンドでもローカル通知を表示\n    if (remoteMessage.notification) {\n      this.showLocalNotification(\n        remoteMessage.notification.title,\n        remoteMessage.notification.body,\n        remoteMessage.data,\n      );\n    }\n  }\n\n  /**\n   * 通知タップ時の処理\n   */\n  private handleNotificationOpen(remoteMessage: any): void {\n    console.log('Notification opened:', remoteMessage);\n\n    // データに基づいて画面遷移を行う\n    if (remoteMessage.data) {\n      const { screen, toiletId, badgeId } = remoteMessage.data;\n\n      // ナビゲーション処理（実装は簡略化）\n      switch (screen) {\n        case 'ToiletDetail':\n          console.log('Navigate to toilet detail:', toiletId);\n          break;\n        case 'BadgeScreen':\n          console.log('Navigate to badge screen:', badgeId);\n          break;\n        default:\n          console.log('Navigate to home screen');\n      }\n    }\n  }\n\n  /**\n   * ローカル通知の表示（デモ用）\n   */\n  private showLocalNotification(title: string, body: string, data?: Record<string, any>): void {\n    // 実際の実装では react-native-push-notification などを使用\n    console.log('Local notification:', { title, body, data });\n  }\n\n  /**\n   * バッジ取得通知\n   */\n  async sendBadgeUnlockedNotification(\n    userId: string,\n    badgeName: string,\n    badgeId: string,\n  ): Promise<void> {\n    await this.sendNotification(\n      userId,\n      NotificationType.BADGE_UNLOCKED,\n      '🎉 新しいバッジを取得！',\n      `「${badgeName}」バッジを取得しました`,\n      { screen: 'BadgeScreen', badgeId },\n    );\n  }\n\n  /**\n   * 「役に立った」投票通知\n   */\n  async sendHelpfulVoteNotification(\n    userId: string,\n    toiletTitle: string,\n    toiletId: string,\n  ): Promise<void> {\n    await this.sendNotification(\n      userId,\n      NotificationType.HELPFUL_VOTE,\n      '👍 役に立ったと評価されました',\n      `「${toiletTitle}」の投稿が役に立ったと評価されました`,\n      { screen: 'ToiletDetail', toiletId },\n    );\n  }\n\n  /**\n   * 近くの新しいトイレ通知\n   */\n  async sendNearbyToiletNotification(\n    userId: string,\n    toiletTitle: string,\n    toiletId: string,\n  ): Promise<void> {\n    await this.sendNotification(\n      userId,\n      NotificationType.NEW_TOILET_NEARBY,\n      '🚻 近くに新しいトイレが追加されました',\n      `「${toiletTitle}」があなたの近くに追加されました`,\n      { screen: 'ToiletDetail', toiletId },\n    );\n  }\n}\n\n// シングルトンインスタンス\nexport const notificationService = new NotificationService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/reportService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":295,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7709,7712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7709,7712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import firestore from '@react-native-firebase/firestore';\nimport {\n  Report,\n  ReportTargetType,\n  ReportReason,\n  ReportStatus,\n  UserRestriction,\n  RestrictionType,\n  ViolationRecord,\n  ViolationType,\n  ViolationSeverity,\n  AutoRestrictionConfig,\n} from '../types/post';\n\nexport class ReportService {\n  private reportsCollection = firestore().collection('reports');\n  private restrictionsCollection = firestore().collection('user_restrictions');\n  private violationsCollection = firestore().collection('violation_records');\n  private configCollection = firestore().collection('system_config');\n\n  // 自動制限設定（デフォルト値）\n  private defaultConfig: AutoRestrictionConfig = {\n    maxViolationPoints: 20,\n    pointExpirationDays: 30,\n    restrictions: {\n      3: {\n        type: RestrictionType.WARNING,\n        message:\n          '軽微な違反が検出されました。今後はコミュニティガイドラインに従ってご利用ください。',\n      },\n      5: {\n        type: RestrictionType.POST_RESTRICTION,\n        durationDays: 1,\n        message: '1日間の投稿制限が適用されました。',\n      },\n      8: {\n        type: RestrictionType.POST_RESTRICTION,\n        durationDays: 3,\n        message: '3日間の投稿制限が適用されました。',\n      },\n      12: {\n        type: RestrictionType.TEMPORARY_BAN,\n        durationDays: 7,\n        message: '7日間の利用停止が適用されました。',\n      },\n      20: {\n        type: RestrictionType.PERMANENT_BAN,\n        message: 'アカウントが永久停止されました。',\n      },\n    },\n  };\n\n  /**\n   * 通報を送信\n   */\n  async submitReport(\n    reporterId: string,\n    targetType: ReportTargetType,\n    targetId: string,\n    reason: ReportReason,\n    description?: string,\n    evidence?: string[],\n  ): Promise<void> {\n    try {\n      // 同じ対象に対する重複通報をチェック\n      const existingReport = await this.reportsCollection\n        .where('reporterId', '==', reporterId)\n        .where('targetType', '==', targetType)\n        .where('targetId', '==', targetId)\n        .where('status', 'in', [ReportStatus.PENDING, ReportStatus.UNDER_REVIEW])\n        .get();\n\n      if (!existingReport.empty) {\n        throw new Error('この対象は既に通報済みです');\n      }\n\n      const reportData: Report = {\n        id: this.reportsCollection.doc().id,\n        reporterId,\n        targetType,\n        targetId,\n        reason,\n        description,\n        evidence,\n        status: ReportStatus.PENDING,\n        createdAt: new Date(),\n      };\n\n      await this.reportsCollection.add({\n        ...reportData,\n        createdAt: firestore.Timestamp.now(),\n      });\n\n      // 自動検出ロジックの実行\n      await this.processAutoDetection(targetType, targetId, reason);\n    } catch (error) {\n      console.error('Failed to submit report:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 通報一覧を取得（管理者用）\n   */\n  async getReports(status?: ReportStatus, limit: number = 50): Promise<Report[]> {\n    try {\n      let query = this.reportsCollection.orderBy('createdAt', 'desc');\n\n      if (status) {\n        query = query.where('status', '==', status);\n      }\n\n      const snapshot = await query.limit(limit).get();\n\n      const reports: Report[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        reports.push({\n          id: doc.id,\n          reporterId: data.reporterId,\n          targetType: data.targetType,\n          targetId: data.targetId,\n          reason: data.reason,\n          description: data.description,\n          evidence: data.evidence,\n          status: data.status,\n          createdAt: data.createdAt.toDate(),\n          reviewedAt: data.reviewedAt?.toDate(),\n          reviewerId: data.reviewerId,\n          resolution: data.resolution,\n        });\n      });\n\n      return reports;\n    } catch (error) {\n      console.error('Failed to get reports:', error);\n      return [];\n    }\n  }\n\n  /**\n   * ユーザーの通報履歴を取得\n   */\n  async getUserReports(userId: string): Promise<Report[]> {\n    try {\n      const snapshot = await this.reportsCollection\n        .where('reporterId', '==', userId)\n        .orderBy('createdAt', 'desc')\n        .limit(20)\n        .get();\n\n      const reports: Report[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        reports.push({\n          id: doc.id,\n          reporterId: data.reporterId,\n          targetType: data.targetType,\n          targetId: data.targetId,\n          reason: data.reason,\n          description: data.description,\n          evidence: data.evidence,\n          status: data.status,\n          createdAt: data.createdAt.toDate(),\n          reviewedAt: data.reviewedAt?.toDate(),\n          reviewerId: data.reviewerId,\n          resolution: data.resolution,\n        });\n      });\n\n      return reports;\n    } catch (error) {\n      console.error('Failed to get user reports:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 違反記録を追加\n   */\n  async addViolationRecord(\n    userId: string,\n    type: ViolationType,\n    severity: ViolationSeverity,\n    description: string,\n    evidence?: string[],\n    reportId?: string,\n    autoDetected: boolean = false,\n  ): Promise<void> {\n    try {\n      const points = this.getViolationPoints(severity);\n      const expiresAt = new Date();\n      expiresAt.setDate(expiresAt.getDate() + this.defaultConfig.pointExpirationDays);\n\n      const violationData: ViolationRecord = {\n        id: this.violationsCollection.doc().id,\n        userId,\n        type,\n        severity,\n        description,\n        evidence,\n        reportId,\n        autoDetected,\n        points,\n        createdAt: new Date(),\n        expiresAt,\n      };\n\n      await this.violationsCollection.add({\n        ...violationData,\n        createdAt: firestore.Timestamp.now(),\n        expiresAt: firestore.Timestamp.fromDate(expiresAt),\n      });\n\n      // 自動制限判定\n      await this.checkAndApplyRestrictions(userId);\n    } catch (error) {\n      console.error('Failed to add violation record:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * ユーザーの違反ポイントを計算\n   */\n  async getUserViolationPoints(userId: string): Promise<number> {\n    try {\n      const snapshot = await this.violationsCollection\n        .where('userId', '==', userId)\n        .where('expiresAt', '>', firestore.Timestamp.now())\n        .get();\n\n      let totalPoints = 0;\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        totalPoints += data.points || 0;\n      });\n\n      return totalPoints;\n    } catch (error) {\n      console.error('Failed to get user violation points:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * ユーザーの制限状況を取得\n   */\n  async getUserRestrictions(userId: string): Promise<UserRestriction[]> {\n    try {\n      const snapshot = await this.restrictionsCollection\n        .where('userId', '==', userId)\n        .where('isActive', '==', true)\n        .orderBy('startDate', 'desc')\n        .get();\n\n      const restrictions: UserRestriction[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        restrictions.push({\n          id: doc.id,\n          userId: data.userId,\n          type: data.type,\n          reason: data.reason,\n          startDate: data.startDate.toDate(),\n          endDate: data.endDate?.toDate(),\n          isActive: data.isActive,\n          createdBy: data.createdBy,\n          details: data.details,\n        });\n      });\n\n      // 期限切れの制限を無効化\n      for (const restriction of restrictions) {\n        if (restriction.endDate && restriction.endDate < new Date()) {\n          await this.deactivateRestriction(restriction.id);\n        }\n      }\n\n      return restrictions.filter(r => !r.endDate || r.endDate > new Date());\n    } catch (error) {\n      console.error('Failed to get user restrictions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 制限を適用\n   */\n  private async applyRestriction(\n    userId: string,\n    type: RestrictionType,\n    reason: string,\n    durationDays?: number,\n    details?: Record<string, any>,\n  ): Promise<void> {\n    try {\n      const startDate = new Date();\n      const endDate = durationDays\n        ? new Date(startDate.getTime() + durationDays * 24 * 60 * 60 * 1000)\n        : undefined;\n\n      const restrictionData: UserRestriction = {\n        id: this.restrictionsCollection.doc().id,\n        userId,\n        type,\n        reason,\n        startDate,\n        endDate,\n        isActive: true,\n        createdBy: 'system',\n        details,\n      };\n\n      await this.restrictionsCollection.add({\n        ...restrictionData,\n        startDate: firestore.Timestamp.fromDate(startDate),\n        endDate: endDate ? firestore.Timestamp.fromDate(endDate) : null,\n      });\n\n      // TODO: プッシュ通知でユーザーに制限を通知\n    } catch (error) {\n      console.error('Failed to apply restriction:', error);\n    }\n  }\n\n  /**\n   * 制限を無効化\n   */\n  private async deactivateRestriction(restrictionId: string): Promise<void> {\n    try {\n      await this.restrictionsCollection.doc(restrictionId).update({\n        isActive: false,\n      });\n    } catch (error) {\n      console.error('Failed to deactivate restriction:', error);\n    }\n  }\n\n  /**\n   * 自動制限判定と適用\n   */\n  private async checkAndApplyRestrictions(userId: string): Promise<void> {\n    try {\n      const violationPoints = await this.getUserViolationPoints(userId);\n\n      // 設定された制限ポイントを降順でチェック\n      const restrictionPoints = Object.keys(this.defaultConfig.restrictions)\n        .map(Number)\n        .sort((a, b) => b - a);\n\n      for (const points of restrictionPoints) {\n        if (violationPoints >= points) {\n          const config = this.defaultConfig.restrictions[points];\n\n          // 既に同じタイプの制限が適用されているかチェック\n          const existingRestrictions = await this.getUserRestrictions(userId);\n          const hasExistingRestriction = existingRestrictions.some(r => r.type === config.type);\n\n          if (!hasExistingRestriction) {\n            await this.applyRestriction(userId, config.type, config.message, config.durationDays, {\n              violationPoints,\n              triggerPoints: points,\n            });\n          }\n          break;\n        }\n      }\n    } catch (error) {\n      console.error('Failed to check and apply restrictions:', error);\n    }\n  }\n\n  /**\n   * 自動検出処理\n   */\n  private async processAutoDetection(\n    targetType: ReportTargetType,\n    targetId: string,\n    reason: ReportReason,\n  ): Promise<void> {\n    try {\n      // 同じ対象への通報数をカウント\n      const reportCount = await this.getReportCountForTarget(targetType, targetId);\n\n      // 通報数が一定以上の場合、自動的に違反とみなす\n      if (reportCount >= 3) {\n        // 対象のオーナーを特定して違反記録を追加\n        const ownerId = await this.getTargetOwnerId(targetType, targetId);\n        if (ownerId) {\n          let violationType: ViolationType;\n          let severity: ViolationSeverity;\n\n          switch (reason) {\n            case ReportReason.SPAM:\n            case ReportReason.COMMERCIAL_SPAM:\n              violationType = ViolationType.SPAM_POSTING;\n              severity = ViolationSeverity.MEDIUM;\n              break;\n            case ReportReason.INAPPROPRIATE_CONTENT:\n              violationType = ViolationType.INAPPROPRIATE_CONTENT;\n              severity = ViolationSeverity.HIGH;\n              break;\n            case ReportReason.HARASSMENT:\n            case ReportReason.HATE_SPEECH:\n              violationType = ViolationType.HARASSMENT;\n              severity = ViolationSeverity.HIGH;\n              break;\n            case ReportReason.FAKE_INFORMATION:\n              violationType = ViolationType.FAKE_INFORMATION;\n              severity = ViolationSeverity.MEDIUM;\n              break;\n            default:\n              violationType = ViolationType.INAPPROPRIATE_CONTENT;\n              severity = ViolationSeverity.LOW;\n          }\n\n          await this.addViolationRecord(\n            ownerId,\n            violationType,\n            severity,\n            `複数の通報により自動検出: ${reason}`,\n            undefined,\n            undefined,\n            true,\n          );\n        }\n      }\n    } catch (error) {\n      console.error('Failed to process auto detection:', error);\n    }\n  }\n\n  /**\n   * 対象への通報数を取得\n   */\n  private async getReportCountForTarget(\n    targetType: ReportTargetType,\n    targetId: string,\n  ): Promise<number> {\n    try {\n      const snapshot = await this.reportsCollection\n        .where('targetType', '==', targetType)\n        .where('targetId', '==', targetId)\n        .where('status', '!=', ReportStatus.DISMISSED)\n        .get();\n\n      return snapshot.size;\n    } catch (error) {\n      console.error('Failed to get report count:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * 対象のオーナーIDを取得\n   */\n  private async getTargetOwnerId(\n    targetType: ReportTargetType,\n    targetId: string,\n  ): Promise<string | null> {\n    try {\n      let collection: string;\n      switch (targetType) {\n        case ReportTargetType.TOILET:\n          collection = 'toilets';\n          break;\n        case ReportTargetType.REVIEW:\n          collection = 'reviews';\n          break;\n        case ReportTargetType.COMMENT:\n          collection = 'comments';\n          break;\n        case ReportTargetType.USER:\n          return targetId; // ユーザー自身\n        default:\n          return null;\n      }\n\n      const doc = await firestore().collection(collection).doc(targetId).get();\n\n      if (doc.exists()) {\n        const data = doc.data()!;\n        return data.userId || data.authorId || null;\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Failed to get target owner ID:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 違反ポイントを取得\n   */\n  private getViolationPoints(severity: ViolationSeverity): number {\n    switch (severity) {\n      case ViolationSeverity.LOW:\n        return 1;\n      case ViolationSeverity.MEDIUM:\n        return 3;\n      case ViolationSeverity.HIGH:\n        return 6;\n      case ViolationSeverity.CRITICAL:\n        return 12;\n      default:\n        return 1;\n    }\n  }\n\n  /**\n   * ユーザーが制限されているかチェック\n   */\n  async isUserRestricted(\n    userId: string,\n    action: 'post' | 'comment' | 'review' | 'vote',\n  ): Promise<{ restricted: boolean; reason?: string; endDate?: Date }> {\n    try {\n      const restrictions = await this.getUserRestrictions(userId);\n\n      for (const restriction of restrictions) {\n        let isApplicable = false;\n\n        switch (action) {\n          case 'post':\n            isApplicable = [\n              RestrictionType.POST_RESTRICTION,\n              RestrictionType.TEMPORARY_BAN,\n              RestrictionType.PERMANENT_BAN,\n            ].includes(restriction.type);\n            break;\n          case 'comment':\n            isApplicable = [\n              RestrictionType.COMMENT_RESTRICTION,\n              RestrictionType.TEMPORARY_BAN,\n              RestrictionType.PERMANENT_BAN,\n            ].includes(restriction.type);\n            break;\n          case 'review':\n            isApplicable = [\n              RestrictionType.REVIEW_RESTRICTION,\n              RestrictionType.TEMPORARY_BAN,\n              RestrictionType.PERMANENT_BAN,\n            ].includes(restriction.type);\n            break;\n          case 'vote':\n            isApplicable = [\n              RestrictionType.VOTE_RESTRICTION,\n              RestrictionType.TEMPORARY_BAN,\n              RestrictionType.PERMANENT_BAN,\n            ].includes(restriction.type);\n            break;\n        }\n\n        if (isApplicable) {\n          return {\n            restricted: true,\n            reason: restriction.reason,\n            endDate: restriction.endDate,\n          };\n        }\n      }\n\n      return { restricted: false };\n    } catch (error) {\n      console.error('Failed to check user restriction:', error);\n      return { restricted: false };\n    }\n  }\n}\n\n// シングルトンインスタンス\nexport const reportService = new ReportService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/services/searchService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":341,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9655,9658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9655,9658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import firestore from '@react-native-firebase/firestore';\nimport { ToiletLocation } from '../types/maps';\nimport { SearchFilters, SearchResult, SortOption, SavedSearch, SearchHistory } from '../types/post';\n\nexport class SearchService {\n  private toiletsCollection = firestore().collection('toilets');\n  private savedSearchesCollection = firestore().collection('saved_searches');\n  private searchHistoryCollection = firestore().collection('search_history');\n\n  /**\n   * トイレを検索\n   */\n  async searchToilets(\n    filters: SearchFilters,\n    userLocation?: { latitude: number; longitude: number },\n    limit: number = 20,\n    offset: number = 0,\n  ): Promise<SearchResult> {\n    const startTime = Date.now();\n\n    try {\n      let query = this.toiletsCollection.where('isActive', '==', true);\n\n      // テキスト検索（タイトルと説明）\n      if (filters.query.trim()) {\n        // Firestoreの制限により、クライアントサイドでフィルタリング\n        // 実際の実装では Algolia や ElasticSearch を推奨\n        const allToilets = await this.getAllActiveToilets();\n        const filteredToilets = this.filterByText(allToilets, filters.query);\n        const finalResults = this.applyFilters(filteredToilets, filters, userLocation);\n        const sortedResults = this.sortResults(finalResults, filters.sortBy, userLocation);\n\n        const paginatedResults = sortedResults.slice(offset, offset + limit);\n\n        return {\n          toilets: paginatedResults,\n          totalCount: sortedResults.length,\n          hasMore: offset + limit < sortedResults.length,\n          searchTime: Date.now() - startTime,\n        };\n      }\n\n      // フィルター条件の適用\n      if (filters.toiletType) {\n        query = query.where('type', '==', filters.toiletType);\n      }\n\n      if (filters.isAccessible !== undefined) {\n        query = query.where('isAccessible', '==', filters.isAccessible);\n      }\n\n      if (filters.rating !== undefined) {\n        query = query.where('rating', '>=', filters.rating);\n      }\n\n      // データ取得\n      let snapshot;\n      switch (filters.sortBy) {\n        case SortOption.RATING:\n          snapshot = await query\n            .orderBy('rating', 'desc')\n            .limit(limit + offset)\n            .get();\n          break;\n        case SortOption.NEWEST:\n          snapshot = await query\n            .orderBy('createdAt', 'desc')\n            .limit(limit + offset)\n            .get();\n          break;\n        case SortOption.HELPFUL:\n          snapshot = await query\n            .orderBy('reviewCount', 'desc')\n            .limit(limit + offset)\n            .get();\n          break;\n        default:\n          snapshot = await query.limit(limit + offset).get();\n      }\n\n      const allResults: ToiletLocation[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        allResults.push({\n          id: data.id,\n          title: data.title,\n          description: data.description,\n          latitude: data.location.latitude,\n          longitude: data.location.longitude,\n          type: data.type,\n          isAccessible: data.isAccessible,\n          rating: data.rating,\n          reviewCount: data.reviewCount,\n          createdBy: data.createdBy,\n          createdAt: data.createdAt.toDate(),\n          updatedAt: data.updatedAt.toDate(),\n        });\n      });\n\n      // 追加フィルタリング\n      const filteredResults = this.applyAdditionalFilters(allResults, filters, userLocation);\n\n      // 距離ソートの場合はクライアントサイドで処理\n      const sortedResults =\n        filters.sortBy === SortOption.DISTANCE && userLocation\n          ? this.sortByDistance(filteredResults, userLocation)\n          : filteredResults;\n\n      const paginatedResults = sortedResults.slice(offset, offset + limit);\n\n      return {\n        toilets: paginatedResults,\n        totalCount: sortedResults.length,\n        hasMore: offset + limit < sortedResults.length,\n        searchTime: Date.now() - startTime,\n      };\n    } catch (error) {\n      console.error('Failed to search toilets:', error);\n      return {\n        toilets: [],\n        totalCount: 0,\n        hasMore: false,\n        searchTime: Date.now() - startTime,\n      };\n    }\n  }\n\n  /**\n   * 全てのアクティブなトイレを取得（テキスト検索用）\n   */\n  private async getAllActiveToilets(): Promise<ToiletLocation[]> {\n    const snapshot = await this.toiletsCollection.where('isActive', '==', true).get();\n\n    const toilets: ToiletLocation[] = [];\n    snapshot.forEach(doc => {\n      const data = doc.data();\n      toilets.push({\n        id: data.id,\n        title: data.title,\n        description: data.description,\n        latitude: data.location.latitude,\n        longitude: data.location.longitude,\n        type: data.type,\n        isAccessible: data.isAccessible,\n        rating: data.rating,\n        reviewCount: data.reviewCount,\n        createdBy: data.createdBy,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      });\n    });\n\n    return toilets;\n  }\n\n  /**\n   * テキストによるフィルタリング\n   */\n  private filterByText(toilets: ToiletLocation[], query: string): ToiletLocation[] {\n    const lowerQuery = query.toLowerCase();\n    return toilets.filter(\n      toilet =>\n        toilet.title.toLowerCase().includes(lowerQuery) ||\n        (toilet.description && toilet.description.toLowerCase().includes(lowerQuery)),\n    );\n  }\n\n  /**\n   * フィルター条件の適用\n   */\n  private applyFilters(\n    toilets: ToiletLocation[],\n    filters: SearchFilters,\n    userLocation?: { latitude: number; longitude: number },\n  ): ToiletLocation[] {\n    return toilets.filter(toilet => {\n      // トイレタイプ\n      if (filters.toiletType && toilet.type !== filters.toiletType) {\n        return false;\n      }\n\n      // バリアフリー\n      if (filters.isAccessible !== undefined && toilet.isAccessible !== filters.isAccessible) {\n        return false;\n      }\n\n      // 評価\n      if (filters.rating !== undefined && toilet.rating && toilet.rating < filters.rating) {\n        return false;\n      }\n\n      // 距離\n      if (filters.distance && userLocation) {\n        const distance = this.calculateDistance(\n          userLocation.latitude,\n          userLocation.longitude,\n          toilet.latitude,\n          toilet.longitude,\n        );\n        if (distance > filters.distance) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * 追加フィルターの適用\n   */\n  private applyAdditionalFilters(\n    toilets: ToiletLocation[],\n    filters: SearchFilters,\n    userLocation?: { latitude: number; longitude: number },\n  ): ToiletLocation[] {\n    return toilets.filter(toilet => {\n      // 距離フィルター\n      if (filters.distance && userLocation) {\n        const distance = this.calculateDistance(\n          userLocation.latitude,\n          userLocation.longitude,\n          toilet.latitude,\n          toilet.longitude,\n        );\n        if (distance > filters.distance) {\n          return false;\n        }\n      }\n\n      // 営業時間フィルター（簡略化）\n      if (filters.openNow) {\n        // 実際の実装では営業時間データを使用\n        return true; // 常に営業中とみなす\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * 結果のソート\n   */\n  private sortResults(\n    toilets: ToiletLocation[],\n    sortBy: SortOption,\n    userLocation?: { latitude: number; longitude: number },\n  ): ToiletLocation[] {\n    switch (sortBy) {\n      case SortOption.DISTANCE:\n        return userLocation ? this.sortByDistance(toilets, userLocation) : toilets;\n\n      case SortOption.RATING:\n        return toilets.sort((a, b) => (b.rating || 0) - (a.rating || 0));\n\n      case SortOption.NEWEST:\n        return toilets.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n\n      case SortOption.HELPFUL:\n        return toilets.sort((a, b) => (b.reviewCount || 0) - (a.reviewCount || 0));\n\n      case SortOption.RELEVANCE:\n      default:\n        return toilets; // 関連度ソートは検索エンジンに依存\n    }\n  }\n\n  /**\n   * 距離でソート\n   */\n  private sortByDistance(\n    toilets: ToiletLocation[],\n    userLocation: { latitude: number; longitude: number },\n  ): ToiletLocation[] {\n    return toilets.sort((a, b) => {\n      const distanceA = this.calculateDistance(\n        userLocation.latitude,\n        userLocation.longitude,\n        a.latitude,\n        a.longitude,\n      );\n      const distanceB = this.calculateDistance(\n        userLocation.latitude,\n        userLocation.longitude,\n        b.latitude,\n        b.longitude,\n      );\n      return distanceA - distanceB;\n    });\n  }\n\n  /**\n   * 距離計算（ハーバイン公式）\n   */\n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371; // 地球の半径 (km)\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLon = this.toRadians(lon2 - lon1);\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(this.toRadians(lat1)) *\n        Math.cos(this.toRadians(lat2)) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  private toRadians(degrees: number): number {\n    return degrees * (Math.PI / 180);\n  }\n\n  /**\n   * 検索履歴を保存\n   */\n  async saveSearchHistory(\n    userId: string,\n    filters: SearchFilters,\n    resultCount: number,\n  ): Promise<void> {\n    try {\n      const historyData = {\n        id: this.searchHistoryCollection.doc().id,\n        userId,\n        query: filters.query,\n        filters,\n        resultCount,\n        searchedAt: firestore.Timestamp.now(),\n      };\n\n      await this.searchHistoryCollection.add(historyData);\n\n      // 古い履歴を削除（最新50件のみ保持）\n      const allHistory = await this.searchHistoryCollection\n        .where('userId', '==', userId)\n        .orderBy('searchedAt', 'desc')\n        .get();\n\n      if (allHistory.docs.length > 50) {\n        const batch = firestore().batch();\n        allHistory.docs.slice(50).forEach((doc: any) => {\n          batch.delete(doc.ref);\n        });\n        await batch.commit();\n      }\n    } catch (error) {\n      console.error('Failed to save search history:', error);\n    }\n  }\n\n  /**\n   * 検索履歴を取得\n   */\n  async getSearchHistory(userId: string, limit: number = 10): Promise<SearchHistory[]> {\n    try {\n      const snapshot = await this.searchHistoryCollection\n        .where('userId', '==', userId)\n        .orderBy('searchedAt', 'desc')\n        .limit(limit)\n        .get();\n\n      const history: SearchHistory[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        history.push({\n          id: data.id,\n          userId: data.userId,\n          query: data.query,\n          filters: data.filters,\n          resultCount: data.resultCount,\n          searchedAt: data.searchedAt.toDate(),\n        });\n      });\n\n      return history;\n    } catch (error) {\n      console.error('Failed to get search history:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 保存された検索条件を作成\n   */\n  async saveFavoriteSearch(userId: string, name: string, filters: SearchFilters): Promise<void> {\n    try {\n      const savedSearchData = {\n        id: this.savedSearchesCollection.doc().id,\n        userId,\n        name,\n        filters,\n        createdAt: firestore.Timestamp.now(),\n        lastUsed: firestore.Timestamp.now(),\n      };\n\n      await this.savedSearchesCollection.add(savedSearchData);\n    } catch (error) {\n      console.error('Failed to save favorite search:', error);\n      throw new Error('検索条件の保存に失敗しました');\n    }\n  }\n\n  /**\n   * 保存された検索条件を取得\n   */\n  async getSavedSearches(userId: string): Promise<SavedSearch[]> {\n    try {\n      const snapshot = await this.savedSearchesCollection\n        .where('userId', '==', userId)\n        .orderBy('lastUsed', 'desc')\n        .get();\n\n      const searches: SavedSearch[] = [];\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        searches.push({\n          id: data.id,\n          userId: data.userId,\n          name: data.name,\n          filters: data.filters,\n          createdAt: data.createdAt.toDate(),\n          lastUsed: data.lastUsed.toDate(),\n        });\n      });\n\n      return searches;\n    } catch (error) {\n      console.error('Failed to get saved searches:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 保存された検索条件を削除\n   */\n  async deleteSavedSearch(searchId: string): Promise<void> {\n    try {\n      await this.savedSearchesCollection.doc(searchId).delete();\n    } catch (error) {\n      console.error('Failed to delete saved search:', error);\n      throw new Error('検索条件の削除に失敗しました');\n    }\n  }\n}\n\n// シングルトンインスタンス\nexport const searchService = new SearchService();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/stores/authStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'get' is defined but never used. Allowed unused args must match /^_/u.","line":19,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":56},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":76,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":76,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1680,1712],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1872,1932],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":86,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":86,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2009,2064],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":91,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":91,"endColumn":22,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2172,2212],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":95,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":95,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2282,2346],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport { authService, User } from '../services/authService';\n\ninterface AuthState {\n  // 状態\n  user: User | null;\n  isLoading: boolean;\n  isInitialized: boolean;\n  error: string | null;\n\n  // アクション\n  signInWithGoogle: () => Promise<void>;\n  signOut: () => Promise<void>;\n  deleteAccount: () => Promise<void>;\n  clearError: () => void;\n  initialize: () => void;\n}\n\nexport const useAuthStore = create<AuthState>((set, get) => ({\n  // 初期状態\n  user: null,\n  isLoading: false,\n  isInitialized: false,\n  error: null,\n\n  // Googleサインイン\n  signInWithGoogle: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      const user = await authService.signInWithGoogle();\n      set({ user, isLoading: false });\n    } catch (error) {\n      set({\n        error: error instanceof Error ? error.message : 'サインインに失敗しました',\n        isLoading: false,\n      });\n    }\n  },\n\n  // サインアウト\n  signOut: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      await authService.signOut();\n      set({ user: null, isLoading: false });\n    } catch (error) {\n      set({\n        error: error instanceof Error ? error.message : 'サインアウトに失敗しました',\n        isLoading: false,\n      });\n    }\n  },\n\n  // アカウント削除\n  deleteAccount: async () => {\n    set({ isLoading: true, error: null });\n    try {\n      await authService.deleteAccount();\n      set({ user: null, isLoading: false });\n    } catch (error) {\n      set({\n        error: error instanceof Error ? error.message : 'アカウント削除に失敗しました',\n        isLoading: false,\n      });\n    }\n  },\n\n  // エラークリア\n  clearError: () => {\n    set({ error: null });\n  },\n\n  // 認証状態の初期化\n  initialize: () => {\n    try {\n      console.log('authStore: 初期化開始');\n      // 現在のユーザーを設定（エラーハンドリング付き）\n      let currentUser = null;\n      try {\n        currentUser = authService.getCurrentUser();\n      } catch (error) {\n        console.log('authStore: getCurrentUser でエラー（スキップ）:', error);\n      }\n      \n      set({ user: currentUser, isInitialized: true });\n      console.log('authStore: 初期化完了', { user: currentUser });\n\n      // 認証状態変更の監視を開始（エラーハンドリング付き）\n      try {\n        authService.onAuthStateChanged(user => {\n          console.log('authStore: 認証状態変更:', user);\n          set({ user });\n        });\n      } catch (error) {\n        console.log('authStore: onAuthStateChanged でエラー（スキップ）:', error);\n      }\n    } catch (error) {\n      console.error('authStore: 初期化でエラー:', error);\n      // エラーが発生しても初期化完了とする\n      set({ user: null, isInitialized: true });\n    }\n  },\n}));\n\n// 認証状態の便利なセレクター\nexport const useAuth = () => {\n  const { user, isLoading, error, isInitialized } = useAuthStore();\n  return {\n    user,\n    isLoading: !isInitialized || isLoading, // 初期化中もローディング扱い\n    error,\n    isAuthenticated: !!user,\n  };\n};\n\nexport const useAuthActions = () => {\n  const { signInWithGoogle, signOut, deleteAccount, clearError } = useAuthStore();\n  return {\n    signInWithGoogle,\n    signOut,\n    deleteAccount,\n    clearError,\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/stores/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/test-utils/index.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2343,2346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2343,2346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2584,2587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2584,2587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2728,2731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2728,2731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { ReactElement } from 'react';\nimport { render, RenderOptions } from '@testing-library/react-native';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { SafeAreaProvider } from 'react-native-safe-area-context';\n\n// カスタムレンダラー\ninterface CustomRenderOptions extends RenderOptions {\n  initialRouteName?: string;\n}\n\nconst AllTheProviders: React.FC<{ children: React.ReactNode }> = ({ children }) => (\n  <SafeAreaProvider>\n    <NavigationContainer>{children}</NavigationContainer>\n  </SafeAreaProvider>\n);\n\nconst customRender = (ui: ReactElement, options?: CustomRenderOptions) =>\n  render(ui, { wrapper: AllTheProviders, ...options });\n\n// re-export everything\nexport * from '@testing-library/react-native';\n\n// override render method\nexport { customRender as render };\n\n// テスト用のmockデータ\nexport const mockUser = {\n  uid: 'test-user-123',\n  email: 'test@example.com',\n  displayName: 'Test User',\n  photoURL: null,\n};\n\nexport const mockToilet = {\n  id: 'toilet-123',\n  title: 'Test Toilet',\n  type: 'public' as const,\n  coordinates: { latitude: 35.6762, longitude: 139.6503 },\n  description: 'Test description',\n  rating: 4.5,\n  reviewCount: 10,\n  isAccessible: true,\n  facilities: {\n    hasWashlet: true,\n    hasHandDryer: false,\n    hasBabyChanging: false,\n    hasMultiPurpose: false,\n    hasPaperTowels: true,\n    hasHandSoap: true,\n    hasVendingMachine: false,\n  },\n  createdAt: new Date('2024-01-01'),\n  updatedAt: new Date('2024-01-01'),\n  authorId: 'author-123',\n};\n\nexport const mockReport = {\n  id: 'report-123',\n  reporterId: mockUser.uid,\n  targetType: 'toilet' as const,\n  targetId: mockToilet.id,\n  reason: 'inappropriate_content' as const,\n  description: 'Test report description',\n  status: 'pending' as const,\n  createdAt: new Date('2024-01-01'),\n};\n\n// Navigation mock helpers\nexport const mockNavigation = {\n  navigate: jest.fn(),\n  goBack: jest.fn(),\n  reset: jest.fn(),\n  setOptions: jest.fn(),\n  addListener: jest.fn(),\n  removeListener: jest.fn(),\n  canGoBack: jest.fn(() => true),\n  isFocused: jest.fn(() => true),\n};\n\nexport const mockRoute = {\n  key: 'test-route',\n  name: 'TestScreen',\n  params: {},\n};\n\n// 非同期処理のヘルパー\nexport const waitForAsync = (ms: number = 0) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Firestore mockデータ生成ヘルパー\nexport const createMockFirestoreDoc = (data: any) => ({\n  id: data.id || 'mock-id',\n  data: () => data,\n  exists: true,\n  ref: {\n    update: jest.fn(() => Promise.resolve()),\n    delete: jest.fn(() => Promise.resolve()),\n  },\n});\n\nexport const createMockFirestoreQuerySnapshot = (docs: any[]) => ({\n  empty: docs.length === 0,\n  size: docs.length,\n  docs: docs.map(doc => createMockFirestoreDoc(doc)),\n  forEach: (callback: (doc: any) => void) => {\n    docs.forEach(doc => callback(createMockFirestoreDoc(doc)));\n  },\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/types/maps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/types/post.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":390,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":390,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9083,9086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9083,9086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":456,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":456,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10901,10904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10901,10904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":589,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":589,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14058,14061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14058,14061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ToiletType, Coordinate } from './maps';\n\n// 複数トイレに対応した投稿フォームデータ型\nexport interface ToiletPostForm {\n  // 施設全体の情報\n  facilityTitle: string; // 施設名（例: 東京駅丸の内口）\n  facilityDescription: string; // 施設の説明\n  type: ToiletType;\n  location: Coordinate | null;\n  openingHours: OpeningHours;\n  facilityImages: string[]; // 施設全体の画像\n\n  // 複数のトイレ情報\n  toilets: ToiletInfo[]; // 個別のトイレ情報配列\n\n  // その他\n  additionalInfo: string;\n}\n\n// 個別のトイレ情報\nexport interface ToiletInfo {\n  id: string; // トイレID（ランダム生成）\n  title: string; // トイレ名（例: 1階男性用トイレ）\n  description: string; // トイレの説明\n  floor?: string; // 階数（例: 1F, B1）\n  location?: string; // 位置（例: 改札内、北口近く）\n  isAccessible: boolean; // バリアフリー対応\n  images: string[]; // トイレの画像\n  facilities: ToiletFacilities; // 基本設備\n  detailedEquipment: DetailedToiletEquipment; // 詳細設備\n  ratings: ToiletRatings; // 評価\n}\n\n// トイレ設備情報\nexport interface ToiletFacilities {\n  hasWashlet: boolean; // ウォシュレット\n  hasHandDryer: boolean; // ハンドドライヤー\n  hasBabyChanging: boolean; // おむつ台\n  hasMultiPurpose: boolean; // 多目的トイレ\n  hasPaperTowels: boolean; // ペーパータオル\n  hasHandSoap: boolean; // ハンドソープ\n  hasVendingMachine: boolean; // 自動販売機\n}\n\n// 営業時間\nexport interface OpeningHours {\n  is24Hours: boolean;\n  openTime?: string; // \"09:00\"\n  closeTime?: string; // \"21:00\"\n  notes?: string; // 特記事項\n}\n\n// 詳細なトイレ設備情報\nexport interface DetailedToiletEquipment {\n  genderType: 'separate' | 'shared' | 'multipurpose'; // 男女別/共用/多目的\n\n  // 男性用設備（男女別の場合）\n  maleEquipment: {\n    urinals: number; // 小便器数\n    westernToilets: number; // 洋式便器数\n  } | null;\n\n  // 女性用設備（男女別の場合）\n  femaleEquipment: {\n    japaneseToilets: number; // 和式便器数\n    westernToilets: number; // 洋式便器数\n  } | null;\n\n  // 共用設備（共用/多目的の場合）\n  sharedEquipment: {\n    japaneseToilets: number; // 和式便器数\n    westernToilets: number; // 洋式便器数\n  } | null;\n\n  // 追加設備\n  additionalFeatures: {\n    hasBabyChangingTable: boolean; // おむつ替え台\n    hasHandDryer: boolean; // ハンドドライヤー\n    hasWashlet: boolean; // ウォシュレット\n    hasPaperTowels: boolean; // ペーパータオル\n    hasHandSoap: boolean; // ハンドソープ\n    hasVendingMachine: boolean; // 自動販売機\n    hasWheelchairAccess: boolean; // 車椅子対応\n  };\n}\n\n// 6つの評価軸\nexport interface ToiletRatings {\n  overall: number; // 総合評価（1-5、必須）\n  cleanliness?: number; // 掃除状況（1-5、任意）\n  newness?: number; // 新しさ（1-5、任意）\n  smell?: number; // 臭い（1-5、任意）\n  userManners?: number; // 利用者マナー（1-5、任意）\n  pestControl?: number; // 害虫の有無（1-5、任意）\n}\n\n// 個別トイレの初期値\nexport const initialToiletInfo: ToiletInfo = {\n  id: '',\n  title: '',\n  description: '',\n  floor: '',\n  location: '',\n  isAccessible: false,\n  images: [],\n  facilities: {\n    hasWashlet: false,\n    hasHandDryer: false,\n    hasBabyChanging: false,\n    hasMultiPurpose: false,\n    hasPaperTowels: false,\n    hasHandSoap: false,\n    hasVendingMachine: false,\n  },\n  detailedEquipment: {\n    genderType: 'separate',\n    maleEquipment: {\n      urinals: 0,\n      westernToilets: 0,\n    },\n    femaleEquipment: {\n      japaneseToilets: 0,\n      westernToilets: 0,\n    },\n    sharedEquipment: null,\n    additionalFeatures: {\n      hasBabyChangingTable: false,\n      hasHandDryer: false,\n      hasWashlet: false,\n      hasPaperTowels: false,\n      hasHandSoap: false,\n      hasVendingMachine: false,\n      hasWheelchairAccess: false,\n    },\n  },\n  ratings: {\n    overall: 5,\n    cleanliness: undefined,\n    newness: undefined,\n    smell: undefined,\n    userManners: undefined,\n    pestControl: undefined,\n  },\n};\n\n// 投稿フォームの初期値\nexport const initialToiletPostForm: ToiletPostForm = {\n  facilityTitle: '',\n  facilityDescription: '',\n  type: ToiletType.PUBLIC,\n  location: null,\n  openingHours: {\n    is24Hours: true,\n    openTime: undefined,\n    closeTime: undefined,\n    notes: '',\n  },\n  facilityImages: [],\n  toilets: [{ ...initialToiletInfo, id: 'toilet_1' }], // 最初は1つのトイレ\n  additionalInfo: '',\n};\n\n// バリデーション関数\nexport const validateToiletPost = (\n  form: ToiletPostForm,\n): { isValid: boolean; errors: string[] } => {\n  const errors: string[] = [];\n\n  // 施設情報の必須フィールドのチェック\n  if (!form.facilityTitle.trim()) {\n    errors.push('施設名は必須です');\n  }\n\n  if (form.facilityTitle.length > 100) {\n    errors.push('施設名は100文字以内で入力してください');\n  }\n\n  if (!form.location) {\n    errors.push('位置情報を設定してください');\n  }\n\n  if (form.facilityDescription.length > 500) {\n    errors.push('施設説明は500文字以内で入力してください');\n  }\n\n  if (form.additionalInfo.length > 300) {\n    errors.push('追加情報は300文字以内で入力してください');\n  }\n\n  // 営業時間のチェック\n  if (!form.openingHours.is24Hours) {\n    if (!form.openingHours.openTime || !form.openingHours.closeTime) {\n      errors.push('営業時間を設定してください');\n    }\n  }\n\n  // トイレ情報のチェック\n  if (form.toilets.length === 0) {\n    errors.push('少なくとも1つのトイレ情報を追加してください');\n  }\n\n  form.toilets.forEach((toilet, index) => {\n    if (!toilet.title.trim()) {\n      errors.push(`トイレ${index + 1}: タイトルは必須です`);\n    }\n\n    if (toilet.title.length > 50) {\n      errors.push(`トイレ${index + 1}: タイトルは50文字以内で入力してください`);\n    }\n\n    if (toilet.description.length > 500) {\n      errors.push(`トイレ${index + 1}: 説明は500文字以内で入力してください`);\n    }\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n// 画像のバリデーション\nexport const validateImages = (images: string[]): { isValid: boolean; errors: string[] } => {\n  const errors: string[] = [];\n\n  if (images.length > 5) {\n    errors.push('画像は5枚まで投稿可能です');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n// トイレタイプの選択肢\nexport const toiletTypeOptions = [\n  { value: ToiletType.PUBLIC, label: '公共トイレ', icon: '🚻' },\n  { value: ToiletType.CONVENIENCE_STORE, label: 'コンビニ', icon: '🏪' },\n  { value: ToiletType.STATION, label: '駅', icon: '🚉' },\n  { value: ToiletType.PARK, label: '公園', icon: '🌳' },\n  { value: ToiletType.SHOPPING_MALL, label: 'ショッピングモール', icon: '🏬' },\n  { value: ToiletType.RESTAURANT, label: 'レストラン・カフェ', icon: '🍽️' },\n  { value: ToiletType.GAS_STATION, label: 'ガソリンスタンド', icon: '⛽' },\n  { value: ToiletType.OTHER, label: 'その他', icon: '🚽' },\n];\n\n// 設備アイコン\nexport const facilityIcons = {\n  hasWashlet: '🚿',\n  hasHandDryer: '💨',\n  hasBabyChanging: '👶',\n  hasMultiPurpose: '♿',\n  hasPaperTowels: '🧻',\n  hasHandSoap: '🧼',\n  hasVendingMachine: '🏪',\n};\n\n// 設備ラベル\nexport const facilityLabels = {\n  hasWashlet: 'ウォシュレット',\n  hasHandDryer: 'ハンドドライヤー',\n  hasBabyChanging: 'おむつ台',\n  hasMultiPurpose: '多目的トイレ',\n  hasPaperTowels: 'ペーパータオル',\n  hasHandSoap: 'ハンドソープ',\n  hasVendingMachine: '自動販売機',\n};\n\n// 評価軸の定義\nexport const ratingCategories = [\n  {\n    key: 'overall' as keyof ToiletRatings,\n    label: '総合評価',\n    icon: '⭐',\n    required: true,\n    description: '全体的な満足度',\n  },\n  {\n    key: 'cleanliness' as keyof ToiletRatings,\n    label: '掃除状況',\n    icon: '🧹',\n    required: false,\n    description: 'きれいに清掃されているか',\n  },\n  {\n    key: 'newness' as keyof ToiletRatings,\n    label: '新しさ',\n    icon: '🏢',\n    required: false,\n    description: '設備の新しさ・きれいさ',\n  },\n  {\n    key: 'smell' as keyof ToiletRatings,\n    label: '臭い',\n    icon: '👃',\n    required: false,\n    description: '嫌な臭いがしないか',\n  },\n  {\n    key: 'userManners' as keyof ToiletRatings,\n    label: '利用者マナー',\n    icon: '👥',\n    required: false,\n    description: '汚され方・マナー・治安',\n  },\n  {\n    key: 'pestControl' as keyof ToiletRatings,\n    label: '害虫の有無',\n    icon: '🐛',\n    required: false,\n    description: '虫や衛生害獣がいないか',\n  },\n];\n\n// 男女区分の選択肢\nexport const genderTypeOptions = [\n  { value: 'separate', label: '男女別', icon: '🚻' },\n  { value: 'shared', label: '男女共用', icon: '🚽' },\n  { value: 'multipurpose', label: '多目的トイレ', icon: '♿' },\n];\n\n// 「役に立った」機能の型定義\nexport interface HelpfulVote {\n  id: string;\n  userId: string;\n  toiletId: string;\n  isHelpful: boolean; // true: 役に立った, false: 役に立たなかった\n  createdAt: Date;\n}\n\n// 役に立った投票の統計\nexport interface HelpfulStats {\n  helpfulCount: number; // 役に立った数\n  notHelpfulCount: number; // 役に立たなかった数\n  totalVotes: number; // 総投票数\n  helpfulRatio: number; // 役に立った比率 (0-1)\n}\n\n// バッジシステムの型定義\nexport interface Badge {\n  id: string;\n  name: string; // バッジ名\n  description: string; // バッジの説明\n  icon: string; // バッジのアイコン（絵文字）\n  category: BadgeCategory;\n  condition: BadgeCondition;\n  rarity: BadgeRarity; // レア度\n  unlockedAt?: Date; // 取得日時\n}\n\nexport enum BadgeCategory {\n  POSTING = 'posting', // 投稿関連\n  REVIEWING = 'reviewing', // レビュー関連\n  EXPLORATION = 'exploration', // 探索関連\n  COMMUNITY = 'community', // コミュニティ関連\n  SPECIAL = 'special', // 特別バッジ\n}\n\nexport enum BadgeRarity {\n  COMMON = 'common', // よくある（ブロンズ）\n  UNCOMMON = 'uncommon', // 珍しい（シルバー）\n  RARE = 'rare', // レア（ゴールド）\n  EPIC = 'epic', // エピック（プラチナ）\n  LEGENDARY = 'legendary', // 伝説（ダイヤモンド）\n}\n\nexport interface BadgeCondition {\n  type: 'count' | 'streak' | 'rating' | 'special';\n  target: string; // 対象（例: 'toilets_posted', 'helpful_votes'）\n  value: number; // 必要な値\n  timeframe?: 'daily' | 'weekly' | 'monthly' | 'yearly'; // 期間制限\n}\n\n// ユーザーのバッジ取得状況\nexport interface UserBadges {\n  userId: string;\n  unlockedBadges: string[]; // 取得済みバッジID配列\n  progress: Record<string, number>; // バッジごとの進捗\n  lastChecked: Date; // 最後にチェックした日時\n}\n\n// プッシュ通知システムの型定義\nexport interface PushNotification {\n  id: string;\n  userId: string;\n  type: NotificationType;\n  title: string;\n  body: string;\n  data?: Record<string, any>; // 追加データ（画面遷移用など）\n  isRead: boolean;\n  createdAt: Date;\n  scheduledAt?: Date; // 予約送信時刻\n}\n\nexport enum NotificationType {\n  BADGE_UNLOCKED = 'badge_unlocked', // バッジ取得\n  HELPFUL_VOTE = 'helpful_vote', // 「役に立った」投票\n  NEW_TOILET_NEARBY = 'new_toilet_nearby', // 近くの新しいトイレ\n  TOILET_UPDATED = 'toilet_updated', // トイレ情報更新\n  MAINTENANCE_ALERT = 'maintenance_alert', // メンテナンス通知\n  COMMUNITY_NEWS = 'community_news', // コミュニティニュース\n  WEEKLY_SUMMARY = 'weekly_summary', // 週間サマリー\n  ACHIEVEMENT_REMINDER = 'achievement_reminder', // 達成リマインダー\n}\n\n// 通知設定\nexport interface NotificationSettings {\n  userId: string;\n  enabled: boolean; // 通知全体のON/OFF\n  badgeNotifications: boolean; // バッジ通知\n  helpfulVoteNotifications: boolean; // 「役に立った」通知\n  nearbyToiletNotifications: boolean; // 近くのトイレ通知\n  updateNotifications: boolean; // 更新通知\n  newsNotifications: boolean; // ニュース通知\n  summaryNotifications: boolean; // サマリー通知\n  reminderNotifications: boolean; // リマインダー通知\n  quietHoursEnabled: boolean; // サイレント時間\n  quietHoursStart: string; // サイレント開始時刻 \"22:00\"\n  quietHoursEnd: string; // サイレント終了時刻 \"08:00\"\n  updatedAt: Date;\n}\n\n// プッシュトークン情報\nexport interface PushToken {\n  userId: string;\n  token: string;\n  platform: 'ios' | 'android';\n  isActive: boolean;\n  lastUsed: Date;\n  createdAt: Date;\n}\n\n// 検索・フィルター機能の型定義\nexport interface SearchFilters {\n  query: string; // 検索クエリ\n  toiletType?: ToiletType; // トイレタイプ\n  isAccessible?: boolean; // バリアフリー\n  hasWashlet?: boolean; // ウォシュレット\n  rating?: number; // 最低評価\n  distance?: number; // 距離（km）\n  openNow?: boolean; // 現在営業中\n  sortBy: SortOption; // ソート方法\n}\n\nexport enum SortOption {\n  RELEVANCE = 'relevance', // 関連度\n  DISTANCE = 'distance', // 距離\n  RATING = 'rating', // 評価\n  NEWEST = 'newest', // 新しい順\n  HELPFUL = 'helpful', // 役に立った順\n}\n\n// 検索結果\nexport interface SearchResult {\n  toilets: any[]; // ToiletLocationは別ファイルで定義されているため、anyを使用\n  totalCount: number;\n  hasMore: boolean;\n  searchTime: number; // 検索時間（ms）\n}\n\n// 保存された検索条件\nexport interface SavedSearch {\n  id: string;\n  userId: string;\n  name: string; // 検索条件の名前\n  filters: SearchFilters;\n  createdAt: Date;\n  lastUsed: Date;\n}\n\n// 検索履歴\nexport interface SearchHistory {\n  id: string;\n  userId: string;\n  query: string;\n  filters: SearchFilters;\n  resultCount: number;\n  searchedAt: Date;\n}\n\n// 履歴・お気に入り機能の型定義\nexport interface ViewHistory {\n  id: string;\n  userId: string;\n  toiletId: string;\n  toiletTitle: string;\n  toiletType: string;\n  viewedAt: Date;\n  viewCount: number; // 同じトイレを見た回数\n}\n\nexport interface Favorite {\n  id: string;\n  userId: string;\n  toiletId: string;\n  toiletTitle: string;\n  toiletType: string;\n  addedAt: Date;\n  lastViewed?: Date;\n}\n\n// ユーザーアクティビティ\nexport interface UserActivity {\n  id: string;\n  userId: string;\n  type: ActivityType;\n  targetId: string; // トイレID、バッジIDなど\n  targetTitle: string; // 対象の名前\n  description: string; // アクティビティの説明\n  createdAt: Date;\n}\n\nexport enum ActivityType {\n  TOILET_POSTED = 'toilet_posted', // トイレ投稿\n  TOILET_UPDATED = 'toilet_updated', // トイレ更新\n  HELPFUL_VOTE = 'helpful_vote', // 役に立った投票\n  BADGE_EARNED = 'badge_earned', // バッジ取得\n  FAVORITE_ADDED = 'favorite_added', // お気に入り追加\n  REVIEW_POSTED = 'review_posted', // レビュー投稿\n}\n\n// 統計情報\nexport interface UserStats {\n  userId: string;\n  totalPosts: number; // 総投稿数\n  totalViews: number; // 総閲覧数\n  totalFavorites: number; // お気に入り数\n  totalHelpfulVotes: number; // 役に立った投票数\n  totalBadges: number; // 取得バッジ数\n  joinedAt: Date; // 参加日\n  lastActiveAt: Date; // 最終アクティブ日時\n  streak: number; // 連続投稿日数\n}\n\n// 通報機能の型定義\nexport interface Report {\n  id: string;\n  reporterId: string; // 通報者ID\n  targetType: ReportTargetType; // 通報対象種別\n  targetId: string; // 対象ID（トイレID、ユーザーIDなど）\n  reason: ReportReason; // 通報理由\n  description?: string; // 詳細説明\n  evidence?: string[]; // 証拠画像URL\n  status: ReportStatus; // 処理状況\n  createdAt: Date; // 通報日時\n  reviewedAt?: Date; // 審査日時\n  reviewerId?: string; // 審査者ID\n  resolution?: string; // 処理結果\n}\n\nexport enum ReportTargetType {\n  TOILET = 'toilet', // トイレ投稿\n  REVIEW = 'review', // レビュー\n  USER = 'user', // ユーザー\n  COMMENT = 'comment', // コメント\n}\n\nexport enum ReportReason {\n  INAPPROPRIATE_CONTENT = 'inappropriate_content', // 不適切なコンテンツ\n  SPAM = 'spam', // スパム\n  HARASSMENT = 'harassment', // 嫌がらせ\n  FAKE_INFORMATION = 'fake_information', // 虚偽情報\n  COPYRIGHT_VIOLATION = 'copyright_violation', // 著作権侵害\n  PRIVACY_VIOLATION = 'privacy_violation', // プライバシー侵害\n  COMMERCIAL_SPAM = 'commercial_spam', // 商業的スパム\n  HATE_SPEECH = 'hate_speech', // ヘイトスピーチ\n  OTHER = 'other', // その他\n}\n\nexport enum ReportStatus {\n  PENDING = 'pending', // 審査待ち\n  UNDER_REVIEW = 'under_review', // 審査中\n  RESOLVED = 'resolved', // 解決済み\n  DISMISSED = 'dismissed', // 却下\n  AUTO_RESOLVED = 'auto_resolved', // 自動解決\n}\n\n// 自動制限システム\nexport interface UserRestriction {\n  id: string;\n  userId: string;\n  type: RestrictionType;\n  reason: string;\n  startDate: Date;\n  endDate?: Date; // 永久制限の場合はnull\n  isActive: boolean;\n  createdBy: 'system' | 'admin'; // システム自動 or 管理者手動\n  details?: Record<string, any>; // 制限の詳細情報\n}\n\nexport enum RestrictionType {\n  POST_RESTRICTION = 'post_restriction', // 投稿制限\n  COMMENT_RESTRICTION = 'comment_restriction', // コメント制限\n  REVIEW_RESTRICTION = 'review_restriction', // レビュー制限\n  VOTE_RESTRICTION = 'vote_restriction', // 投票制限\n  TEMPORARY_BAN = 'temporary_ban', // 一時停止\n  PERMANENT_BAN = 'permanent_ban', // 永久停止\n  WARNING = 'warning', // 警告\n}\n\n// 違反行為の記録\nexport interface ViolationRecord {\n  id: string;\n  userId: string;\n  type: ViolationType;\n  severity: ViolationSeverity;\n  description: string;\n  evidence?: string[];\n  reportId?: string; // 関連する通報ID\n  autoDetected: boolean; // 自動検出かどうか\n  points: number; // 違反ポイント\n  createdAt: Date;\n  expiresAt?: Date; // ポイント失効日\n}\n\nexport enum ViolationType {\n  SPAM_POSTING = 'spam_posting',\n  INAPPROPRIATE_CONTENT = 'inappropriate_content',\n  HARASSMENT = 'harassment',\n  FAKE_INFORMATION = 'fake_information',\n  MULTIPLE_ACCOUNTS = 'multiple_accounts',\n  VOTE_MANIPULATION = 'vote_manipulation',\n  COMMERCIAL_SPAM = 'commercial_spam',\n}\n\nexport enum ViolationSeverity {\n  LOW = 'low', // 軽微（1-2ポイント）\n  MEDIUM = 'medium', // 中程度（3-5ポイント）\n  HIGH = 'high', // 重大（6-10ポイント）\n  CRITICAL = 'critical', // 極めて重大（11+ポイント）\n}\n\n// 制限の自動判定設定\nexport interface AutoRestrictionConfig {\n  maxViolationPoints: number; // 制限発動ポイント閾値\n  pointExpirationDays: number; // ポイント失効日数\n  restrictions: {\n    [key: number]: {\n      // ポイント数をキーとする\n      type: RestrictionType;\n      durationDays?: number; // 制限期間（日数）\n      message: string; // ユーザーへの通知メッセージ\n    };\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]},{"filePath":"/Users/saaya.aizawa/yotas/yotas/src/utils/mapUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-negated-in-lhs","replacedBy":["no-unsafe-negation"]},{"ruleId":"no-catch-shadow","replacedBy":["no-shadow"]},{"ruleId":"handle-callback-err","replacedBy":[]},{"ruleId":"no-mixed-requires","replacedBy":[]},{"ruleId":"no-new-require","replacedBy":[]},{"ruleId":"no-path-concat","replacedBy":[]},{"ruleId":"no-restricted-modules","replacedBy":[]},{"ruleId":"no-new-object","replacedBy":["no-object-constructor"]}]}]
